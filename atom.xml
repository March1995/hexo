<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Marcher</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://marchnineteen.github.io/"/>
  <updated>2023-05-08T01:44:57.935Z</updated>
  <id>https://marchnineteen.github.io/</id>
  
  <author>
    <name>Marcher</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mybatis-plus 原理</title>
    <link href="https://marchnineteen.github.io/2022/08/08/mybatis/mybatis-plus/"/>
    <id>https://marchnineteen.github.io/2022/08/08/mybatis/mybatis-plus/</id>
    <published>2022-08-08T00:00:00.000Z</published>
    <updated>2023-05-08T01:44:57.935Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MapperScan"><a href="#MapperScan" class="headerlink" title="@MapperScan"></a>@MapperScan</h3><p>@MapperScan的作用可以理解为@Import注解 + @MapperScan中配置的包名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span>(proxyTargetClass = <span class="keyword">true</span>, exposeProxy = <span class="keyword">true</span>)</span><br><span class="line"><span class="meta">@EnableFeignClients</span>(&#123;<span class="string">"com.***.***.common.proxy.api"</span>&#125;)</span><br><span class="line"><span class="meta">@EnableApolloConfig</span>(<span class="string">"application"</span>)</span><br><span class="line"><span class="meta">@MapperScan</span>(<span class="string">"com.***.***.backend.**.dao"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SopBackendApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SopBackendApplication<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SpringBoot启动时会记录启动类上的注解信息，然后Spring会通过ConfigurationClassPostProcessor解析对应的注解bean，<br>当获取到@MapperScan注解中有@Import注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(MapperScannerRegistrar<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">Repeatable</span>(<span class="title">MapperScans</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">MapperScan</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后会通过ConfigurationClassPostProcessor类把@Import中的MapperScannerRegistrar加入到Spring的启动逻辑中，<br>因为MapperScannerRegistrar实现了Spring的ImportBeanDefinitionRegistrar接口，所以会被调用到registerBeanDefinitions()方法。<br>而registerBeanDefinitions()方法的逻辑会判断类上面是否有@MapperScan注解，<br>有的话就会通过MapperScannerConfigurer扫描@MapperScan配置的目录，<br>通过ClassPathMapperScanner类扫描@Mapperscan配置目录下的所有加了@Repository注解的mapper，<br>并生成对应的beandefinition信息保存到spring容器中，<br>其中这些beandefinition的beanclass被设置成了MapperFactoryBean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RepeatingRegistrar</span> <span class="keyword">extends</span> <span class="title">MapperScannerRegistrar</span> </span>&#123;</span><br><span class="line">    RepeatingRegistrar() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        AnnotationAttributes mapperScansAttrs = AnnotationAttributes.fromMap(importingClassMetadata.getAnnotationAttributes(MapperScans<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()))</span>;</span><br><span class="line">        <span class="keyword">if</span> (mapperScansAttrs != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Arrays.stream(mapperScansAttrs.getAnnotationArray(<span class="string">"value"</span>)).forEach((mapperScanAttrs) -&gt; &#123;</span><br><span class="line">                <span class="keyword">this</span>.registerBeanDefinitions(mapperScanAttrs, registry);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationAttributes annoAttrs, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        ClassPathMapperScanner scanner = <span class="keyword">new</span> ClassPathMapperScanner(registry);</span><br><span class="line">        Optional.ofNullable(<span class="keyword">this</span>.resourceLoader).ifPresent(scanner::setResourceLoader);</span><br><span class="line">        Class&lt;? extends Annotation&gt; annotationClass = annoAttrs.getClass(<span class="string">"annotationClass"</span>);</span><br><span class="line">        <span class="keyword">if</span> (!Annotation<span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">annotationClass</span>)) </span>&#123;</span><br><span class="line">            scanner.setAnnotationClass(annotationClass);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; markerInterface = annoAttrs.getClass(<span class="string">"markerInterface"</span>);</span><br><span class="line">        <span class="keyword">if</span> (!Class<span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">markerInterface</span>)) </span>&#123;</span><br><span class="line">            scanner.setMarkerInterface(markerInterface);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Class&lt;? extends BeanNameGenerator&gt; generatorClass = annoAttrs.getClass(<span class="string">"nameGenerator"</span>);</span><br><span class="line">        <span class="keyword">if</span> (!BeanNameGenerator<span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">generatorClass</span>)) </span>&#123;</span><br><span class="line">            scanner.setBeanNameGenerator((BeanNameGenerator) BeanUtils.instantiateClass(generatorClass));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Class&lt;? extends MapperFactoryBean&gt; mapperFactoryBeanClass = annoAttrs.getClass(<span class="string">"factoryBean"</span>);</span><br><span class="line">        <span class="keyword">if</span> (!MapperFactoryBean<span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">mapperFactoryBeanClass</span>)) </span>&#123;</span><br><span class="line">            scanner.setMapperFactoryBean((MapperFactoryBean) BeanUtils.instantiateClass(mapperFactoryBeanClass));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        scanner.setSqlSessionTemplateBeanName(annoAttrs.getString(<span class="string">"sqlSessionTemplateRef"</span>));</span><br><span class="line">        scanner.setSqlSessionFactoryBeanName(annoAttrs.getString(<span class="string">"sqlSessionFactoryRef"</span>));</span><br><span class="line">        List&lt;String&gt; basePackages = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        basePackages.addAll((Collection) Arrays.stream(annoAttrs.getStringArray(<span class="string">"value"</span>)).filter(StringUtils::hasText).collect(Collectors.toList()));</span><br><span class="line">        basePackages.addAll((Collection) Arrays.stream(annoAttrs.getStringArray(<span class="string">"basePackages"</span>)).filter(StringUtils::hasText).collect(Collectors.toList()));</span><br><span class="line">        basePackages.addAll((Collection) Arrays.stream(annoAttrs.getClassArray(<span class="string">"basePackageClasses"</span>)).map(ClassUtils::getPackageName).collect(Collectors.toList()));</span><br><span class="line">        scanner.registerFilters();</span><br><span class="line">        scanner.doScan(StringUtils.toStringArray(basePackages));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>doScan–&gt;processBeanDefinitions</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathMapperScanner</span> <span class="keyword">extends</span> <span class="title">ClassPathBeanDefinitionScanner</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processBeanDefinitions</span><span class="params">(Set&lt;BeanDefinitionHolder&gt; beanDefinitions)</span> </span>&#123;</span><br><span class="line">        GenericBeanDefinition definition;</span><br><span class="line">        <span class="keyword">for</span> (BeanDefinitionHolder holder : beanDefinitions) &#123;</span><br><span class="line">            definition = (GenericBeanDefinition) holder.getBeanDefinition();</span><br><span class="line">            String beanClassName = definition.getBeanClassName();</span><br><span class="line">            LOGGER.debug(() -&gt; <span class="string">"Creating MapperFactoryBean with name '"</span> + holder.getBeanName()</span><br><span class="line">                    + <span class="string">"' and '"</span> + beanClassName + <span class="string">"' mapperInterface"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// the mapper interface is the original class of the bean</span></span><br><span class="line">            <span class="comment">// but, the actual class of the bean is MapperFactoryBean</span></span><br><span class="line">            definition.getConstructorArgumentValues().addGenericArgumentValue(beanClassName); <span class="comment">// issue #59</span></span><br><span class="line">            definition.setBeanClass(<span class="keyword">this</span>.mapperFactoryBean.getClass());</span><br><span class="line"></span><br><span class="line">            definition.getPropertyValues().add(<span class="string">"addToConfig"</span>, <span class="keyword">this</span>.addToConfig);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> explicitFactoryUsed = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasText(<span class="keyword">this</span>.sqlSessionFactoryBeanName)) &#123;</span><br><span class="line">                definition.getPropertyValues().add(<span class="string">"sqlSessionFactory"</span>, <span class="keyword">new</span> RuntimeBeanReference(<span class="keyword">this</span>.sqlSessionFactoryBeanName));</span><br><span class="line">                explicitFactoryUsed = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.sqlSessionFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">                definition.getPropertyValues().add(<span class="string">"sqlSessionFactory"</span>, <span class="keyword">this</span>.sqlSessionFactory);</span><br><span class="line">                explicitFactoryUsed = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasText(<span class="keyword">this</span>.sqlSessionTemplateBeanName)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (explicitFactoryUsed) &#123;</span><br><span class="line">                    LOGGER.warn(() -&gt; <span class="string">"Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                definition.getPropertyValues().add(<span class="string">"sqlSessionTemplate"</span>, <span class="keyword">new</span> RuntimeBeanReference(<span class="keyword">this</span>.sqlSessionTemplateBeanName));</span><br><span class="line">                explicitFactoryUsed = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.sqlSessionTemplate != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (explicitFactoryUsed) &#123;</span><br><span class="line">                    LOGGER.warn(() -&gt; <span class="string">"Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                definition.getPropertyValues().add(<span class="string">"sqlSessionTemplate"</span>, <span class="keyword">this</span>.sqlSessionTemplate);</span><br><span class="line">                explicitFactoryUsed = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!explicitFactoryUsed) &#123;</span><br><span class="line">                LOGGER.debug(() -&gt; <span class="string">"Enabling autowire by type for MapperFactoryBean with name '"</span> + holder.getBeanName() + <span class="string">"'."</span>);</span><br><span class="line">                definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而MapperFactoryBean实现了spring的FactoryBean接口，当spring通过BeanDefinitionMap创建bean的过程中，<br>会调用MapperFactoryBean的getObject()方法生成xxxMapper接口的代理对象MybatisMapperProxy。<br>到此Mapper接口就可以有代理对象被调用了。</p><h3 id="xxxMapper-xml"><a href="#xxxMapper-xml" class="headerlink" title="xxxMapper.xml"></a>xxxMapper.xml</h3><p>MybatisPlusAutoConfiguration被spring解释的时候，通过调用sqlSessionFactory()方法，<br>加载默认路径下mapper.xml文件，保存到MappedStatement中，<br>包括查询类型，sql语句，参数信息等，通过namespace和mapper对应上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Accessors</span>(chain = <span class="keyword">true</span>)</span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = Constants.MYBATIS_PLUS)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisPlusProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String[] mapperLocations = <span class="keyword">new</span> String[]&#123;<span class="string">"classpath*:/mapper/**/*.xml"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Resource[] resolveMapperLocations() &#123;</span><br><span class="line">        <span class="keyword">return</span> Stream.of(Optional.ofNullable(<span class="keyword">this</span>.mapperLocations).orElse(<span class="keyword">new</span> String[<span class="number">0</span>]))</span><br><span class="line">                .flatMap(location -&gt; Stream.of(getResources(location)))</span><br><span class="line">                .toArray(Resource[]::<span class="keyword">new</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Resource[] getResources(String location) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> resourceResolver.getResources(location);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Resource[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisSqlSessionFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">SqlSessionFactory</span>&gt;, <span class="title">InitializingBean</span>, <span class="title">ApplicationListener</span>&lt;<span class="title">ApplicationEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.mapperLocations !=<span class="keyword">null</span>)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.mapperLocations.length == <span class="number">0</span>) &#123;</span><br><span class="line">            LOGGER.warn(() -&gt; <span class="string">"Property 'mapperLocations' was specified but matching resources are not found."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Resource mapperLocation : <span class="keyword">this</span>.mapperLocations) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mapperLocation == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//解析xml文件，生成MapperStatement</span></span><br><span class="line">                    XMLMapperBuilder xmlMapperBuilder = <span class="keyword">new</span> XMLMapperBuilder(mapperLocation.getInputStream(),</span><br><span class="line">                            targetConfiguration, mapperLocation.toString(), targetConfiguration.getSqlFragments());</span><br><span class="line">                    xmlMapperBuilder.parse();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NestedIOException(<span class="string">"Failed to parse mapping resource: '"</span> + mapperLocation + <span class="string">"'"</span>, e);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    ErrorContext.instance().reset();</span><br><span class="line">                &#125;</span><br><span class="line">                LOGGER.debug(() -&gt; <span class="string">"Parsed mapper file: '"</span> + mapperLocation + <span class="string">"'"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BaseMapper"><a href="#BaseMapper" class="headerlink" title="BaseMapper"></a>BaseMapper<T></T></h3><p>BaseMapper，继承了该接口后，无需编写mapper.xml文件，即可以获得CRUD功能，那么MyBatis-Plus又是如何做到无需配置mapper.xml就能获得CRUD功能呢？<br>答案就是通过sql注入器AbstractSqlInjector自己生成sql。</p><h3 id="TableName"><a href="#TableName" class="headerlink" title="@TableName"></a>@TableName</h3><p>在AbstractSqlInject中inspectInject方法会获取BaseMapper<T>中的泛型类型，然后获取Entity上@tableName配置的表名以及@TableField注解字段的信息。</T></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SqlMethod &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    INSERT_ONE(<span class="string">"insert"</span>, <span class="string">"插入一条数据（选择字段插入）"</span>, <span class="string">"&lt;script&gt;\nINSERT INTO %s %s VALUES %s\n&lt;/script&gt;"</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractSqlInjector</span> <span class="keyword">implements</span> <span class="title">ISqlInjector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(AbstractSqlInjector<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inspectInject</span><span class="params">(MapperBuilderAssistant builderAssistant, Class&lt;?&gt; mapperClass)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//  获取BaseMapper中的泛型类型，，通过TableName获取mapper关联的是哪个表</span></span><br><span class="line">        Class&lt;?&gt; modelClass = extractModelClass(mapperClass);</span><br><span class="line">        <span class="keyword">if</span> (modelClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String className = mapperClass.toString();</span><br><span class="line">            Set&lt;String&gt; mapperRegistryCache = GlobalConfigUtils.getMapperRegistryCache(builderAssistant.getConfiguration());</span><br><span class="line">            <span class="keyword">if</span> (!mapperRegistryCache.contains(className)) &#123;</span><br><span class="line">                List&lt;AbstractMethod&gt; methodList = <span class="keyword">this</span>.getMethodList(mapperClass);</span><br><span class="line">                <span class="keyword">if</span> (CollectionUtils.isNotEmpty(methodList)) &#123;</span><br><span class="line">                    TableInfo tableInfo = TableInfoHelper.initTableInfo(builderAssistant, modelClass);</span><br><span class="line">                    <span class="comment">// 循环注入自定义方法</span></span><br><span class="line">                    methodList.forEach(m -&gt; m.inject(builderAssistant, mapperClass, modelClass, tableInfo));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    logger.debug(mapperClass.toString() + <span class="string">", No effective injection method was found."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                mapperRegistryCache.add(className);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TableInfoHelper</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 实体类反射获取表信息【初始化】</span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz 反射实体类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 数据库表反射信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> TableInfo <span class="title">initTableInfo</span><span class="params">(MapperBuilderAssistant builderAssistant, Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">        TableInfo tableInfo = TABLE_INFO_CACHE.get(clazz);</span><br><span class="line">        <span class="keyword">if</span> (tableInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (builderAssistant != <span class="keyword">null</span>) &#123;</span><br><span class="line">                tableInfo.setConfiguration(builderAssistant.getConfiguration());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> tableInfo;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 没有获取到缓存信息,则初始化 */</span></span><br><span class="line">        tableInfo = <span class="keyword">new</span> TableInfo(clazz);</span><br><span class="line">        GlobalConfig globalConfig;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != builderAssistant) &#123;</span><br><span class="line">            tableInfo.setCurrentNamespace(builderAssistant.getCurrentNamespace());</span><br><span class="line">            tableInfo.setConfiguration(builderAssistant.getConfiguration());</span><br><span class="line">            globalConfig = GlobalConfigUtils.getGlobalConfig(builderAssistant.getConfiguration());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 兼容测试场景</span></span><br><span class="line">            globalConfig = GlobalConfigUtils.defaults();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 初始化表名相关 */</span></span><br><span class="line">        initTableName(clazz, globalConfig, tableInfo);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 初始化字段相关 */</span></span><br><span class="line">        initTableFields(clazz, globalConfig, tableInfo);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 放入缓存 */</span></span><br><span class="line">        TABLE_INFO_CACHE.put(clazz, tableInfo);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 缓存 lambda */</span></span><br><span class="line">        LambdaUtils.installCache(tableInfo);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 自动构建 resultMap */</span></span><br><span class="line">        tableInfo.initResultMapIfNeed();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tableInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 初始化 表数据库类型,表名,resultMap</span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz        实体类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> globalConfig 全局配置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableInfo    数据库表反射信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initTableName</span><span class="params">(Class&lt;?&gt; clazz, GlobalConfig globalConfig, TableInfo tableInfo)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* 数据库全局配置 */</span></span><br><span class="line">        GlobalConfig.DbConfig dbConfig = globalConfig.getDbConfig();</span><br><span class="line">        TableName table = clazz.getAnnotation(TableName<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        String tableName = clazz.getSimpleName();</span><br><span class="line">        String tablePrefix = dbConfig.getTablePrefix();</span><br><span class="line">        String schema = dbConfig.getSchema();</span><br><span class="line">        <span class="keyword">boolean</span> tablePrefixEffect = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (table != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isNotEmpty(table.value())) &#123;</span><br><span class="line">                tableName = table.value();</span><br><span class="line">                <span class="keyword">if</span> (StringUtils.isNotEmpty(tablePrefix) &amp;&amp; !table.keepGlobalPrefix()) &#123;</span><br><span class="line">                    tablePrefixEffect = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tableName = initTableNameWithDbConfig(tableName, dbConfig);</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;MapperScan&quot;&gt;&lt;a href=&quot;#MapperScan&quot; class=&quot;headerlink&quot; title=&quot;@MapperScan&quot;&gt;&lt;/a&gt;@MapperScan&lt;/h3&gt;&lt;p&gt;@MapperScan的作用可以理解为@Import注解 + @Mapp
      
    
    </summary>
    
    
      <category term="mybatis" scheme="https://marchnineteen.github.io/categories/mybatis/"/>
    
    
  </entry>
  
  <entry>
    <title>explain工具</title>
    <link href="https://marchnineteen.github.io/2022/03/22/database/3.explain/"/>
    <id>https://marchnineteen.github.io/2022/03/22/database/3.explain/</id>
    <published>2022-03-22T00:00:00.000Z</published>
    <updated>2023-05-08T01:44:57.915Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>使用EXPLAIN关键字可以模拟优化器执行SQL语句，分析你的查询语句或是结构的性能瓶颈在select语句之前增加 xplain 关键字，<br>MySQL 会在查询上设置一个标记，执行查询会返 回执行计划的信息， 而不是执行这条SQL 注意：如果 from 中包含子查询，<br>仍会执行该子查询，将结果放入临时表中</p><h1 id="explain中的列"><a href="#explain中的列" class="headerlink" title="explain中的列"></a>explain中的列</h1><p><strong>1.id列:</strong></p><p>id列的编号是 select 的序列号，有几个 select 就有几个id，并且id的顺序是按 select 出现的 顺序增长的。<br>从大到小，越大的执行优先级越高，相同的从上到下执行，id为null最后执行。</p><p><strong>2.select_type列</strong></p><p>select_type 表示对应行是简单还是复杂的查询。</p><ul><li>simple:简单查询。</li><li>primary:复杂查询中最外层的 select</li><li>subquery:包含在 select 中的子查询（不在 from 子句中）</li><li>derived:包含在 from 子句中的子查询。MySQL会将结果存放在一个临时表中，也称为 派生表（derived的英文含义）</li></ul><p><strong>3.table列</strong></p><p>这一列表示 explain 的一行正在访问哪个表。 当 from 子句中有子查询时，table列是 <derivenN> 格式，表示当前查询依赖 id=N 的查询，<br>于是先执行 id=N 的查询。 当有 union 时，UNION RESULT 的 table 列的值为&lt;union1,2&gt;，1和2表示参与 union 的 select 行id。</derivenN></p><p><strong>4.type列</strong></p><p>这一列表示关联类型或访问类型，即MySQL决定如何查找表中的行，查找数据行记录的大概 范围。</p><p>依次从最优到最差分别为：system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; all</p><p>一般来说，得保证查询达到range级别，最好达到ref。</p><ul><li>NULL：mysql能够在优化阶段分解查询语句，在执行阶段用不着再访问表或索引。例如：在 索引列中选取最小值，可以单独查找索引来完成，不需要在执行时访问表</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select min(id) from film;</span><br></pre></td></tr></table></figure><ul><li>const, system：mysql能对查询的某部分进行优化并将其转化成一个常量（可以看show warnings 的结果）。<br>用于 primary key 或 unique key 的所有列与常数比较时，所以表最多 有一个匹配行，读取1次，速度比较快。system是const的特例，表里只有一条元组匹配时为 system</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain extended select * from (select * from film where id &#x3D; 1) tmp;</span><br></pre></td></tr></table></figure><ul><li>eq_ref:primary key 或 unique key 索引的所有部分被连接使用 ，最多只会返回一条符合条件的记录。<br>这可能是在 const 之外最好的联接类型了，简单的 select 查询不会出现这种 type。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from film_actor left join film on film_actor.film_id &#x3D; film.id;</span><br></pre></td></tr></table></figure><ul><li><p>ref:相比 eq_ref，不使用唯一索引，而是使用普通索引或者唯一性索引的部分前缀，索引要和某个值相比较，可能会找到多个符合条件的行。</p></li><li><p>range:范围扫描通常出现在 in(), between ,&gt; ,&lt;, &gt;= 等操作中。使用一个索引来检索给定 范围的行。</p></li><li><p>index：扫描全表索引，这通常比ALL快一些</p></li><li><p>ALL：即全表扫描，意味着mysql需要从头到尾去查找所需要的行。通常情况下这需要增加索 引来进行优化了</p></li></ul><p><strong>5. possible_keys列</strong></p><p>这一列显示查询可能使用哪些索引来查找。 explain 时可能出现 possible_keys 有列，而 key 显示 NULL 的情况，这种情况是因为表中 数据不多，<br>mysql认为索引对此查询帮助不大，选择了全表查询。 如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查 where 子句看是否可 以创造一个适当的索引来提高查询性能，<br>然后用 explain 查看效果</p><p><strong>6. key列</strong> </p><p>这一列显示mysql实际采用哪个索引来优化对该表的访问。<br>如果没有使用索引，则该列是 NULL。如果想强制mysql使用或忽视possible_keys列中的索 引，在查询中使用 force index、ignore index。</p><p><strong>7. key_len列</strong> </p><p>这一列显示了mysql在索引里使用的字节数，通过这个值可以算出具体使用了索引中的哪些 列。举例来说，film_actor的联合索引 idx_film_actor_id 由 film_id 和 actor_id 两个int列组成，<br>并且每个int是4字节。 通过结果中的key_len=4可推断出查询使用了第一个列：film_id列来执 行索引查找。 mysql&gt; explain sele</p><p>key_len计算规则如下： </p><ul><li>字符串 char(n)：n字节长度 varchar(n)：2字节存储字符串长度，如果是utf-8，则长度 3n + 2</li><li>数值类型tinyint：1字节 smallint：2字节 int：4字节 bigint：8字节 </li><li>时间类型：date：3字节 timestamp：4字节 datetime：8字节</li><li>如果字段允许为 NULL，需要1字节记录是否为 NULL </li></ul><p>索引最大长度是768字节，当字符串过长时，mysql会做一个类似左前缀索引的处理，将前半 部分的字符提取出来做索引。</p><p><strong>8. ref列</strong> </p><p>这一列显示了在key列记录的索引中，表查找值所用到的列或常量，常见的有：const（常 量），字段名（例：film.id）</p><p><strong>9. rows列</strong> </p><p>这一列是mysql估计要读取并检测的行数，注意这个不是结果集里的行数</p><p><strong>10. Extra列</strong> </p><p>这一列展示的是额外信息。常见的重要值如下：</p><ul><li>Using index：使用覆盖索引</li><li>Using where：使用 where 语句来处理结果，查询的列未被索引覆盖</li><li>Using index condition：查询的列不完全被索引覆盖，where条件中是一个前导列的范围</li><li>Using temporary：mysql需要创建一张临时表来处理查询。出现这种情况一般是要进行 优化的，首先是想到用索引来优化。</li><li>Using filesort：将用外部排序而不是索引排序，数据较小时从内存排序，否则需要在磁盘 完成排序。这种情况下一般也是要考虑使用索引来优化的。</li><li>Select tables optimized away：使用某些聚合函数（比如 max、min）来访问存在索引 的某个字段是</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;使用EXPLAIN关键字可以模拟优化器执行SQL语句，分析你的查询语句或是结构的性能瓶颈在select语句之前增加 xplain 关键字，&lt;
      
    
    </summary>
    
    
      <category term="database" scheme="https://marchnineteen.github.io/categories/database/"/>
    
    
  </entry>
  
  <entry>
    <title>定时任务&amp;定时线程池</title>
    <link href="https://marchnineteen.github.io/2021/11/09/java/coucurrent/7.%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1&amp;%E5%AE%9A%E6%97%B6%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>https://marchnineteen.github.io/2021/11/09/java/coucurrent/7.%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1&amp;%E5%AE%9A%E6%97%B6%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2021-11-09T00:00:00.000Z</published>
    <updated>2023-05-08T01:44:57.915Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="并发编程" scheme="https://marchnineteen.github.io/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>Executor线程池原理</title>
    <link href="https://marchnineteen.github.io/2021/11/08/java/coucurrent/6.Executor%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86/"/>
    <id>https://marchnineteen.github.io/2021/11/08/java/coucurrent/6.Executor%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86/</id>
    <published>2021-11-08T00:00:00.000Z</published>
    <updated>2023-05-08T01:44:57.915Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程使用过程中存在的问题"><a href="#线程使用过程中存在的问题" class="headerlink" title="线程使用过程中存在的问题"></a>线程使用过程中存在的问题</h1><p>如果并发的请求数量非常多，但每个线程执行的时间很短，这样就会频繁的创建和销毁<br>线程，如此一来会大大降低系统的效率。可能出现服务器在为每个请求创建新线程和销毁线<br>程上花费的时间和消耗的系统资源要比处理实际的用户请求的时间和资源更多。</p><h1 id="线程池的使用场景-amp-优势"><a href="#线程池的使用场景-amp-优势" class="headerlink" title="线程池的使用场景&amp;优势"></a>线程池的使用场景&amp;优势</h1><p>什么时候使用线程池?</p><ul><li>单个任务处理时间比较短</li><li>需要处理的任务数量很大</li></ul><p>线程池优势</p><ul><li>重用存在的线程，减少线程创建，消亡的开销，提高性能 提高响应速度。 </li><li>当任务到达时，任务可以不需要的等到线程创建就能立即执行。 </li><li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，<br>使用线程池可以进行统一的分配，调优和监控。</li></ul><h1 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a>线程的实现方式</h1><p>Runnable,Thread,Callable</p><h3 id="Runnable"><a href="#Runnable" class="headerlink" title="Runnable"></a>Runnable</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现Runnable接口的类将被Thread执行，表示一个基本的任务 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// run方法就是它所有的内容，就是实际执行的任务 </span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span>; </span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestThread thread = <span class="keyword">new</span> TestThread();</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h3><p>有返回结果，用Future接收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Callable同样是任务，与Runnable接口的区别在于它接收泛型，同时它执行任务后带 有返回内容</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123; </span><br><span class="line">    <span class="comment">// 相对于run方法的带有返回值的call方法</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception; </span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h1><p>Executor接口是线程池框架中最基础的部分，定义了一个用于执行Runnable的execute方法。</p><p>下图为它的继承与实现.</p><p><img src="/uploads/java/concurrent/%E7%BA%BF%E7%A8%8B%E6%B1%A0.png" alt="线程池.png"></p><p>从图中可以看出Executor下有一个重要子接口ExecutorService，其中定义了线程池的具体行为<br>1，execute（Runnable command）：履行Ruannable类型的任务,</p><p>2，submit（task）：可用来提交Callable或Runnable任务，并返回代表此任务的Future 对象</p><p>3，shutdown（）：在完成已提交的任务后封闭办事，不再接管新任务,</p><p>4，shutdownNow（）：停止所有正在履行的任务并封闭办事。</p><p>5，isTerminated（）：测试是否所有任务都履行完毕了。</p><p>6，isShutdown（）：测试是否该ExecutorService已被关闭</p><h1 id="线程池重点属性"><a href="#线程池重点属性" class="headerlink" title="线程池重点属性"></a>线程池重点属性</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING,<span class="number">0</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span> = <span class="number">29</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY = (<span class="number">1</span> &lt;&lt; COUNT_BITS)  - <span class="number">1</span> = workerCount;</span><br></pre></td></tr></table></figure><p>ctl 是对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段， 它包含两<br>部分的信息: 线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)，这<br>里可以看到，使用了Integer类型来保存，高3位保存runState，低29位保存<br>workerCount。COUNT_BITS 就是29，CAPACITY就是1左移29位减1（29个1），这个常<br>量表示workerCount的上限值，大约是5亿。</p><h3 id="ctl相关方法"><a href="#ctl相关方法" class="headerlink" title="ctl相关方法"></a>ctl相关方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure><ul><li>runStateOf：获取运行状态；</li><li>workerCountOf：获取活动线程数；</li><li>ctlOf：获取运行状态和活动线程数的值。</li></ul><p>线程池存在5种状态</p><ul><li>RUNNING = 1 &lt;&lt; COUNT_BITS; //高3位为111</li><li>SHUTDOWN = 0 &lt;&lt; COUNT_BITS; //高3位为000</li><li>STOP = 1 &lt;&lt; COUNT_BITS; //高3位为001</li><li>TIDYING = 2 &lt;&lt; COUNT_BITS; //高3位为010</li><li>TERMINATED = 3 &lt;&lt; COUNT_BITS; //高3位为011</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      System.out.println(toBin(-<span class="number">1</span> &lt;&lt; Integer.SIZE - <span class="number">3</span>));</span><br><span class="line">      System.out.println(toBin(<span class="number">0</span> &lt;&lt; Integer.SIZE - <span class="number">3</span>));</span><br><span class="line">      System.out.println(toBin(<span class="number">1</span> &lt;&lt; Integer.SIZE - <span class="number">3</span>));</span><br><span class="line">      System.out.println(toBin(<span class="number">2</span> &lt;&lt; Integer.SIZE - <span class="number">3</span>));</span><br><span class="line">      System.out.println(toBin(<span class="number">3</span> &lt;&lt; Integer.SIZE - <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">      <span class="number">11100000000000000000000000000000</span></span><br><span class="line">      <span class="number">00000000000000000000000000000000</span></span><br><span class="line">      <span class="number">00100000000000000000000000000000</span></span><br><span class="line">      <span class="number">01000000000000000000000000000000</span></span><br><span class="line">      <span class="number">01100000000000000000000000000000</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toBin</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] chs = <span class="keyword">new</span> <span class="keyword">char</span>[Integer.SIZE];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Integer.SIZE; i++) &#123;</span><br><span class="line">        chs[Integer.SIZE - <span class="number">1</span> - i] = (<span class="keyword">char</span>) ((num &gt;&gt; i &amp; <span class="number">1</span>) + <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(chs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、RUNNING</p><p>(1) 状态说明：线程池处在RUNNING状态时，能够接收新任务，以及对已添加的任务进行<br>处理。</p><p>(2) 状态切换：线程池的初始化状态是RUNNING。换句话说，线程池被一旦被创建，就处<br>于RUNNING状态，并且线程池中的任务数为0！</p><p>2、 SHUTDOWN</p><p>(1) 状态说明：线程池处在SHUTDOWN状态时，不接收新任务，但能处理已添加的任务。</p><p>(2) 状态切换：调用线程池的shutdown()接口时，线程池由RUNNING -&gt; SHUTDOWN。</p><p>3、STOP</p><p>(1) 状态说明：线程池处在STOP状态时，不接收新任务，不处理已添加的任务，并且会中断正在处理的任务。</p><p>(2) 状态切换：调用线程池的shutdownNow()接口时，线程池由(RUNNING or SHUTDOWN ) -&gt; STOP。</p><p>4、TIDYING</p><p>(1) 状态说明：当所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为TIDYING<br>状态。当线程池变为TIDYING状态时，会执行钩子函数terminated()。terminated()在<br>ThreadPoolExecutor类中是空的，若用户想在线程池变为TIDYING时，进行相应的处理；<br>可以通过重载terminated()函数来实现。</p><p>(2) 状态切换：当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也<br>为空时，就会由 SHUTDOWN -&gt; TIDYING。 当线程池在STOP状态下，线程池中执行的<br>任务为空时，就会由STOP -&gt; TIDYING。</p><p>5、 TERMINATED</p><p>(1) 状态说明：线程池彻底终止，就变成TERMINATED状态。</p><p>(2) 状态切换：线程池处在TIDYING状态时，执行完terminated()之后，就会由 TIDYING -&gt; TERMINATED。</p><p>进入TERMINATED的条件如下：</p><ul><li>线程池不是RUNNING状态；</li><li>线程池状态不是TIDYING状态或TERMINATED状态；</li><li>如果线程池状态是SHUTDOWN并且workerQueue为空；</li><li>workerCount为0；</li><li>设置TIDYING状态成功</li></ul><p><img src="/uploads/java/concurrent/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81%E5%88%87%E6%8D%A2.jpg" alt="线程池状态切换.jpg"></p><h1 id="线程池的具体实现"><a href="#线程池的具体实现" class="headerlink" title="线程池的具体实现"></a>线程池的具体实现</h1><p>ThreadPoolExecutor 默认线程池</p><p>ScheduledThreadPoolExecutor 定时线程池</p><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><h3 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">        TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">        BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">        ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">        RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure><h3 id="任务提交"><a href="#任务提交" class="headerlink" title="任务提交"></a>任务提交</h3><p>1、public void execute() //提交任务无返回值</p><p>2、public Future&lt;?&gt; submit() //任务执行完成后有返回值参数</p><h3 id="参数解释"><a href="#参数解释" class="headerlink" title="参数解释"></a>参数解释</h3><h4 id="corePoolSize"><a href="#corePoolSize" class="headerlink" title="corePoolSize"></a>corePoolSize</h4><p>线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当<br>前线程数等于corePoolSize；如果当前线程数为corePoolSize，继续提交的任务被保存到<br>阻塞队列中，等待被执行；如果执行了线程池的prestartAllCoreThreads()方法，线程池会<br>提前创建并启动所有核心线程。</p><h4 id="maximumPoolSize"><a href="#maximumPoolSize" class="headerlink" title="maximumPoolSize"></a>maximumPoolSize</h4><p>线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线<br>程执行任务，前提是当前线程数小于maximumPoolSize；</p><h4 id="keepAliveTime"><a href="#keepAliveTime" class="headerlink" title="keepAliveTime"></a>keepAliveTime</h4><p>线程池维护线程所允许的空闲时间。当线程池中的线程数量大于corePoolSize的时<br>候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待<br>的时间超过了keepAliveTime；</p><h4 id="unit"><a href="#unit" class="headerlink" title="unit"></a>unit</h4><p>keepAliveTime的单位；</p><h4 id="workQueue"><a href="#workQueue" class="headerlink" title="workQueue"></a>workQueue</h4><p>用来保存等待被执行的任务的阻塞队列，且任务必须实现Runable接口，在JDK中提供了如下阻塞队列：</p><ul><li>1、ArrayBlockingQueue：基于数组结构的有界阻塞队列，按FIFO排序任务；</li><li>2、LinkedBlockingQuene：基于链表结构的阻塞队列，按FIFO排序任务，吞<br>吐量通常要高于ArrayBlockingQuene；</li><li>3、SynchronousQuene：一个不存储元素的阻塞队列，每个插入操作必须等到<br>另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于<br>LinkedBlockingQuene；</li><li>4、priorityBlockingQuene：具有优先级的无界阻塞队列；</li></ul><h4 id="threadFactory"><a href="#threadFactory" class="headerlink" title="threadFactory"></a>threadFactory</h4><p>它是ThreadFactory类型的变量，用来创建新线程。默认使用<br>Executors.defaultThreadFactory() 来创建线程。使用默认的ThreadFactory来创建线程<br>时，会使新创建的线程具有相同的NORM_PRIORITY优先级并且是非守护线程，同时也设<br>置了线程的名称。</p><h4 id="handler"><a href="#handler" class="headerlink" title="handler"></a>handler</h4><p>线程池的饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了4种策略：</p><ul><li>1、AbortPolicy：直接抛出异常，默认策略；</li><li>2、CallerRunsPolicy：用调用者所在的线程来执行任务；</li><li>3、DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；</li><li>4、DiscardPolicy：直接丢弃任务；</li></ul><h3 id="线程池监控"><a href="#线程池监控" class="headerlink" title="线程池监控"></a>线程池监控</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getTaskCount</span><span class="params">()</span> <span class="comment">//线程池已执行与未执行的任务总数</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getCompletedTaskCount</span><span class="params">()</span> <span class="comment">//已完成的任务数</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPoolSize</span><span class="params">()</span> <span class="comment">//线程池当前的线程数</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getActiveCount</span><span class="params">()</span> <span class="comment">//线程池中正在执行任务的线程数量</span></span></span><br></pre></td></tr></table></figure><h3 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h3><p><img src="/uploads/java/concurrent/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86.jpg" alt="线程池运行原理.jpg"></p><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;线程使用过程中存在的问题&quot;&gt;&lt;a href=&quot;#线程使用过程中存在的问题&quot; class=&quot;headerlink&quot; title=&quot;线程使用过程中存在的问题&quot;&gt;&lt;/a&gt;线程使用过程中存在的问题&lt;/h1&gt;&lt;p&gt;如果并发的请求数量非常多，但每个线程执行的时间很短，这样就会
      
    
    </summary>
    
    
      <category term="并发编程" scheme="https://marchnineteen.github.io/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>Collections&amp;Queue体系</title>
    <link href="https://marchnineteen.github.io/2021/11/07/java/coucurrent/5.Collections&amp;Queue%E4%BD%93%E7%B3%BB/"/>
    <id>https://marchnineteen.github.io/2021/11/07/java/coucurrent/5.Collections&amp;Queue%E4%BD%93%E7%B3%BB/</id>
    <published>2021-11-07T00:00:00.000Z</published>
    <updated>2023-05-08T01:44:57.915Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BlockingQueue阻塞队列"><a href="#BlockingQueue阻塞队列" class="headerlink" title="BlockingQueue阻塞队列"></a>BlockingQueue阻塞队列</h1><p>队列实质就是一种存储数据的结构</p><p>通常用链表或者数组实现</p><p>一般而言队列具备FIFO先进先出的特性，当然也有双端队列（Deque）优先级队列</p><p>主要操作：入队（EnQueue）与出队（Dequeue）</p><p><img src="/uploads/java/concurrent/BlockingQueue.png" alt="BlockingQueue.png"></p><p>1、ArrayBlockingQueue 由数组支持的有界队列<br>2、LinkedBlockingQueue 由链接节点支持的可选有界队列<br>3、PriorityBlockingQueue 由优先级堆支持的无界优先级队列<br>4、DelayQueue 由优先级堆支持的、基于时间的调度队列</p><h1 id="Java7HashMap死锁与Java8HashMap优化"><a href="#Java7HashMap死锁与Java8HashMap优化" class="headerlink" title="Java7HashMap死锁与Java8HashMap优化"></a>Java7HashMap死锁与Java8HashMap优化</h1><h1 id="ConcurrentHashMap线程安全与分段锁"><a href="#ConcurrentHashMap线程安全与分段锁" class="headerlink" title="ConcurrentHashMap线程安全与分段锁"></a>ConcurrentHashMap线程安全与分段锁</h1><h1 id="并发List-ArrayList与CopyOnWriteArrayList"><a href="#并发List-ArrayList与CopyOnWriteArrayList" class="headerlink" title="并发List-ArrayList与CopyOnWriteArrayList"></a>并发List-ArrayList与CopyOnWriteArrayList</h1><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p><img src="/uploads/java/concurrent/AQS%E5%90%8C%E6%AD%A5%E5%99%A8%E6%9D%A1%E4%BB%B6%E9%98%9F%E5%88%97%E5%BA%94%E7%94%A8%E9%80%BB%E8%BE%91.jpg" alt="AQS同步器条件队列应用逻辑.jpg"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;BlockingQueue阻塞队列&quot;&gt;&lt;a href=&quot;#BlockingQueue阻塞队列&quot; class=&quot;headerlink&quot; title=&quot;BlockingQueue阻塞队列&quot;&gt;&lt;/a&gt;BlockingQueue阻塞队列&lt;/h1&gt;&lt;p&gt;队列实质就是一种存储
      
    
    </summary>
    
    
      <category term="并发编程" scheme="https://marchnineteen.github.io/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>Atomic&amp;Unsafe魔法类详解</title>
    <link href="https://marchnineteen.github.io/2021/11/05/java/coucurrent/4.Atomic&amp;Unsafe%E9%AD%94%E6%B3%95%E7%B1%BB%E8%AF%A6%E8%A7%A3/"/>
    <id>https://marchnineteen.github.io/2021/11/05/java/coucurrent/4.Atomic&amp;Unsafe%E9%AD%94%E6%B3%95%E7%B1%BB%E8%AF%A6%E8%A7%A3/</id>
    <published>2021-11-05T00:00:00.000Z</published>
    <updated>2023-05-08T01:44:57.915Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h1><p>处理器自动保证基本内存操作的原子性，如对同一个缓存行里进行16/32/64位的操作是原子的。<br>复杂的内存操作处理器不能自动保证其原子性，比如跨总线宽度，跨多个缓存行，跨页表的访问。</p><p>缓存加锁</p><p>总线加锁</p><h1 id="Atomic"><a href="#Atomic" class="headerlink" title="Atomic"></a>Atomic</h1><p>在Atomic包里一共有12个类，四种原子更新方式,原子更新基本类型,原子更新数组,原子更新引用,原子更新字段, Atomic包里的类基本都是使用Unsafe实现的包装类。</p><p>基本类：AtomicInteger、AtomicLong、AtomicBoolean；</p><p>引用类型：AtomicReference、AtomicReference的ABA实例、AtomicStampedRerence、AtomicMarkableReference；</p><p>数组类型：AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray</p><p>属性原子修改器（Updater）：AtomicIntegerFieldUpdater、AtomicLongFieldUpdater、AtomicReferenceFieldUpdater</p><h1 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h1><p>Unsafe是位于sun.misc包下的一个类，主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升Java运行效率、<br>增强Java语言底层资源操作能力方面起到了很大的作用。</p><p>Unsafe类为一单例实现，提供静态方法getUnsafe获取Unsafe实例，当且仅当调用getUnsafe方法的类为引导类加载器所加载时才合法，<br>否则抛出SecurityException异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Unsafe</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe theUnsafe;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Unsafe</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="meta">@CallerSensitive</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title">getUnsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Class var0 = Reflection.getCallerClass();       </span><br><span class="line">        <span class="comment">// 仅在引导类加载器`BootstrapClassLoader`加载时才合法       </span></span><br><span class="line">        <span class="keyword">if</span>(!VM.isSystemDomainLoader(var0.getClassLoader())) &#123;           </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"Unsafe"</span>);       </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;           </span><br><span class="line">            <span class="keyword">return</span> theUnsafe;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何获取Unsafe"><a href="#如何获取Unsafe" class="headerlink" title="如何获取Unsafe"></a>如何获取Unsafe</h2><p>1、把调用Unsafe相关方法的类Demo所在jar包路径追加到默认的bootstrap路径中，使得A被引导类加载器加载</p><ul><li>java -Xbootclasspath/Demo:${path} // 其中path为调用Unsafe相关方法的类所在jar包路径 </li></ul><p>2、通过反射获取单例对象theUnsafe</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeInstance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title">reflectGetUnsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field field = Unsafe.class.getDeclaredField("theUnsafe");</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> (Unsafe) field.get(<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Unsafe功能"><a href="#Unsafe功能" class="headerlink" title="Unsafe功能"></a>Unsafe功能</h2><p><img src="/uploads/java/concurrent/Unsafe%E5%8A%9F%E8%83%BD.png" alt="Unsafe功能.png"></p><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CAS</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o         包含要修改field的对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> offset    对象中某field的偏移量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> expected  期望值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> update    更新值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>          true | false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapObject</span><span class="params">(Object var1, <span class="keyword">long</span> var2, Object var4, Object var5)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapLong</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">long</span> var4, <span class="keyword">long</span> var6)</span></span>;</span><br></pre></td></tr></table></figure><p><img src="/uploads/java/concurrent/CAS.png" alt="CAS.png"></p><h2 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取消阻塞线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Object thread)</span></span>;</span><br><span class="line"><span class="comment">//阻塞线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(<span class="keyword">boolean</span> isAbsolute, <span class="keyword">long</span> time)</span></span>;</span><br><span class="line"><span class="comment">//获得对象锁（可重入锁）</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">monitorEnter</span><span class="params">(Object o)</span></span>;</span><br><span class="line"><span class="comment">//释放对象锁</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">monitorExit</span><span class="params">(Object o)</span></span>;</span><br><span class="line"><span class="comment">//尝试获取对象锁</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">tryMonitorEnter</span><span class="params">(Object o)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内存屏障，禁止load操作重排序。屏障前的load操作不能被重排序到屏障后，屏障后的load操作不能被重排序到屏障前</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">loadFence</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//内存屏障，禁止store操作重排序。屏障前的store操作不能被重排序到屏障后，屏障后的store操作不能被重排序到屏障前</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">storeFence</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//内存屏障，禁止load、store操作重排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">fullFence</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">典型应用</span><br><span class="line">StampedLock的validate()方法使用内存屏障，防止指令重排</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validate</span><span class="params">(<span class="keyword">long</span> stamp)</span> </span>&#123;</span><br><span class="line">    U.loadFence();<span class="comment">// 内存屏障</span></span><br><span class="line">    reture (stamp &amp; SBITS) == (state &amp; SBITS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/uploads/java/concurrent/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C.png" alt="内存屏障.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原子操作&quot;&gt;&lt;a href=&quot;#原子操作&quot; class=&quot;headerlink&quot; title=&quot;原子操作&quot;&gt;&lt;/a&gt;原子操作&lt;/h1&gt;&lt;p&gt;处理器自动保证基本内存操作的原子性，如对同一个缓存行里进行16/32/64位的操作是原子的。&lt;br&gt;复杂的内存操作处理器不能
      
    
    </summary>
    
    
      <category term="并发编程" scheme="https://marchnineteen.github.io/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>CountDownLatch&amp;Semaphore-共享锁</title>
    <link href="https://marchnineteen.github.io/2021/10/31/java/coucurrent/3.CountDownLatch&amp;Semaphore/"/>
    <id>https://marchnineteen.github.io/2021/10/31/java/coucurrent/3.CountDownLatch&amp;Semaphore/</id>
    <published>2021-10-31T00:00:00.000Z</published>
    <updated>2023-05-08T01:44:57.915Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Semaphore-是什么？"><a href="#1-Semaphore-是什么？" class="headerlink" title="1. Semaphore 是什么？"></a>1. Semaphore 是什么？</h1><p>Semaphore 字面意思是信号量的意思，它的作用是控制访问特定资源的线程数目。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Semaphore-是什么？&quot;&gt;&lt;a href=&quot;#1-Semaphore-是什么？&quot; class=&quot;headerlink&quot; title=&quot;1. Semaphore 是什么？&quot;&gt;&lt;/a&gt;1. Semaphore 是什么？&lt;/h1&gt;&lt;p&gt;Semaphore 字面
      
    
    </summary>
    
    
      <category term="并发编程" scheme="https://marchnineteen.github.io/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>JVM调优</title>
    <link href="https://marchnineteen.github.io/2021/10/31/java/jvm/jvm%E8%B0%83%E4%BC%98/"/>
    <id>https://marchnineteen.github.io/2021/10/31/java/jvm/jvm%E8%B0%83%E4%BC%98/</id>
    <published>2021-10-31T00:00:00.000Z</published>
    <updated>2023-05-08T01:44:57.935Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.cnblogs.com/likehua/p/3369823.html" target="_blank" rel="noopener">https://www.cnblogs.com/likehua/p/3369823.html</a></p></blockquote><blockquote><p>实战<a href="https://juejin.cn/post/7025410482341150751?utm_source=gold_browser_extension#heading-8" target="_blank" rel="noopener">https://juejin.cn/post/7025410482341150751?utm_source=gold_browser_extension#heading-8</a> </p></blockquote><h1 id="1-堆大小设置"><a href="#1-堆大小设置" class="headerlink" title="1.堆大小设置"></a>1.堆大小设置</h1><p>典型设置</p><p>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k</p><ul><li><p>-Xmx3550m:设置JVM最大可用内存为3550M</p></li><li><p>-Xms3550m:设置JVM初始内存为3550m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存</p></li><li><p>-Xmn2g:设置年轻代大小为2G。整个JVM内存大小=年轻代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。<br>此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8</p></li><li><p>-Xss128k：设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。更具应用的线程所需内存大小进行调整。<br>在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。</p></li></ul><p>java -Xmx3550m -Xms3550m -Xss128k -XX:NewRatio=4 -XX:SurvivorRatio=4 -XX:MaxPermSize=16m -XX:MaxTenuringThreshold=0</p><ul><li><p>-XX:NewRatio=4:设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1/5</p></li><li><p>-XX:SurvivorRatio=4：设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6</p></li><li><p>-XX:MaxPermSize=16m:设置持久代大小为16m。</p></li><li><p>-XX:MaxTenuringThreshold=0：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。<br>对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，<br>增加在年轻代即被回收的概论。</p></li></ul><h1 id="2-回收器选择"><a href="#2-回收器选择" class="headerlink" title="2.回收器选择"></a>2.回收器选择</h1><p>JVM给了三种选择：<strong>串行收集器、并行收集器、并发收集器</strong>，但是串行收集器只适用于小数据量的情况，所以这里的选择主要针对并行收集器和并发收集器。<br>默认情况下，JDK5.0以前都是使用串行收集器，如果想使用其他收集器需要在启动时加入相应参数。JDK5.0以后，JVM会根据当前系统配置进行判断。</p><h2 id="2-1-吞吐量优先的并行收集器"><a href="#2-1-吞吐量优先的并行收集器" class="headerlink" title="2.1 吞吐量优先的并行收集器"></a>2.1 吞吐量优先的并行收集器</h2><p>如上文所述，并行收集器主要以到达一定的吞吐量为目标，适用于科学技术和后台处理等。</p><p>典型配置：<br>java -Xmx3800m -Xms3800m -Xmn2g -Xss128k <strong>-XX:+UseParallelGC -XX:ParallelGCThreads=20</strong></p><p>-XX:+UseParallelGC：选择垃圾收集器为并行收集器。此配置仅对年轻代有效。即上述配置下，年轻代使用并发收集，而年老代仍旧使用串行收集。<br>-XX:ParallelGCThreads=20：配置并行收集器的线程数，即：同时多少个线程一起进行垃圾回收。此值最好配置与处理器数目相等。</p><p>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=20 <strong>-XX:+UseParallelOldGC</strong><br>-XX:+UseParallelOldGC：配置年老代垃圾收集方式为并行收集。JDK6.0支持对年老代并行收集。</p><p>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k <strong>-XX:+UseParallelGC  -XX:MaxGCPauseMillis=100</strong><br>-XX:MaxGCPauseMillis=100:设置每次年轻代垃圾回收的最长时间，如果无法满足此时间，JVM会自动调整年轻代大小，以满足此值。</p><p>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC  -XX:MaxGCPauseMillis=100 <strong>-XX:+UseAdaptiveSizePolicy</strong><br>-XX:+UseAdaptiveSizePolicy：设置此选项后，并行收集器会自动选择年轻代区大小和相应的Survivor区比例，以达到目标系统规定的最低相应时间或者收集频率等，此值建议使用并行收集器时，一直打开。</p><h2 id="2-2-响应时间优先的并发收集器"><a href="#2-2-响应时间优先的并发收集器" class="headerlink" title="2.2 响应时间优先的并发收集器"></a>2.2 响应时间优先的并发收集器</h2><p>如上文所述，并发收集器主要是保证系统的响应时间，减少垃圾收集时的停顿时间。适用于应用服务器、电信领域等。</p><p>典型配置：<br>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:ParallelGCThreads=20 <strong>-XX:+UseConcMarkSweepGC -XX:+UseParNewGC</strong><br>-XX:+UseConcMarkSweepGC：设置年老代为并发收集。测试中配置这个以后，-XX:NewRatio=4的配置失效了，原因不明。所以，此时年轻代大小最好用-Xmn设置。<br>-XX:+UseParNewGC:设置年轻代为并行收集。可与CMS收集同时使用。JDK5.0以上，JVM会根据系统配置自行设置，所以无需再设置此值。</p><p>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseConcMarkSweepGC <strong>-XX:CMSFullGCsBeforeCompaction=5 -XX:+UseCMSCompactAtFullCollection</strong><br>-XX:CMSFullGCsBeforeCompaction：由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行多少次GC以后对内存空间进行压缩、整理。<br>-XX:+UseCMSCompactAtFullCollection：打开对年老代的压缩。可能会影响性能，但是可以消除碎片</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/likehua/p/3369823.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/likehua/p/33
      
    
    </summary>
    
    
      <category term="JVM" scheme="https://marchnineteen.github.io/categories/JVM/"/>
    
    
  </entry>
  
  <entry>
    <title>支付系统可能遇到的问题</title>
    <link href="https://marchnineteen.github.io/2021/10/11/active/pay/"/>
    <id>https://marchnineteen.github.io/2021/10/11/active/pay/</id>
    <published>2021-10-11T00:00:00.000Z</published>
    <updated>2023-05-08T01:44:57.915Z</updated>
    
    <content type="html"><![CDATA[<p>(资源)</p><p>资源不可用</p><p>资源响应超时</p><p>(外部服务)</p><p>通信中断</p><p>服务不可用</p><p>外部服务器响应超时</p><p>外部服务违背功能契约</p><p>应对方式(参考)：原则：避免发生，降低概率，控制影响，快速恢复。</p><table><thead><tr><th>故障条件</th><th>应对方式</th></tr></thead><tbody><tr><td>超量请求</td><td>配额控制，如订单号提前生成，控制额度</td></tr><tr><td>重复请求</td><td>幂等控制</td></tr><tr><td>并发请求</td><td>并发控制netty、mina等</td></tr><tr><td>请求积压</td><td>请求丢弃</td></tr><tr><td>服务/资源响应超时</td><td>时间控制</td></tr><tr><td>可恢复通信故障</td><td>合理重试</td></tr><tr><td>处理中断</td><td>事务/补偿机制</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;(资源)&lt;/p&gt;
&lt;p&gt;资源不可用&lt;/p&gt;
&lt;p&gt;资源响应超时&lt;/p&gt;
&lt;p&gt;(外部服务)&lt;/p&gt;
&lt;p&gt;通信中断&lt;/p&gt;
&lt;p&gt;服务不可用&lt;/p&gt;
&lt;p&gt;外部服务器响应超时&lt;/p&gt;
&lt;p&gt;外部服务违背功能契约&lt;/p&gt;
&lt;p&gt;应对方式(参考)：原则：避免发生，降低概率，控制
      
    
    </summary>
    
    
      <category term="active" scheme="https://marchnineteen.github.io/categories/active/"/>
    
    
  </entry>
  
  <entry>
    <title>app嵌入H5如何同步登录状态</title>
    <link href="https://marchnineteen.github.io/2021/10/11/active/appH5Token/"/>
    <id>https://marchnineteen.github.io/2021/10/11/active/appH5Token/</id>
    <published>2021-10-11T00:00:00.000Z</published>
    <updated>2023-05-08T01:44:57.915Z</updated>
    
    <content type="html"><![CDATA[<p>目前使用的方案：<br>1.h5通过js和app交互调用app的token<br>2.拿到token后使用ajax做异步登录并刷新页面<br>目前的缺点：<br>1.会多次刷新页面<br>2.通过js调用时H5需要做部分改动</p><p>优化的方向：<br>A.APP登陆状态的变化是请求页面，登录后使用webview调用对应域名下的接口实现H5的登录B.每次请求H5url增加get登陆的信息，例如访问 index.php变成index.php？a=xxx通过附加信息同步登录状态<br>优化的方案不知道那个更好一点</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;目前使用的方案：&lt;br&gt;1.h5通过js和app交互调用app的token&lt;br&gt;2.拿到token后使用ajax做异步登录并刷新页面&lt;br&gt;目前的缺点：&lt;br&gt;1.会多次刷新页面&lt;br&gt;2.通过js调用时H5需要做部分改动&lt;/p&gt;
&lt;p&gt;优化的方向：&lt;br&gt;A.APP登陆
      
    
    </summary>
    
    
      <category term="active" scheme="https://marchnineteen.github.io/categories/active/"/>
    
    
  </entry>
  
  <entry>
    <title>dubbo调用模块</title>
    <link href="https://marchnineteen.github.io/2021/09/12/%E5%88%86%E5%B8%83%E5%BC%8F%E6%A1%86%E6%9E%B6%E4%B8%93%E9%A2%98/dubbo/%E8%B0%83%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    <id>https://marchnineteen.github.io/2021/09/12/%E5%88%86%E5%B8%83%E5%BC%8F%E6%A1%86%E6%9E%B6%E4%B8%93%E9%A2%98/dubbo/%E8%B0%83%E7%94%A8%E6%A8%A1%E5%9D%97/</id>
    <published>2021-09-12T00:00:00.000Z</published>
    <updated>2023-05-08T01:44:57.959Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Dubbo-调用模块基本组成"><a href="#一、Dubbo-调用模块基本组成" class="headerlink" title="一、Dubbo 调用模块基本组成"></a>一、Dubbo 调用模块基本组成</h2><ol><li>透明代理：通过动态代理技术，屏蔽远程调用细节以提高编程友好性。</li><li>负载均衡：当有多个提供者是，如何选择哪个进行调用的负载算法。</li><li>容错机制：当服务调用失败时采取的策略</li><li>调用方式：支持同步调用、异步调用</li></ol><p><img src="/uploads/dubbo/%E8%B0%83%E7%94%A8%E6%A8%A1%E5%9D%97.png" alt="调用模块.png"></p><h3 id="透明代理"><a href="#透明代理" class="headerlink" title="透明代理"></a>透明代理</h3><p>参见源码：<br>com.alibaba.dubbo.config.ReferenceConfig#createProxy<br>com.alibaba.dubbo.common.bytecode.ClassGenerator<br>com.alibaba.dubbo.rpc.proxy.javassist.JavassistProxyFactory</p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>Dubbo 目前官方支持以下负载均衡策略：</p><ol><li>随机(random)：按权重设置随机概率。此为默认算法.</li><li>轮循(roundrobin):按公约后的权重设置轮循比率。</li><li>最少活跃调用数(leastactive):相同活跃数的随机，活跃数指调用前后计数差。</li><li>一致性Hash(consistenthash ):相同的参数总是发到同一台机器</li></ol><p>设置方式支持如下四种方式设置，优先级由低至高:</p><!-- 服务端级别--><p>&lt;dubbo:service interface=”…” loadbalance=”roundrobin” /&gt;</p><!-- 客户端级别--><p>&lt;dubbo:reference interface=”…” loadbalance=”roundrobin” /&gt;</p><!-- 服务端方法级别--><p>&lt;dubbo:service interface=”…”&gt;<br>    &lt;dubbo:method name=”…” loadbalance=”roundrobin”/&gt;<br></p><!-- 客户端方法级别--><p>&lt;dubbo:reference interface=”…”&gt;<br>    &lt;dubbo:method name=”…” loadbalance=”roundrobin”/&gt;<br></p><p>一至性hash 算法详解：<br><img src="/uploads/dubbo/%E4%B8%80%E8%87%B3%E6%80%A7hash.png" alt="一至性hash.png"></p><h3 id="容错"><a href="#容错" class="headerlink" title="容错"></a>容错</h3><p>Dubbo 官方目前支持以下容错策略：</p><ol><li>失败自动切换：调用失败后基于retries=“2”属性重试其它服务器</li><li>快速失败：快速失败，只发起一次调用，失败立即报错。</li><li>勿略失败：失败后勿略，不抛出异常给客户端。</li><li>失败重试：失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作</li><li>并行调用:只要一个成功即返回，并行调用指定数量机器，可通过 forks=”2”来设置最大并行数。</li><li>广播调用：广播调用所有提供者，逐个调用，任意一台报错则报错 设置方式支持如下两种方式设置，优先级由低至高<br>&lt;!–<br>Failover 失败自动切换 retries=”1” 切换次数<br>Failfast 快速失败<br>Failsafe 勿略失败<br>Failback 失败重试，5秒后仅重试一次<br>Forking 并行调用 forks=”2” 最大并行数<br>Broadcast 广播调用</li></ol><p>–&gt;<br>&lt;dubbo:service interface=”…” cluster=”broadcast” /&gt;<br>&lt;dubbo:reference interface=”…” cluster=”broadcast”/ &gt;<br>注：容错机制 在基于 API设置时无效 如 referenceConfig.setCluster(“failback”); 经测试不启作用 </p><h3 id="异步调用"><a href="#异步调用" class="headerlink" title="异步调用"></a>异步调用</h3><p>异步调用是指发起远程调用之后获取结果的方式。</p><ol><li>同步等待结果返回（默认）</li><li>异步等待结果返回</li><li>不需要返回结果</li></ol><p>Dubbo 中关于异步等待结果返回的实现流程如下图：</p><p><img src="/uploads/dubbo/%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8.png" alt="异步调用.png"></p><p>异步调用配置:<br>&lt;dubbo:reference id=”asyncDemoService”<br>interface=”com.tuling.teach.service.async.AsyncDemoService”&gt;</p><!-- 异步调async：true 异步调用 false 同步调用--><p>&lt;dubbo:method name=”sayHello1” async=”false”/&gt;<br>&lt;dubbo:method name=”sayHello2” async=”false”/&gt;<br>&lt;dubbo:method name=”notReturn” return=”false”/&gt;<br></p><p>注：在进行异步调用时 容错机制不能为  cluster=”forking” 或  cluster=”broadcast”</p><h2 id="二、Dubbo-调用非典型使用场景"><a href="#二、Dubbo-调用非典型使用场景" class="headerlink" title="二、Dubbo 调用非典型使用场景"></a>二、Dubbo 调用非典型使用场景</h2><h3 id="泛化提供-amp-引用"><a href="#泛化提供-amp-引用" class="headerlink" title="泛化提供&amp;引用"></a>泛化提供&amp;引用</h3><p>泛化提供<br>是指不通过接口的方式直接将服务暴露出去。通常用于Mock框架或服务降级框架实现。</p><p>泛化引用<br>是指不通过常规接口的方式去引用服务，通常用于测试框架</p><h3 id="隐示传参"><a href="#隐示传参" class="headerlink" title="隐示传参"></a>隐示传参</h3><p>是指通过非常方法参数传递参数，类似于http 调用当中添加cookie值。通常用于分布式追踪框架的实现。使用方式如下 ：<br>//客户端隐示设置值<br>RpcContext.getContext().setAttachment(“index”, “1”); // 隐式传参，后面的远程调用都会隐<br>//服务端隐示获取值<br>String index = RpcContext.getContext().getAttachment(“index”);</p><h3 id="令牌验证"><a href="#令牌验证" class="headerlink" title="令牌验证"></a>令牌验证</h3><p>通过令牌验证在注册中心控制权限，以决定要不要下发令牌给消费者，可以防止消费者绕过注册中心访问提供者，<br>另外通过注册中心可灵活改变授权方式，而不需修改或升级提供者</p><h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p>类似于 WEB 中的Filter ，Dubbo本身提供了Filter 功能用于拦截远程方法的调用。其支持自定义过滤器与官方的过滤器使用：</p><p>演示添加日志访问过滤:</p><p>&lt;dubbo:provider filter=”accesslog” accesslog=”logs/dubbo.log”/&gt;<br>以上配置 就是 为 服务提供者 添加 日志记录过滤器， 所有访问日志将会集中打印至 accesslog 当中</p><h2 id="三、Dubbo调用流程"><a href="#三、Dubbo调用流程" class="headerlink" title="三、Dubbo调用流程"></a>三、Dubbo调用流程</h2><p><img src="/uploads/dubbo/Dubbo%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B.png" alt="Dubbo调用流程.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//------ 6协议 调用</span></span><br><span class="line">doInvoke:<span class="number">77</span>, DubboInvoker &#123;org.apache.dubbo.rpc.protocol.dubbo&#125;</span><br><span class="line">invoke:<span class="number">155</span>, AbstractInvoker &#123;org.apache.dubbo.rpc.protocol&#125;</span><br><span class="line"><span class="comment">//------ 5异步转同步</span></span><br><span class="line">invoke:<span class="number">52</span>, AsyncToSyncInvoker &#123;org.apache.dubbo.rpc.protocol&#125; <span class="comment">// 异步转同步 ,返回结果之前进行阻塞调用线程</span></span><br><span class="line"><span class="comment">//----- 4过滤器链</span></span><br><span class="line">invoke:<span class="number">92</span>, MonitorFilter &#123;org.apache.dubbo.monitor.support&#125;  <span class="comment">// 过滤链-&gt; 监控器</span></span><br><span class="line">invoke:<span class="number">54</span>, FutureFilter &#123;org.apache.dubbo.rpc.protocol.dubbo.filter&#125;    <span class="comment">//过滤链-&gt; 回调参数</span></span><br><span class="line">invoke:<span class="number">14</span>, ProviderHelloFilter &#123;com.wyb.dubbo&#125;  <span class="comment">// 过滤链-&gt; 自定义过滤器</span></span><br><span class="line">invoke:<span class="number">60</span>, ConsumerContextFilter &#123;org.apache.dubbo.rpc.filter&#125; <span class="comment">// 过滤链-&gt; 消费者环境初始化</span></span><br><span class="line"><span class="comment">//------3集群处理</span></span><br><span class="line">doInvoke:<span class="number">82</span>, FailoverClusterInvoker &#123;org.apache.dubbo.rpc.cluster.support&#125; <span class="comment">// 集服-失败重试</span></span><br><span class="line">invoke:<span class="number">248</span>, AbstractClusterInvoker &#123;org.apache.dubbo.rpc.cluster.support&#125; <span class="comment">//</span></span><br><span class="line"><span class="comment">//----- Mock服务</span></span><br><span class="line">invoke:<span class="number">78</span>, MockClusterInvoker &#123;org.apache.dubbo.rpc.cluster.support.wrapper&#125; <span class="comment">// mock 服务</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//----- 2动态代理 --透明化</span></span><br><span class="line">invoke:<span class="number">55</span>, InvokerInvocationHandler &#123;org.apache.dubbo.rpc.proxy&#125;<span class="comment">// 代理的中间接口</span></span><br><span class="line">getUser:-<span class="number">1</span>, proxy0 &#123;org.apache.dubbo.common.bytecode&#125; <span class="comment">// 代理对象</span></span><br><span class="line"><span class="comment">//----- 1调用客户端</span></span><br><span class="line">main:<span class="number">53</span>, DubboClient &#123;com.wyb.dubbo&#125;  <span class="comment">// 客户端</span></span><br><span class="line"></span><br><span class="line">RegistryProtocol --&gt; Cluster --&gt; MockClusterInvoker:ClusterInvoker-&gt;DubboProtocol-&gt;FilterChain:AsyncToSyncInvoker:DubboInvoker</span><br><span class="line">协议--》(注册协议)---&gt;MockClusterInvoker ---》ClusterInvoker---&gt; RegistryDirectory ---&gt;(DubboProtcol)-&gt;FilterChain--&gt;DubboInvoker</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、Dubbo-调用模块基本组成&quot;&gt;&lt;a href=&quot;#一、Dubbo-调用模块基本组成&quot; class=&quot;headerlink&quot; title=&quot;一、Dubbo 调用模块基本组成&quot;&gt;&lt;/a&gt;一、Dubbo 调用模块基本组成&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;透明代理：通过动
      
    
    </summary>
    
    
      <category term="dubbo" scheme="https://marchnineteen.github.io/categories/dubbo/"/>
    
    
  </entry>
  
  <entry>
    <title>dubbo协议模块</title>
    <link href="https://marchnineteen.github.io/2021/09/12/%E5%88%86%E5%B8%83%E5%BC%8F%E6%A1%86%E6%9E%B6%E4%B8%93%E9%A2%98/dubbo/%E5%8D%8F%E8%AE%AE%E6%A8%A1%E5%9D%97/"/>
    <id>https://marchnineteen.github.io/2021/09/12/%E5%88%86%E5%B8%83%E5%BC%8F%E6%A1%86%E6%9E%B6%E4%B8%93%E9%A2%98/dubbo/%E5%8D%8F%E8%AE%AE%E6%A8%A1%E5%9D%97/</id>
    <published>2021-09-12T00:00:00.000Z</published>
    <updated>2023-05-08T01:44:57.959Z</updated>
    
    <content type="html"><![CDATA[<p><strong>课程概要：</strong></p><ol><li>RPC协议基本组成</li><li>RPC协议报文编码与实现详解</li><li>Dubbo中所支持RPC协议与使用<h3 id="RPC协议基本组成"><a href="#RPC协议基本组成" class="headerlink" title="## RPC协议基本组成"></a>## <strong>RPC协议基本组成</strong></h3></li></ol><hr><h3 id="RPC-协议名词解释"><a href="#RPC-协议名词解释" class="headerlink" title="RPC 协议名词解释"></a><strong>RPC 协议名词解释</strong></h3><p>在一个典型RPC的使用场景中，包含了服务发现、负载、容错、网络传输、序列化等组件，其中RPC协议就指明了程序如何进行网络传输和序列化 。也就是说一个RPC协议的实现就等于一个非透明的远程调用实现，如何做到的的呢？</p><p><img src="/uploads/dubbo/Rpc%E5%8D%8F%E8%AE%AE.png" alt="Rpc协议.png"></p><h3 id="协议基本组成："><a href="#协议基本组成：" class="headerlink" title="协议基本组成："></a><strong>协议基本组成：</strong></h3><p><img src="/uploads/dubbo/Rpc%E5%8D%8F%E8%AE%AE%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90.png" alt="Rpc协议基本组成.png"></p><ol><li>地址：服务提供者地址</li><li>端口：协议指定开放的端口</li><li>报文编码：协议报文编码 ，分为请求头和请求体两部分。</li><li>序列化方式：将请求体序列化成对象<ol><li>Hessian2Serialization、</li><li>DubboSerialization、</li><li>JavaSerialization</li><li>JsonSerialization</li></ol></li><li>运行服务: 网络传输实现<ol><li>netty</li><li>mina</li><li>RMI 服务</li><li>servlet 容器（jetty、Tomcat、Jboss）<h2 id="Dubbo中所支持RPC协议使用"><a href="#Dubbo中所支持RPC协议使用" class="headerlink" title="Dubbo中所支持RPC协议使用"></a><strong>Dubbo中所支持RPC协议使用</strong></h2></li></ol></li></ol><hr><p><strong>dubbo 支持的RPC协议列表</strong></p><table><thead><tr><th align="left"><strong>名称</strong></th><th align="left"><strong>实现描述</strong></th><th align="left"><strong>连接描述</strong></th><th align="left"><strong>适用场景</strong></th></tr></thead><tbody><tr><td align="left"><strong>dubbo</strong></td><td align="left">传输服务: mina, netty(默认), grizzy序列化: hessian2(默认), java, fastjson自定义报文</td><td align="left">单个长连接NIO异步传输</td><td align="left">1、常规RPC调用2、传输数据量小3、提供者少于消费者</td></tr><tr><td align="left"><strong>rmi</strong></td><td align="left">传输：java rmi 服务序列化：java原生二进制序列化</td><td align="left">多个短连接BIO同步传输</td><td align="left">1、常规RPC调用  2、与原RMI客户端集成  3、可传少量文件  4、不防火墙穿透</td></tr><tr><td align="left"><strong>hessian</strong></td><td align="left">传输服务：servlet容器序列化：hessian二进制序列化</td><td align="left">基于Http 协议传输，依懒servlet容器配置</td><td align="left">1、提供者多于消费者  2、可传大字段和文件  <del>3、跨语言调用</del></td></tr><tr><td align="left"><strong>http</strong></td><td align="left">传输服务：servlet容器序列化：java原生二进制序列化</td><td align="left">依懒servlet容器配置</td><td align="left">1、数据包大小混合</td></tr><tr><td align="left"><strong>thrift</strong></td><td align="left">与thrift RPC 实现集成，并在其基础上修改了报文头</td><td align="left">长连接、NIO异步传输</td><td align="left"></td></tr></tbody></table><p><strong><em>关于RMI不支持防火墙穿透的补充说明：</em></strong></p><p>原因在于RMI 底层实现中会有两个端口，一个是固定的用于服务发现的注册端口，另外会生成一个<strong><em>随机</em></strong>端口用于网络传输。因为这个随机端口就不能在防火墙中提前设置开放开。所以存在<em>防火墙穿透问题</em></p><h3 id="协议的使用与配置"><a href="#协议的使用与配置" class="headerlink" title="协议的使用与配置:"></a><strong>协议的使用与配置:</strong></h3><p>Dubbo框架配置协议非常方便，用户只需要在 provider 应用中 配置*&lt;*<em>dubbo:protocol&gt;</em>元素即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line"> name: 协议名称 dubbo|rmi|hessian|http|</span><br><span class="line"> host:本机IP可不填，则系统自动获取</span><br><span class="line"> port：端口、填-1表示系统自动选择</span><br><span class="line"> server：运行服务 mina|netty|grizzy|servlet|jetty</span><br><span class="line"> serialization：序列化方式 hessian2|java|compactedjava|fastjson</span><br><span class="line"> 详细配置参见dubbo 官网 dubbo.io</span><br><span class="line">--&gt;</span><br><span class="line">&lt;dubbo:protocol name&#x3D;&quot;dubbo&quot; host&#x3D;&quot;192.168.0.11&quot; port&#x3D;&quot;20880&quot; server&#x3D;&quot;netty&quot;</span><br><span class="line"> serialization&#x3D;“hessian2” charset&#x3D;“UTF-8” &#x2F;&gt;</span><br></pre></td></tr></table></figure><p>#TODO 演示采用其它协议来配置Dubbo</p><ul><li><input disabled type="checkbox"> dubbo 协议采用 json 进行序列化(源码参见：com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol<em>)</em></li><li><input disabled type="checkbox"> 采用RMI协议(源码参见：<em>com.alibaba.dubbo.rpc.protocol.rmi.RmiProtocol)</em></li><li><input disabled type="checkbox"> 采用Http协议(源码参见：<em>com.alibaba.dubbo.rpc.protocol.http.HttpProtocol.InternalHandler)</em></li><li><input disabled type="checkbox"> 采用Heason协议(源码参见:com.alibaba.dubbo.rpc.protocol.hessian.HessianProtocol.HessianHandler)</li></ul><p>new PrintWriter(System.out)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -aon|findstr &quot;17732&quot;</span><br></pre></td></tr></table></figure><p>序列化：</p><table><thead><tr><th align="left"></th><th align="left">特点</th></tr></thead><tbody><tr><td align="left">fastjson</td><td align="left">文本型：体积较大，性能慢、跨语言、可读性高</td></tr><tr><td align="left">fst</td><td align="left">二进制型：体积小、兼容 JDK 原生的序列化。要求 JDK 1.7 支持。</td></tr><tr><td align="left">hessian2</td><td align="left">二进制型：跨语言、容错性高、体积小</td></tr><tr><td align="left">java</td><td align="left">二进制型：在JAVA原生的基础上 可以写入Null</td></tr><tr><td align="left">compactedjava</td><td align="left">二进制型：与java 类似，内容做了压缩</td></tr><tr><td align="left">nativejava</td><td align="left">二进制型：原生的JAVA 序列化</td></tr><tr><td align="left">kryo</td><td align="left">二进制型：体积比hessian2 还要小，但容错性 没有hessian2 好</td></tr></tbody></table><h3 id="Hessian-序列化："><a href="#Hessian-序列化：" class="headerlink" title="Hessian 序列化："></a>Hessian 序列化：</h3><ul><li>参数及返回值需实现Serializable接口</li><li>参数及返回值不能自定义实现List,Map,Number,Date,Calendar等接口，只能用 JDK 自带的实现，因为 hessian 会做特殊处理，自定义实现类中的属性值都会丢失。</li><li>Hessian 序列化，只传成员属性值和值的类型，不传方法或静态变量，兼容情况<a href="http://dubbo.apache.org/zh-cn/docs/user/references/protocol/dubbo.html#fn1" target="_blank" rel="noopener">[1]</a><br><a href="http://dubbo.apache.org/zh-cn/docs/user/references/protocol/dubbo.html#fn2" target="_blank" rel="noopener">[2]</a></li></ul><table><thead><tr><th align="left"><strong>数据通讯</strong></th><th align="left"><strong>情况</strong></th><th align="left"><strong>结果</strong></th></tr></thead><tbody><tr><td align="left">A-&gt;B</td><td align="left">类A多一种 属性（或者说类B少一种 属性）</td><td align="left">不抛异常，A多的那 个属性的值，B没有， 其他正常</td></tr><tr><td align="left">A-&gt;B</td><td align="left">枚举A多一种 枚举（或者说B少一种 枚举），A使用多 出来的枚举进行传输</td><td align="left">抛异常</td></tr><tr><td align="left">A-&gt;B</td><td align="left">枚举A多一种 枚举（或者说B少一种 枚举），A不使用 多出来的枚举进行传输</td><td align="left">不抛异常，B正常接 收数据</td></tr><tr><td align="left">A-&gt;B</td><td align="left">A和B的属性 名相同，但类型不相同</td><td align="left">抛异常</td></tr><tr><td align="left">A-&gt;B</td><td align="left">serialId 不相同</td><td align="left">正常传输</td></tr></tbody></table><p>接口增加方法，对客户端无影响，如果该方法不是客户端需要的，客户端不需要重新部署。输入参数和结果集中增加属性，对客户端无影响，如果客户端并不需要新属性，不用重新部署。</p><p>输入参数和结果集属性名变化，对客户端序列化无影响，但是如果客户端不重新部署，不管输入还是输出，属性名变化的属性值是获取不到的。</p><p>总结：服务器端和客户端对领域对象并不需要完全一致，而是按照最大匹配原则。</p><ul><li><input disabled type="checkbox"> 演示Hession2 序列化的容错性</li></ul><h2 id="三-、RPC协议报文编码与实现详解"><a href="#三-、RPC协议报文编码与实现详解" class="headerlink" title="三 、RPC协议报文编码与实现详解"></a><strong>三 、RPC协议报文编码与实现详解</strong></h2><hr><h3 id="RPC-传输实现："><a href="#RPC-传输实现：" class="headerlink" title="RPC 传输实现："></a><strong>RPC 传输实现：</strong></h3><p>RPC的协议的传输是基于 TCP/IP 做为基础使用Socket 或Netty、mina等网络编程组件实现。但有个问题是TCP是面向字节流的无边边界协议，其只管负责数据传输并不会区分每次请求所对应的消息，这样就会出现TCP协义传输当中的拆包与粘包问题</p><h3 id="拆包与粘包产生的原因："><a href="#拆包与粘包产生的原因：" class="headerlink" title="拆包与粘包产生的原因："></a><strong>拆包与粘包产生的原因：</strong></h3><p>我们知道tcp是以流动的方式传输数据，传输的最小单位为一个报文段（segment）。tcp Header中有个Options标识位，常见的标识为mss(Maximum Segment Size)指的是，连接层每次传输的数据有个最大限制MTU(Maximum Transmission Unit)，一般是1500比特，超过这个量要分成多个报文段，mss则是这个最大限制减去TCP的header，光是要传输的数据的大小，一般为1460比特。换算成字节，也就是180多字节。</p><p>tcp为提高性能，发送端会将需要发送的数据发送到缓冲区，等待缓冲区满了之后，再将缓冲中的数据发送到接收方。同理，接收方也有缓冲区这样的机制，来接收数据。这时就会出现以下情况：</p><ol><li>应用程序写入的数据大于MSS大小，这将会发生拆包。</li><li>应用程序写入数据小于MSS大小，这将会发生粘包。</li><li>接收方法不及时读取套接字缓冲区数据，这将发生粘包。<h3 id="拆包与粘包解决办法："><a href="#拆包与粘包解决办法：" class="headerlink" title="拆包与粘包解决办法："></a><strong>拆包与粘包解决办法：</strong></h3></li><li>设置定长消息，服务端每次读取既定长度的内容作为一条完整消息。</li><li>{“type”:”message”,”content”:”hello”}\n</li><li>使用带消息头的协议、消息头存储消息开始标识及消息长度信息，服务端获取消息头的时候解析出消息长度，然后向后读取该长度的内容。</li></ol><p><strong>比如：</strong>Http协议 heade 中的 Content-Length 就表示消息体的大小。</p><p><img src="/uploads/dubbo/Http%E5%8D%8F%E8%AE%AEhead.png" alt="http协议head.png"></p><h3 id="Dubbo-协议报文编码："><a href="#Dubbo-协议报文编码：" class="headerlink" title="Dubbo 协议报文编码："></a>Dubbo 协议报文编码：</h3><p><img src="/uploads/dubbo/Dubbo%E5%8D%8F%E8%AE%AE%E6%8A%A5%E6%96%87%E7%BC%96%E7%A0%81.png" alt="Dubbo协议报文编码.png"></p><ul><li><strong>magic</strong>：类似java字节码文件里的魔数，用来判断是不是dubbo协议的数据包。魔数是常量0xdabb,用于判断报文的开始。</li><li><strong>flag</strong>：标志位, 一共8个地址位。低四位用来表示消息体数据用的序列化工具的类型（默认hessian），高四位中，第一位为1表示是request请求，第二位为1表示双向传输（即有返回response），第三位为1表示是心跳ping事件。</li><li><strong>status</strong>：状态位, 设置请求响应状态，dubbo定义了一些响应的类型。具体类型见 com.alibaba.dubbo.remoting.exchange.Response</li><li><strong>invoke id：</strong>消息id, long 类型。每一个请求的唯一识别id（由于采用异步通讯的方式，用来把请求request和返回的response对应上）</li><li><strong>body length：</strong>消息体 body 长度, int 类型，即记录Body Content有多少个字节。</li></ul><p><img src="/uploads/dubbo/Dubbo%E5%8D%8F%E8%AE%AE%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.png" alt="img.png"></p><pre><code>*（注：相关源码参见**c**om.alibaba.dubbo.rpc.protocol.dubbo.DubboCodec**）*</code></pre><h3 id="Dubbo协议的编解码过程："><a href="#Dubbo协议的编解码过程：" class="headerlink" title="Dubbo协议的编解码过程："></a><strong><em>Dubbo协议的编解码过程：</em></strong></h3><p><img src="/uploads/dubbo/Dubbo%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%BC%96%E8%A7%A3%E7%A0%81%E8%BF%87%E7%A8%8B.png" alt="Dubbo协议的编解码过程.png"></p><p><strong>Dubbo 协议编解码实现过程*</strong>(源码来源于<em>*dubbo2.5.8 )</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、DubboCodec.encodeRequestData() 116L &#x2F;&#x2F; 编码request</span><br><span class="line">2、DecodeableRpcInvocation.decode()  89L   &#x2F;&#x2F; 解码request</span><br><span class="line">3、DubboCodec.encodeResponseData()   184L  &#x2F;&#x2F; 编码response    </span><br><span class="line">4、DecodeableRpcResult.decode()      73L   &#x2F;&#x2F; 解码response</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;课程概要：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;RPC协议基本组成&lt;/li&gt;
&lt;li&gt;RPC协议报文编码与实现详解&lt;/li&gt;
&lt;li&gt;Dubbo中所支持RPC协议与使用&lt;h3 id=&quot;RPC协议基本组成&quot;&gt;&lt;a href=&quot;#RPC协议基本组成&quot; c
      
    
    </summary>
    
    
      <category term="dubbo" scheme="https://marchnineteen.github.io/categories/dubbo/"/>
    
    
  </entry>
  
  <entry>
    <title>dubbo注册中心</title>
    <link href="https://marchnineteen.github.io/2021/09/12/%E5%88%86%E5%B8%83%E5%BC%8F%E6%A1%86%E6%9E%B6%E4%B8%93%E9%A2%98/dubbo/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/"/>
    <id>https://marchnineteen.github.io/2021/09/12/%E5%88%86%E5%B8%83%E5%BC%8F%E6%A1%86%E6%9E%B6%E4%B8%93%E9%A2%98/dubbo/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/</id>
    <published>2021-09-12T00:00:00.000Z</published>
    <updated>2023-05-08T01:44:57.959Z</updated>
    
    <content type="html"><![CDATA[<h1 id="注册中心的作用"><a href="#注册中心的作用" class="headerlink" title="注册中心的作用"></a>注册中心的作用</h1><p>为了达到服务器动态扩容的目的，注册中心存储的服务器的地址信息和可用状态，并实时推送给订阅了相关服务的客户端。</p><p>一个完整的注册中心需要实现以下功能：</p><p>1.接收服务端的注册和客户端的引用，即 将服务与消费相关联，并支持多对多。<br>2.支持服务端宕机后能即时清楚其状态。<br>3.注册中心重启后，可以自动恢复注册的数据和订阅的请求。<br>4.注册中心自身的集群。</p><h1 id="Dubbo所支持的注册中心"><a href="#Dubbo所支持的注册中心" class="headerlink" title="Dubbo所支持的注册中心"></a>Dubbo所支持的注册中心</h1><p>1.Multicast注册中心:</p><ul><li>基于组网广播技术，只能用在局域网内，一般用于简单的测试服务</li></ul><p>2.zookeeper 注册中心(推荐)</p><p>3.Redis注册中心</p><p>4.Simple注册中心</p><h1 id="Redis-注册中心"><a href="#Redis-注册中心" class="headerlink" title="Redis 注册中心"></a>Redis 注册中心</h1><p>关于Redis注册中心我们需要了解两点，</p><ol><li>如何存储服务的注册与订阅关系</li><li>是当服务状态改变时如何即时更新</li></ol><h2 id="如何存储服务的注册与订阅关系"><a href="#如何存储服务的注册与订阅关系" class="headerlink" title="如何存储服务的注册与订阅关系"></a>如何存储服务的注册与订阅关系</h2><p>使用redis的发布订阅(pub/sub)模型。</p><p>redis中存储的数据结构。</p><p>服务端：<br>Reids中增加了一个Hash 类型的记录，其key为/dubbo/tuling.dubbo.server.UserService/providers。Value中分别存储了两个服务提供者的URL和有效期。</p><p><img src="/uploads/dubbo/Redis%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%A8%A1%E5%9E%8B.png" alt="Redis服务端模型.png"></p><p>客户端:<br>主 Key 为服务名和类型 </p><p>Map 中的 Key 为 URL 地址</p><p>Map 中的 Value 为过期时间，用于判断脏数据，脏数据由监控中心删除</p><h2 id="是当服务状态改变时如何即时更新"><a href="#是当服务状态改变时如何即时更新" class="headerlink" title="是当服务状态改变时如何即时更新"></a>是当服务状态改变时如何即时更新</h2><p>这里Dubbo采用的是定时心跳的机制 来维护服务URL的有效期，默认每30秒更新一次有效期。即URL对应的毫秒值。<br>具体代码参见：com.alibaba.dubbo.registry.redis.RedisRegistry#expireExecutor</p><p><img src="/uploads/dubbo/Redis%E5%BF%83%E8%B7%B3.png" alt="Redis心跳.png"></p><p>com.alibaba.dubbo.registry.redis.RedisRegistry#deferExpired<br>com.alibaba.dubbo.registry.integration.RegistryDirectory<br>com.alibaba.dubbo.registry.support.ProviderConsumerRegTable</p><h1 id="Zookeeper-注册中心"><a href="#Zookeeper-注册中心" class="headerlink" title="Zookeeper 注册中心"></a>Zookeeper 注册中心</h1><p>Zookeper是一个树型的目录服务，本身支持变更推送相比redis的实现Publish/Subscribe功能更稳定。</p><p>结构：<br><img src="/uploads/dubbo/Zookeeper%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83.png" alt="Zookeeper注册中心.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;注册中心的作用&quot;&gt;&lt;a href=&quot;#注册中心的作用&quot; class=&quot;headerlink&quot; title=&quot;注册中心的作用&quot;&gt;&lt;/a&gt;注册中心的作用&lt;/h1&gt;&lt;p&gt;为了达到服务器动态扩容的目的，注册中心存储的服务器的地址信息和可用状态，并实时推送给订阅了相关服务的
      
    
    </summary>
    
    
      <category term="dubbo" scheme="https://marchnineteen.github.io/categories/dubbo/"/>
    
    
  </entry>
  
  <entry>
    <title>synchronized&amp;Lock&amp;AQS</title>
    <link href="https://marchnineteen.github.io/2021/06/09/java/coucurrent/2.synchronized&amp;Lock&amp;AQS/"/>
    <id>https://marchnineteen.github.io/2021/06/09/java/coucurrent/2.synchronized&amp;Lock&amp;AQS/</id>
    <published>2021-06-09T00:00:00.000Z</published>
    <updated>2023-05-08T01:44:57.915Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发同步器"><a href="#并发同步器" class="headerlink" title="并发同步器"></a>并发同步器</h1><p>多线程编程中，有可能会出现多个线程同时访问同一个共享、可变资源的情况；这种资源可能是：对象、变量、文件等。</p><ul><li>共享：资源可以由多个线程同时访问</li><li>可变：资源可以在其生命周期内被修改</li></ul><p>引出的问题：<br>由于线程执行的过程是不可控的，所以需要采用同步机制来协同对对象可变状态的访问</p><p>加锁目的：序列化访问临界资源，即同一时刻只能有一个线程访问临界资源(同步互斥访问)</p><h1 id="Java锁体系"><a href="#Java锁体系" class="headerlink" title="Java锁体系"></a>Java锁体系</h1><p><img src="/uploads/java/concurrent/Java%E9%94%81%E4%BD%93%E7%B3%BB.png" alt="Java锁体系"></p><blockquote><p><a href="https://juejin.cn/post/6844904110085373966" target="_blank" rel="noopener">https://juejin.cn/post/6844904110085373966</a></p></blockquote><h1 id="synchronized使用与原理"><a href="#synchronized使用与原理" class="headerlink" title="synchronized使用与原理"></a>synchronized使用与原理</h1><p>加锁方式：</p><ul><li>同步实例方法，锁是当前实例对象</li><li>同步类方法，锁是当前类对象</li><li>同步代码块，锁是括号里面的对象</li></ul><p>底层原理:</p><p>JVM内置锁通过synchronized使用，通过内部对象Monitor(监视器锁)实现，基于进入与退出Monitor对象实现方法与<br>代码块同步，监视器锁的实现依赖底层操作系统的Mutex lock（互斥锁）实现，它是一个重量级锁性能较低</p><p><img src="/uploads/java/concurrent/synchronized.png" alt="synchronized"></p><h2 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h2><p>每个对象都有一个自己的Monitor(监视器锁)</p><p>JVM加锁过程：</p><p><img src="/uploads/java/concurrent/synchronized%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B.png" alt="synchronized加锁过程"></p><h2 id="对象内存结构详见jvm"><a href="#对象内存结构详见jvm" class="headerlink" title="对象内存结构详见jvm"></a>对象内存结构<a href="https://marchnineteen.github.io/2018/10/31/java/jvm/jvm(1">详见jvm</a></h2><p>认识对象的内存结构：</p><ul><li>对象头：比如 hash码，对象所属的年代，对象锁，锁状态标志，偏向锁（线程）ID，偏向时间，数组长度（数组对象）等</li><li>对象实际数据：即创建对象时，对象中成员变量，方法等</li><li>对齐填充：对象的大小必须是8字节的整数倍</li></ul><p>面试问题：</p><p>实例对象内存中存储在哪？</p><p>如果实例对象存储在堆区时：实例对象内存存在堆区，实例的引用存在栈上，实例的元数据class存在方法区或者元空间</p><p>Object实例对象一定是存在堆区的吗？</p><p>不一定，如果实例对象没有线程逃逸行为</p><p><img src="/uploads/java/concurrent/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png" alt="对象的内存结构"></p><h3 id="MarkWord"><a href="#MarkWord" class="headerlink" title="MarkWord"></a>MarkWord</h3><p>以32位JVM中存储内容为例</p><p><img src="/uploads/java/concurrent/MarkWord.png" alt="MarkWord"></p><h2 id="锁优化升级过程"><a href="#锁优化升级过程" class="headerlink" title="锁优化升级过程"></a>锁优化升级过程</h2><p>JDK1.6版本之后对synchronized的实现进行了各种优化，如自旋锁、偏向锁和轻量级锁<br>并默认开启偏向锁<br>开启偏向锁：-XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0<br>关闭偏向锁：-XX:-UseBiasedLocking</p><p>偏向锁：单线程场景<br>轻量级锁：线程间交替执行场景，本身竞争不是很激烈。</p><p><img src="/uploads/java/concurrent/JVM%E5%86%85%E7%BD%AE%E9%94%81%E4%BC%98%E5%8C%96%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B.png" alt="JVM内置锁优化升级过程"></p><p><img src="/uploads/java/concurrent/%E9%94%81%E4%BC%98%E5%8C%96%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B.png" alt="锁优化升级过程"></p><p><img src="/uploads/java/concurrent/JVM%E9%94%81%E7%9A%84%E8%86%A8%E8%83%80%E5%8D%87%E7%BA%A7.jpg" alt="JVM锁的膨胀升级"></p><h1 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h1><p><img src="/uploads/java/concurrent/lock.png" alt="lock"></p><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><blockquote><p><a href="https://juejin.cn/post/6844903598984282119" target="_blank" rel="noopener">https://juejin.cn/post/6844903598984282119</a></p></blockquote><h2 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h2><h1 id="AbstractQueuedSynchronizer"><a href="#AbstractQueuedSynchronizer" class="headerlink" title="AbstractQueuedSynchronizer"></a>AbstractQueuedSynchronizer</h1><p>Java并发编程核心在于java.concurrent.util包<br>而juc当中的大多数同步器实现都是围绕着共同的基础行为，比如等待队列、条件队列、独占获取、共享获取等，而这个行为的抽象就是基于AbstractQueuedSynchronizer简称AQS，<br>AQS定义了一套多线程访问共享资源的同步器框架，是一个依赖状态(state)的同步器。</p><p>AQS具备特性</p><ul><li>阻塞等待队列</li><li>共享/独占</li><li>公平/非公平</li><li>可重入</li><li>允许中断</li></ul><h2 id="并发编程包依赖于AQS的内部实现"><a href="#并发编程包依赖于AQS的内部实现" class="headerlink" title="并发编程包依赖于AQS的内部实现"></a>并发编程包依赖于AQS的内部实现</h2><p>Java.concurrent.util当中同步器的实现如Lock,Latch,Barrier等，都是基于AQS框架实现</p><ul><li>一般通过定义内部类Sync继承AQS</li><li>将同步器所有调用都映射到Sync对应的方法</li></ul><p>AQS框架-管理状态</p><p>AQS内部维护属性volatile int state (32位)</p><ul><li>state表示资源的可用状态</li></ul><p>State三种访问方式</p><ul><li>getState()、setState()、compareAndSetState()</li></ul><p>AQS定义两种资源共享方式</p><ul><li>Exclusive-独占，只有一个线程能执行，如ReentrantLock</li><li>Share-共享，多个线程可以同时执行，如Semaphore/CountDownLatch</li></ul><p>AQS定义两种队列</p><ul><li>同步等待队列</li><li>条件等待队列</li></ul><h2 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h2><p>CLH队列是Craig、Landin、Hagersten三人发明的一种基于双向链表数据结构的队列， 是FIFO先入先出线程等待队列，<br>Java中的CLH队列是原CLH队列的一个变种, 线程由原自旋机制改为阻塞机制。</p><p><img src="/uploads/java/concurrent/CLH%E9%98%9F%E5%88%97.png" alt="CLH队列"></p><h2 id="条件队列"><a href="#条件队列" class="headerlink" title="条件队列"></a>条件队列</h2><p>Condition是一个多线程间协调通信的工具类，使得某个，或者某些线程一起等待某个条件（Condition）,只有当该条件具备时 ，这些等待线程才会被唤醒，从而重新争夺锁</p><p><img src="/uploads/java/concurrent/%E6%9D%A1%E4%BB%B6%E9%98%9F%E5%88%97.png" alt="条件队列"></p><h2 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h2><p><img src="/uploads/java/concurrent/%E5%85%AC%E5%B9%B3%E9%94%81.png" alt="公平锁"></p><h2 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h2><p><img src="/uploads/java/concurrent/%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81.png" alt="非公平锁"></p><h2 id="重入锁"><a href="#重入锁" class="headerlink" title="重入锁"></a>重入锁</h2><p><img src="/uploads/java/concurrent/%E9%87%8D%E5%85%A5%E9%94%81.png" alt="重入锁"></p><h2 id="不可重入锁"><a href="#不可重入锁" class="headerlink" title="不可重入锁"></a>不可重入锁</h2><p><img src="/uploads/java/concurrent/%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81.png" alt="不可重入锁"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;并发同步器&quot;&gt;&lt;a href=&quot;#并发同步器&quot; class=&quot;headerlink&quot; title=&quot;并发同步器&quot;&gt;&lt;/a&gt;并发同步器&lt;/h1&gt;&lt;p&gt;多线程编程中，有可能会出现多个线程同时访问同一个共享、可变资源的情况；这种资源可能是：对象、变量、文件等。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="并发编程" scheme="https://marchnineteen.github.io/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>JMM&amp;volatile</title>
    <link href="https://marchnineteen.github.io/2021/06/08/java/coucurrent/1.JMM&amp;volatile/"/>
    <id>https://marchnineteen.github.io/2021/06/08/java/coucurrent/1.JMM&amp;volatile/</id>
    <published>2021-06-08T00:00:00.000Z</published>
    <updated>2023-05-08T01:44:57.915Z</updated>
    
    <content type="html"><![CDATA[<h1 id="现代计算机模型"><a href="#现代计算机模型" class="headerlink" title="现代计算机模型"></a>现代计算机模型</h1><p>冯诺依曼计算机模型<br><img src="/uploads/java/concurrent/%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A8%A1%E5%9E%8B.png" alt="冯诺依曼计算机模型"></p><p>现代计算机硬件基本结构<br><img src="/uploads/java/concurrent/%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.png" alt="现代计算机硬件基本结构"></p><p>CPU内部结构<br><img src="/uploads/java/concurrent/CPU%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.png" alt="CPU内部结构"></p><p>CPU多核缓存架构<br><img src="/uploads/java/concurrent/CPU%E5%A4%9A%E6%A0%B8%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.png" alt="CPU多核缓存架构"></p><p>缓存一致性协议(MESI)<br><img src="/uploads/java/concurrent/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE.png" alt="缓存一致性协议"></p><h2 id="具体流程："><a href="#具体流程：" class="headerlink" title="具体流程："></a>具体流程：</h2><p><strong>主存中存在变量x=1，多cpu多线程读取x（lock的是缓存行，当锁的数据横跨多个缓存行时就会进行总线加锁），copy副本到工作线程，此时所有线程中缓存行的状态<br>都是S，T1线程想要修改x时，把缓存行设为E，T1修改x之后，其它线程通过总线嗅探机制时刻监听着，其它线程对该缓存行的操作，<br>发现T1变成M之后，其它线程的变成I，T1对x的操作，等待某一个时间后，刷回主存。其它线程，当发现x被修改之后，会重新去主存中<br>copy，但是cpu不会等待，从而出现指令重排。</strong></p><p><img src="/uploads/java/concurrent/CPU%E5%A4%9A%E6%A0%B8%E7%BC%93%E5%AD%98%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" alt="具体流程"></p><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h2><p>进程是系统分配资源的基本单位，线程是调度CPU的基本单位，一个进程至少包含一个执行线程，<br>线程寄生在进程当中。每个线程都有一个程序计数器（记录要执行的下一条指令），<br>一组寄存器（保存当前线程的工作变量），堆栈（记录执行历史，其中每一帧保存了一个已经调用但未返回的过程）</p><p>线程分为两类：<br>用户级线程(User-Level Thread)<br>内核线线程(Kernel-Level Thread)</p><p>用户空间划分：<br>内核空间<br>用户空间</p><p><img src="/uploads/java/concurrent/%E7%BA%BF%E7%A8%8B%E6%B7%B1%E5%85%A5%E8%A7%A3%E8%AF%BB.png" alt="线程深入解读"></p><h2 id="Java线程与内核线程的关系"><a href="#Java线程与内核线程的关系" class="headerlink" title="Java线程与内核线程的关系"></a>Java线程与内核线程的关系</h2><p><img src="/uploads/java/concurrent/Java%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="Java线程与内核线程的关系"></p><h2 id="Java线程生命状态"><a href="#Java线程生命状态" class="headerlink" title="Java线程生命状态"></a>Java线程生命状态</h2><p><img src="/uploads/java/concurrent/Java%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E7%8A%B6%E6%80%81.png" alt="Java线程生命状态"></p><h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h2 id="为什么用到并发"><a href="#为什么用到并发" class="headerlink" title="为什么用到并发"></a>为什么用到并发</h2><ul><li>充分利用多核CPU的计算能力</li><li>方便业务拆分，提升应用性能</li></ul><h2 id="并发产生的问题"><a href="#并发产生的问题" class="headerlink" title="并发产生的问题"></a>并发产生的问题</h2><ul><li>高并发场景下，导致频繁的上下文切换</li><li>临界区线程安全问题，容易出现死锁的，产生死锁就会造成系统功能不可用</li><li>其它</li></ul><p><img src="/uploads/java/concurrent/%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E8%BF%87%E7%A8%8B.png" alt="线程上下文切换过程"></p><h1 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h1><p>JMM与JVM内存区域的划分是不同的概念层次，更恰当说JMM描述的是一组规则，通过这组规则控制程序中各个变量在共享数据区域和私有数据区域的访问方式，<br>JMM是围绕原子性，有序性、可见性展开。</p><p>简单来说：JMM是计算机CPU多核缓存架构java实现，是一种规则。</p><p><img src="/uploads/java/concurrent/JMM%E6%A8%A1%E5%9E%8B.png" alt="JMM模型"></p><h2 id="JVM虚拟机规范主内存与工作内存"><a href="#JVM虚拟机规范主内存与工作内存" class="headerlink" title="JVM虚拟机规范主内存与工作内存"></a>JVM虚拟机规范主内存与工作内存</h2><p><img src="/uploads/java/concurrent/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%A7%84%E8%8C%83%E4%B8%BB%E5%86%85%E5%AD%98%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98.png" alt="JVM虚拟机规范主内存与工作内存"></p><h2 id="Java内存模型与硬件内存架构的关系"><a href="#Java内存模型与硬件内存架构的关系" class="headerlink" title="Java内存模型与硬件内存架构的关系"></a>Java内存模型与硬件内存架构的关系</h2><p>JMM模型跟CPU缓存模型结构类似，是基于CPU缓存模型建立起来的，JMM模型是标准化的，<br>屏蔽掉了底层不同计算机的区别。对于硬件内存来说只有寄存器、缓存内存、主内存的概念，并没有工作内存(线程私有数据区域)和主内存(堆内存)之分，<br>也就是说Java内存模型对内存的划分对硬件内存并没有任何影响</p><p><img src="/uploads/java/concurrent/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%A1%AC%E4%BB%B6%E5%86%85%E5%AD%98%E6%9E%B6%E6%9E%84%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="Java内存模型与硬件内存架构的关系"></p><h2 id="Java内存模型内存交互操作"><a href="#Java内存模型内存交互操作" class="headerlink" title="Java内存模型内存交互操作"></a>Java内存模型内存交互操作</h2><p>1.lock(锁定)：作用于主内存的变量，把一个变量标记为一条线程独占状态<br>2.unlock(解锁)：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定<br>3.read(读取)：作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用<br>4.load(载入)：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中<br>5.use(使用)：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎<br>6.assign(赋值)：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量<br>7.store(存储)：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作<br>8.write(写入)：作用于工作内存的变量，它把store操作从工作内存中的一个变量的值传送到主内存的变量中</p><p>把一个变量从主内存中复制到工作内存中，就需要按顺序地执行read和load操作，如果把变量从工作内存中同步到主内存中，<br>就需要按顺序地执行store和write操作。但Java内存模型只要求上述8大操作(原子操作)必须按顺序执行，而没有保证必须是连续执行。</p><p><strong>read和load同时出现，store和write同时出现</strong></p><p><img src="/uploads/java/concurrent/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%86%85%E5%AD%98%E4%BA%A4%E4%BA%92%E6%93%8D%E4%BD%9C.png" alt="Java内存模型内存交互操作"></p><h2 id="Java内存模型内存同步规则"><a href="#Java内存模型内存同步规则" class="headerlink" title="Java内存模型内存同步规则"></a>Java内存模型内存同步规则</h2><p><img src="/uploads/java/concurrent/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%86%85%E5%AD%98%E5%90%8C%E6%AD%A5%E8%A7%84%E5%88%99.png" alt="Java内存模型内存同步规则"></p><h1 id="volatile原理与内存语义"><a href="#volatile原理与内存语义" class="headerlink" title="volatile原理与内存语义"></a>volatile原理与内存语义</h1><p>volatile是Java虚拟机提供的轻量级的同步机制</p><p>volatile语义有如下两个作用</p><ul><li>可见性：保证被volatile修饰的共享变量对所有线程总数可见的，也就是当一个线程修改了一个被volatile修饰共享变量的值，新值总是可以被其他线程立即得知。</li><li>有序性：禁止指令重排序优化。</li></ul><p>volatile缓存可见性实现原理</p><ul><li>JMM内存交互层面：volatile修饰的变量的read、load、use操作和assign、store、write必须是连续的，即修改后必须立即同步会主内存，使用时必须从主内存刷新，由此保证volatile变量的可见性。</li><li>底层实现：通过汇编lock前缀指令，它会锁定变量缓存行区域并写回主内存，这个操作称为“缓存锁定”，缓存一致性机制会阻止同时修改被两个以上处理器缓存的内存区域数据。一个处理器的缓存回写到内存内存会导致其他处理器的缓存无效</li><li>汇编代码查看<br>XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly -Xcomp</li></ul><h1 id="可见性-amp-原子性-amp-有序性"><a href="#可见性-amp-原子性-amp-有序性" class="headerlink" title="可见性&amp;原子性&amp;有序性"></a>可见性&amp;原子性&amp;有序性</h1><p>并发编程三大特性</p><ul><li>可见性</li><li>原子性</li><li>有序性</li></ul><p>volatile保证可见性与有序性，但是不能保证原子性，要保证原子性需要借助synchronized、Lock锁机制，同理也能保证有序性与可见性。因为synchronized和Lock能够保证任一时刻只有一个线程访问该代码块。</p><h1 id="有序性-amp-指令重排"><a href="#有序性-amp-指令重排" class="headerlink" title="有序性&amp;指令重排"></a>有序性&amp;指令重排</h1><p>java语言规范规定JVM线程内部维持顺序化语义。即只要程序的最终结果与它顺序化情况的结果相等，那么指令的执行顺序可以与代码顺序不一致，此过程叫指令的重排序。</p><p>指令重排序的意义：JVM能根据处理器特性（CPU多级缓存系统、多核处理器等）适当的对机器指令进行重排序，使机器指令能更符合CPU的执行特性，最大限度的发挥机器性能。</p><p>在编译器与CPU处理器中都能执行指令重排优化操作</p><p><img src="/uploads/java/concurrent/%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92.png" alt="指令重排"></p><h1 id="总线风暴–过度使用volatile可能产生的问题"><a href="#总线风暴–过度使用volatile可能产生的问题" class="headerlink" title="总线风暴–过度使用volatile可能产生的问题"></a>总线风暴–过度使用volatile可能产生的问题</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;现代计算机模型&quot;&gt;&lt;a href=&quot;#现代计算机模型&quot; class=&quot;headerlink&quot; title=&quot;现代计算机模型&quot;&gt;&lt;/a&gt;现代计算机模型&lt;/h1&gt;&lt;p&gt;冯诺依曼计算机模型&lt;br&gt;&lt;img src=&quot;/uploads/java/concurrent/%E
      
    
    </summary>
    
    
      <category term="并发编程" scheme="https://marchnineteen.github.io/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>杭州地铁规划2025</title>
    <link href="https://marchnineteen.github.io/2020/04/10/other/hangzhoumetro2025/"/>
    <id>https://marchnineteen.github.io/2020/04/10/other/hangzhoumetro2025/</id>
    <published>2020-04-10T00:00:00.000Z</published>
    <updated>2023-05-08T01:44:57.935Z</updated>
    
    <content type="html"><![CDATA[<h1 id="杭州地铁规划2025"><a href="#杭州地铁规划2025" class="headerlink" title="杭州地铁规划2025"></a>杭州地铁规划2025</h1><p><img src="/uploads/other/%E6%9D%AD%E5%B7%9E%E5%9C%B0%E9%93%81%E8%A7%84%E5%88%922025.jpg" alt="杭州地铁规划2025.jpg"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;杭州地铁规划2025&quot;&gt;&lt;a href=&quot;#杭州地铁规划2025&quot; class=&quot;headerlink&quot; title=&quot;杭州地铁规划2025&quot;&gt;&lt;/a&gt;杭州地铁规划2025&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/uploads/other/%E6%9D%AD%E5%
      
    
    </summary>
    
    
      <category term="other" scheme="https://marchnineteen.github.io/categories/other/"/>
    
    
  </entry>
  
  <entry>
    <title>java 1.8  steam流操作</title>
    <link href="https://marchnineteen.github.io/2020/01/11/java/javase/streamApiAction/"/>
    <id>https://marchnineteen.github.io/2020/01/11/java/javase/streamApiAction/</id>
    <published>2020-01-11T00:00:00.000Z</published>
    <updated>2023-05-08T01:44:57.935Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/MarchNineteen/spring-example/blob/master/spring-example-test/src/main/java/com/wyb/test/java/java8/StreamApiAction.java" target="_blank" rel="noopener">相应源码地址</a></p><h2 id="流操作类型"><a href="#流操作类型" class="headerlink" title="流操作类型"></a>流操作类型</h2><h3 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h3><p>目的是打开一个流，做出一些操作或者映射后，会返回一个新的流交给下个操作。lazy的，在调用方式时并没有真正执行。</p><h3 id="终止操作"><a href="#终止操作" class="headerlink" title="终止操作"></a>终止操作</h3><p>在执行这个操作后，流被使用，在出现终止操作时才会调用之前的所有方法。</p><h3 id="short-circuiting"><a href="#short-circuiting" class="headerlink" title="short-circuiting"></a>short-circuiting</h3><p>对于一个 intermediate 操作，如果它接受的是一个无限大（infinite/unbounded）的 Stream，但返回一个有限的新 Stream。<br>对于一个 terminal 操作，如果它接受的是一个无限大的 Stream，但能在有限的时间计算出结果。</p><h2 id="具体流操作"><a href="#具体流操作" class="headerlink" title="具体流操作"></a>具体流操作</h2><h3 id="中间操作-1"><a href="#中间操作-1" class="headerlink" title="中间操作"></a>中间操作</h3><ul><li>map (mapToInt, flatMap 等)</li></ul><p>把input Stream 的每一个元素，映射成 output Stream 的另外一个元素。</p><p>map一对一</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;list中数的平方</span><br><span class="line">list.stream().map(v -&gt; v * v)</span><br></pre></td></tr></table></figure><p>flatMap一对多 多对多 映射,把流扁平化，多个流转化成流里所有元素的单个流。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list1 &#x3D; Arrays.asList(1, 2, 3, 4, 5);</span><br><span class="line">List&lt;Integer&gt; list2 &#x3D; Arrays.asList(6, 7, 8, 9, 10);</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; allList &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">allList.add(list1);</span><br><span class="line">allList.add(list2);</span><br><span class="line">        </span><br><span class="line">allList.stream().flatMap(v -&gt; v.stream()).forEach(System.out::println);</span><br></pre></td></tr></table></figure><ul><li>filter </li></ul><p>过滤,对元素进行某种条件过滤，留下符合的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 留下偶数</span><br><span class="line">list.stream().filter(v -&gt; v % 2 &#x3D;&#x3D; 0).forEach(System.out::println);</span><br></pre></td></tr></table></figure><ul><li>distinct </li></ul><p>去重，不接收方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.stream().distinct().forEach(System.out::println);</span><br></pre></td></tr></table></figure><ul><li>sorted</li></ul><p>排序，接受一个Comparator，或者默认顺序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list.stream().sorted()</span><br><span class="line">list.stream().sorted((o1, o2) -&gt; -1)</span><br></pre></td></tr></table></figure><ul><li>peek</li></ul><p>peek 对每个元素执行操作并返回一个新的 Stream。类似foreach，foreach是终止操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list &#x3D; list.stream().peek(System.out::println).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><ul><li>limit</li></ul><p>返回 Stream 的前面 n 个元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.stream().limit(2).forEach(System.out::println);</span><br></pre></td></tr></table></figure><ul><li>skip</li></ul><p>扔掉前 n 个元素（它是由一个叫 subStream 的方法改名而来）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.stream().skip(2).forEach(System.out::println);</span><br></pre></td></tr></table></figure><ul><li>parallel</li></ul><p>转行成并行流，进行多线程操作，顺序会改变。可以使用forEachOrdered，固定顺序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list.stream().parallel().forEach(System.out::println);</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">1</span><br><span class="line">5</span><br><span class="line">2</span><br></pre></td></tr></table></figure><ul><li>sequential</li></ul><p>并行流转为串行流</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list.parallelStream().forEach(System.out::println);</span><br><span class="line">list.parallelStream().sequential().forEach(System.out::println);</span><br></pre></td></tr></table></figure><ul><li>unordered</li></ul><p><strong>消除了必须保持有序的流的约束</strong>,返回一个无序的等效的Stream，可能返回的是Stream本身，因为该Stream已经是无序的，或者该Stream的底层状态被修改为了无序.<br>一般用于并行的时候。例如TreeSet，或者流操作中指定顺序，会取消排序和指定顺序无效。</p><h3 id="终止操作-1"><a href="#终止操作-1" class="headerlink" title="终止操作"></a>终止操作</h3><ul><li>forEach</li></ul><p>forEach 不能修改自己包含的本地变量值，也不能用 break/return 之类的关键字提前结束循环。</p><ul><li><p>forEachOrdered</p></li><li><p>toArray</p></li><li><p>reduce</p></li></ul><p>这个方法的主要作用是把 Stream 元素组合起来。它提供一个起始值（种子），然后依照运算规则（BinaryOperator），和前面 Stream 的第一个、第二个、第 n 个元素组合。<br>从这个意义上说，字符串拼接、数值的 sum、min、max、average 都是特殊的 reduce。</p><p>注意：没有起始值，返回对象为Optional</p><ul><li>collect</li></ul><p>两个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;R&gt; R collect(Supplier&lt;R&gt; supplier,</span><br><span class="line">                  BiConsumer&lt;R, ? super T&gt; accumulator,</span><br><span class="line">                  BiConsumer&lt;R, R&gt; combiner);</span><br><span class="line">                  </span><br><span class="line">IntStream i &#x3D; IntStream.of(6,5,7,1, 2, 3, 3);</span><br><span class="line">  List&lt;Integer&gt; v &#x3D; i</span><br><span class="line">      .collect(ArrayList::new, ArrayList::add, ArrayList::addAll);</span><br><span class="line">  </span><br><span class="line">  System.out.println(v);</span><br><span class="line"></span><br><span class="line">&lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector);</span><br></pre></td></tr></table></figure><p>Collector在后面重点讲解</p><ul><li><p>min</p></li><li><p>max</p></li><li><p>count</p></li><li><p>anyMatch</p></li><li><p>allMatch</p></li><li><p>noneMatch</p></li><li><p>findFirst</p></li><li><p>findAny</p></li><li><p>iterator</p></li></ul><h3 id="Short-circuiting"><a href="#Short-circuiting" class="headerlink" title="Short-circuiting"></a>Short-circuiting</h3><ul><li><p>anyMatch</p></li><li><p>allMatch </p></li><li><p>noneMatch</p></li><li><p>findFirst </p></li><li><p>findAny </p></li><li><p>limit</p></li></ul><h2 id="Collectors"><a href="#Collectors" class="headerlink" title="Collectors"></a>Collectors</h2><p>要作用就是辅助进行各类有用的 reduction 操作，例如转变输出为 Collection，把 Stream 元素进行归组。</p><ul><li>类型归纳 </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Collectors.toList();</span><br><span class="line">Collectors.toMap();</span><br><span class="line">Collectors.toSet();</span><br><span class="line">Collectors.toCollection();</span><br><span class="line">Collectors.toConcurrentMap();</span><br></pre></td></tr></table></figure><ul><li>joining</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strList = Arrays.asList(<span class="string">"aa"</span>, <span class="string">"bb"</span>, <span class="string">"cc"</span>, <span class="string">"dd"</span>, <span class="string">"ee"</span>);</span><br><span class="line">String s = strList.stream().collect(Collectors.joining());</span><br><span class="line">System.out.println(s);</span><br><span class="line"><span class="comment">// 逗号连接</span></span><br><span class="line">s = strList.stream().collect(Collectors.joining(<span class="string">","</span>));</span><br><span class="line">System.out.println(s);</span><br><span class="line"><span class="comment">// 逗号连接</span></span><br><span class="line">s = strList.stream().collect(Collectors.joining(<span class="string">","</span>, <span class="string">"["</span>, <span class="string">"]"</span>));</span><br><span class="line">System.out.println(s);</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">- collectingAndThen</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">s = strList.stream().collect(Collectors.collectingAndThen(Collectors.joining(<span class="string">","</span>), String::toUpperCase));</span><br></pre></td></tr></table></figure><ul><li>groupingBy groupingByConcurrent</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, List&lt;String&gt;&gt; map = strList.stream().collect(Collectors.groupingBy(String::length));</span><br><span class="line">map.keySet().forEach(v -&gt; map.get(v).forEach(System.out::println));</span><br><span class="line">    </span><br><span class="line">Map&lt;Integer, Set&lt;String&gt;&gt; map1 = strList.stream().collect(Collectors.groupingBy(String::length, Collectors.toSet();</span><br></pre></td></tr></table></figure><ul><li>partitioningBy</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Boolean, List&lt;Integer&gt;&gt; mapBoolean = list.stream().collect(Collectors.partitioningBy(v -&gt; v % <span class="number">2</span> == <span class="number">0</span>));</span><br><span class="line">mapBoolean.keySet().forEach(v -&gt; mapBoolean.get(v).forEach(System.out::println));</span><br></pre></td></tr></table></figure><ul><li>summingInt/Double/Long summarizingInt/Double/Long</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://github.com/MarchNineteen/spring-example/blob/master/spring-example-test/src/main/java/com/wyb/test/java/java8/StreamApiA
      
    
    </summary>
    
    
      <category term="JavaSE" scheme="https://marchnineteen.github.io/categories/JavaSE/"/>
    
    
  </entry>
  
  <entry>
    <title>秒杀场景</title>
    <link href="https://marchnineteen.github.io/2019/12/20/active/miaosha/"/>
    <id>https://marchnineteen.github.io/2019/12/20/active/miaosha/</id>
    <published>2019-12-20T00:00:00.000Z</published>
    <updated>2023-05-08T01:44:57.915Z</updated>
    
    <content type="html"><![CDATA[<h1 id="秒杀场景可能遇到的问题（用户流程角度）"><a href="#秒杀场景可能遇到的问题（用户流程角度）" class="headerlink" title="秒杀场景可能遇到的问题（用户流程角度）"></a>秒杀场景可能遇到的问题（用户流程角度）</h1><ul><li><p>问题一.即将到秒杀时间，同时请求网页过多，打开网页速度慢</p></li><li><p>问题二.进入页面后，未到秒杀时间，用户一直点击购买按钮，一直发起请求</p></li><li><p>问题三.用户拿到接口地址，恶意请求（用脚本）</p></li><li><p>问题四.超卖现象</p></li><li><p>问题五.数据库请求过多，数据库奔溃</p></li></ul><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h2><ul><li><p>针对于动态页面（jsp，ftl）可以把整个页面存储在redis中，避免页面渲染。</p></li><li><p>前后端分离项目，页面单独部署，使用cdn加速，资源静态</p></li><li><p>打开网页速度慢，除了页面的原因外，后台请求返回慢也有很大的关系，简单说就是后台高并发能力不足，一遇到此类场景，cpu，内存飚升，程序响应慢。单台tomcat并发量不足，可以集群部署然后使用nginx做负载均衡，恶意请求也可以在此拦截。</p></li><li><p>后台对请求限流</p></li></ul><h2 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h2><ul><li>页面按钮控制，未到时间按钮不能点击，需要页面定时请求后台获取最新的北京时间，不能以页面本地时间为准</li><li>在用户点击过后，再把按钮设置无效，防止无效重复点击</li></ul><h2 id="问题三"><a href="#问题三" class="headerlink" title="问题三"></a>问题三</h2><p>接口地址动态化，通过MD5之类的加密算法加密随机的字符串去做url，然后通过前端代码获取url后台校验才能通过</p><h2 id="问题四"><a href="#问题四" class="headerlink" title="问题四"></a>问题四</h2><h3 id="处理流程："><a href="#处理流程：" class="headerlink" title="处理流程："></a>处理流程：</h3><p>典型的读多先少场景，使用mysql等nosql，把库存存入redis中，进行库存预热。通过三级缓冲保证数据库压力，本地内存标记，库存修改在redis中进行预存，接着通过mq进行异步下单，处理数据库。若下单成功，页面轮询接口返回订单处理状态。</p><h3 id="解决超卖方案"><a href="#解决超卖方案" class="headerlink" title="解决超卖方案"></a>解决超卖方案</h3><ul><li>防止数据库内存为0，在修改时进行库存判断，大于0才更新。</li><li>用户id与商品id建立唯一所以，防止同一用户重复购买同一件商品。</li><li>实现乐观锁，商品信息中年增加version字段。每次更新时version+1，更新时候带上版本号，当提交前版本号等于更新前版本号，说明此时没有被其他线程影响到，正常更新，如果冲突了则不会进行提交更新。当库存是足够的情况下发生乐观锁冲突就进行一定次数的重试。</li></ul><p>一整套解决方案</p><p><img src="https://user-gold-cdn.xitu.io/2019/11/16/16e72d24415cb009?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="秒杀"></p><h2 id="产生更多的问题"><a href="#产生更多的问题" class="headerlink" title="产生更多的问题"></a>产生更多的问题</h2><ul><li>redis集群，数据同步,分布式锁等</li><li>mq高可用</li><li>限流&amp;降级&amp;熔断&amp;隔离</li><li>分布式服务，事务处理。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;秒杀场景可能遇到的问题（用户流程角度）&quot;&gt;&lt;a href=&quot;#秒杀场景可能遇到的问题（用户流程角度）&quot; class=&quot;headerlink&quot; title=&quot;秒杀场景可能遇到的问题（用户流程角度）&quot;&gt;&lt;/a&gt;秒杀场景可能遇到的问题（用户流程角度）&lt;/h1&gt;&lt;ul&gt;

      
    
    </summary>
    
    
      <category term="active" scheme="https://marchnineteen.github.io/categories/active/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring 加载XML文件的六种方式</title>
    <link href="https://marchnineteen.github.io/2019/12/06/spring/springLoadXml/"/>
    <id>https://marchnineteen.github.io/2019/12/06/spring/springLoadXml/</id>
    <published>2019-12-06T00:00:00.000Z</published>
    <updated>2023-05-08T01:44:57.939Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-XmlBeanFactory-引用资源"><a href="#一-XmlBeanFactory-引用资源" class="headerlink" title="一: XmlBeanFactory 引用资源"></a>一: XmlBeanFactory 引用资源</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Resource resource &#x3D; new ClassPathResource(&quot;appcontext.xml&quot;);</span><br><span class="line">BeanFactory factory &#x3D; new XmlBeanFactory(resource);</span><br><span class="line">BaseEntity entity &#x3D; (BaseEntity) factory.getBean(&quot;baseEntity1&quot;);</span><br><span class="line">System.out.println(&quot;XmlBeanFactory 获取 bean ：&quot; + entity.getId());</span><br></pre></td></tr></table></figure><h1 id="二-ClassPathXmlApplicationContext-编译路径"><a href="#二-ClassPathXmlApplicationContext-编译路径" class="headerlink" title="二: ClassPathXmlApplicationContext  编译路径"></a>二: ClassPathXmlApplicationContext  编译路径</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 单个文件</span><br><span class="line">ApplicationContext applicationContext &#x3D; new ClassPathXmlApplicationContext(&quot;classpath:appcontext.xml&quot;);</span><br><span class="line">&#x2F;&#x2F; 多个文件</span><br><span class="line">ApplicationContext multiApplicationContext &#x3D; new ClassPathXmlApplicationContext(&quot;classpath:appcontext.xml&quot;, &quot;classpath:appcontext2.xml&quot;);</span><br><span class="line">BaseEntity entity &#x3D; (BaseEntity) applicationContext.getBean(&quot;baseEntity&quot;);</span><br><span class="line"></span><br><span class="line">BaseEntity entity2 &#x3D; (BaseEntity) multiApplicationContext.getBean(&quot;baseEntity2&quot;);</span><br><span class="line">System.out.println(&quot;ClassPathXmlApplicationContext 获取 bean ：&quot; + entity.getId());</span><br><span class="line">System.out.println(&quot;ClassPathXmlApplicationContext 获取 bean2 ：&quot; + entity2.getId());</span><br></pre></td></tr></table></figure><h1 id="三-用文件系统的路径"><a href="#三-用文件系统的路径" class="headerlink" title="三: 用文件系统的路径"></a>三: 用文件系统的路径</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; classPath</span><br><span class="line">ApplicationContext fileSystemXmlApplicationContext &#x3D; new FileSystemXmlApplicationContext(&quot;classpath:appcontext.xml&quot;);</span><br><span class="line">&#x2F;&#x2F; 文件系统</span><br><span class="line">ApplicationContext fileSystemXmlApplicationContext2 &#x3D; new FileSystemXmlApplicationContext(&quot;spring-example-test&#x2F;src&#x2F;main&#x2F;resources&#x2F;appcontext.xml&quot;);</span><br><span class="line">ApplicationContext fileSystemXmlApplicationContext3 &#x3D; new FileSystemXmlApplicationContext(&quot;file:E:\\marcher\\spring-example\\spring-example-test\\src\\main\\resources&#x2F;appcontext.xml&quot;);</span><br><span class="line">ApplicationContext fileSystemXmlApplicationContext4 &#x3D; new FileSystemXmlApplicationContext(&quot;E:\\marcher\\spring-example\\spring-example-test\\src\\main\\resources&#x2F;appcontext.xml&quot;);</span><br><span class="line"></span><br><span class="line">BaseEntity entity &#x3D; (BaseEntity) fileSystemXmlApplicationContext.getBean(&quot;baseEntity&quot;);</span><br><span class="line">System.out.println(&quot;ClassPathXmlApplicationContext 获取 bean ：&quot; + entity.getId());</span><br><span class="line"></span><br><span class="line">BaseEntity entity2 &#x3D; (BaseEntity) fileSystemXmlApplicationContext2.getBean(&quot;baseEntity&quot;);</span><br><span class="line">System.out.println(&quot;ClassPathXmlApplicationContext 获取 bean ：&quot; + entity2.getId());</span><br><span class="line"></span><br><span class="line">BaseEntity entity3 &#x3D; (BaseEntity) fileSystemXmlApplicationContext3.getBean(&quot;baseEntity&quot;);</span><br><span class="line">System.out.println(&quot;ClassPathXmlApplicationContext 获取 bean ：&quot; + entity2.getId());</span><br><span class="line"></span><br><span class="line">BaseEntity entity4 &#x3D; (BaseEntity) fileSystemXmlApplicationContext4.getBean(&quot;baseEntity&quot;);</span><br><span class="line">System.out.println(&quot;ClassPathXmlApplicationContext 获取 bean ：&quot; + entity2.getId());</span><br></pre></td></tr></table></figure><h1 id="四-XmlWebApplicationContext是专为Web工程定制的。"><a href="#四-XmlWebApplicationContext是专为Web工程定制的。" class="headerlink" title="四: XmlWebApplicationContext是专为Web工程定制的。"></a>四: XmlWebApplicationContext是专为Web工程定制的。</h1><p>ServletContext servletContext = request.getSession().getServletContext();<br>ApplicationContext ctx = WebApplicationContextUtils.getWebApplicationContext(servletContext ); </p><h1 id="五-使用BeanFactory"><a href="#五-使用BeanFactory" class="headerlink" title="五: 使用BeanFactory"></a>五: 使用BeanFactory</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BeanDefinitionRegistry reg &#x3D; new DefaultListableBeanFactory();</span><br><span class="line">XmlBeanDefinitionReader reader &#x3D; new XmlBeanDefinitionReader(reg);</span><br><span class="line">reader.loadBeanDefinitions(new ClassPathResource(&quot;appcontext.xml&quot;));</span><br><span class="line">reader.loadBeanDefinitions(new ClassPathResource(&quot;appcontext2.xml&quot;));</span><br><span class="line">BeanFactory bf &#x3D; (BeanFactory) reg;</span><br><span class="line">BaseEntity entity &#x3D; (BaseEntity) bf.getBean(&quot;baseEntity&quot;);</span><br><span class="line">BaseEntity entity2 &#x3D; (BaseEntity) bf.getBean(&quot;baseEntity2&quot;);</span><br><span class="line">System.out.println(&quot;ClassPathXmlApplicationContext 获取 bean ：&quot; + entity.getId());</span><br><span class="line">System.out.println(&quot;ClassPathXmlApplicationContext 获取 bean ：&quot; + entity2.getId());</span><br></pre></td></tr></table></figure><h1 id="六：Web-应用启动时加载多个配置文件"><a href="#六：Web-应用启动时加载多个配置文件" class="headerlink" title="六：Web 应用启动时加载多个配置文件"></a>六：Web 应用启动时加载多个配置文件</h1><p>通过ContextLoaderListener 也可加载多个配置文件，在web.xml文件中利用<br><context-pararn>元素来指定多个配置文件位置，其配置如下: </context-pararn></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;context-param&gt;  </span><br><span class="line">    &lt;!-- Context Configuration locations for Spring XML files --&gt;  </span><br><span class="line">       &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;  </span><br><span class="line">       &lt;param-value&gt;  </span><br><span class="line">       .&#x2F;WEB-INF&#x2F;**&#x2F;Appserver-resources.xml,  </span><br><span class="line">       classpath:config&#x2F;aer&#x2F;aerContext.xml,  </span><br><span class="line">       classpath:org&#x2F;codehaus&#x2F;xfire&#x2F;spring&#x2F;xfire.xml,  </span><br><span class="line">       .&#x2F;WEB-INF&#x2F;**&#x2F;*.spring.xml  </span><br><span class="line">       &lt;&#x2F;param-value&gt;  </span><br><span class="line">   &lt;&#x2F;context-param&gt;</span><br></pre></td></tr></table></figure><p>这个方法加载配置文件的前提是已经知道配置文件在哪里，虽然可以利用“*”通配符，但灵活度有限。 </p><h1 id="获取配套代码"><a href="#获取配套代码" class="headerlink" title="获取配套代码"></a><a href="https://github.com/MarchNineteen/spring-example/tree/master/spring-example-test/src/main/java/com/wyb/test/spring/loadXml" target="_blank" rel="noopener">获取配套代码</a></h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-XmlBeanFactory-引用资源&quot;&gt;&lt;a href=&quot;#一-XmlBeanFactory-引用资源&quot; class=&quot;headerlink&quot; title=&quot;一: XmlBeanFactory 引用资源&quot;&gt;&lt;/a&gt;一: XmlBeanFactory 引用资源
      
    
    </summary>
    
    
      <category term="spring" scheme="https://marchnineteen.github.io/categories/spring/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring Bean 生命周期</title>
    <link href="https://marchnineteen.github.io/2019/12/06/spring/beanLifeCycle/"/>
    <id>https://marchnineteen.github.io/2019/12/06/spring/beanLifeCycle/</id>
    <published>2019-12-06T00:00:00.000Z</published>
    <updated>2023-05-08T01:44:57.939Z</updated>
    
    <content type="html"><![CDATA[<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p><img src="/uploads/spring/springBeanLifeCycle.png" alt="生命周期"></p><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p><img src="/uploads/spring/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8Fspringbean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg" alt="单例模式生命周期"></p><h1 id="多例模式"><a href="#多例模式" class="headerlink" title="多例模式"></a>多例模式</h1><p>需求主动调用才会创建对象，原因见下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LifeCycle lifeCycle &#x3D; (LifeCycle) applicationContext.getBean(&quot;lifeCycle&quot;);</span><br></pre></td></tr></table></figure><p><img src="/uploads/spring/%E5%A4%9A%E4%BE%8B%E6%A8%A1%E5%BC%8Fspringbean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg" alt="多例模式生命周期"></p><h1 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h1><h2 id="单例模式-1"><a href="#单例模式-1" class="headerlink" title="单例模式"></a>单例模式</h2><p>bean在单例模式下，spring容器启动时解析xml文件发现该bean标签后，直接创建该bean对象存入内部map中保存，<br>此后无论调用多少次getBean()获取该bean都是从map中获取该对象返回，一直是一个对象。<br>此对象一直被spring容器持有，直到容器推出时，随着容器的退出对象被销毁。</p><h2 id="多例模式-1"><a href="#多例模式-1" class="headerlink" title="多例模式"></a>多例模式</h2><p>bean在多例模式下，spring容器启动时解析xml发下该bean标签后，只是将该bean进行管理，并不会创建对象，<br>此后每层使用getBean()获取该bean时，spring都会重新创建该对象返回，每层都是一个新的对象。<br>这个对象spring容器并不会持有，什么时候销毁却决于该对象的用户自己什么时候销毁该对象。</p><h1 id="相应测试源码"><a href="#相应测试源码" class="headerlink" title="相应测试源码"></a><a href="https://github.com/MarchNineteen/spring-example/blob/master/spring-example-test/src/main/java/com/wyb/test/spring/bean/LifeCycle.java" target="_blank" rel="noopener">相应测试源码</a></h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;生命周期&quot;&gt;&lt;a href=&quot;#生命周期&quot; class=&quot;headerlink&quot; title=&quot;生命周期&quot;&gt;&lt;/a&gt;生命周期&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/uploads/spring/springBeanLifeCycle.png&quot; alt=&quot;生命周期&quot;&gt;
      
    
    </summary>
    
    
      <category term="spring" scheme="https://marchnineteen.github.io/categories/spring/"/>
    
    
  </entry>
  
</feed>
