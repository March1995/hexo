<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>app嵌入H5如何同步登录状态</title>
    <url>/2021/10/11/active/appH5Token/</url>
    <content><![CDATA[<p>目前使用的方案：<br>1.h5通过js和app交互调用app的token<br>2.拿到token后使用ajax做异步登录并刷新页面<br>目前的缺点：<br>1.会多次刷新页面<br>2.通过js调用时H5需要做部分改动</p>
<p>优化的方向：<br>A.APP登陆状态的变化是请求页面，登录后使用webview调用对应域名下的接口实现H5的登录B.每次请求H5url增加get登陆的信息，例如访问 index.php变成index.php？a=xxx通过附加信息同步登录状态<br>优化的方案不知道那个更好一点</p>
]]></content>
      <categories>
        <category>active</category>
      </categories>
  </entry>
  <entry>
    <title>秒杀场景</title>
    <url>/2019/12/20/active/miaosha/</url>
    <content><![CDATA[<h1 id="秒杀场景可能遇到的问题（用户流程角度）"><a href="#秒杀场景可能遇到的问题（用户流程角度）" class="headerlink" title="秒杀场景可能遇到的问题（用户流程角度）"></a>秒杀场景可能遇到的问题（用户流程角度）</h1><ul>
<li><p>问题一.即将到秒杀时间，同时请求网页过多，打开网页速度慢</p>
</li>
<li><p>问题二.进入页面后，未到秒杀时间，用户一直点击购买按钮，一直发起请求</p>
</li>
<li><p>问题三.用户拿到接口地址，恶意请求（用脚本）</p>
</li>
<li><p>问题四.超卖现象</p>
</li>
<li><p>问题五.数据库请求过多，数据库奔溃</p>
</li>
</ul>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h2><ul>
<li><p>针对于动态页面（jsp，ftl）可以把整个页面存储在redis中，避免页面渲染。</p>
</li>
<li><p>前后端分离项目，页面单独部署，使用cdn加速，资源静态</p>
</li>
<li><p>打开网页速度慢，除了页面的原因外，后台请求返回慢也有很大的关系，简单说就是后台高并发能力不足，一遇到此类场景，cpu，内存飚升，程序响应慢。单台tomcat并发量不足，可以集群部署然后使用nginx做负载均衡，恶意请求也可以在此拦截。</p>
</li>
<li><p>后台对请求限流</p>
</li>
</ul>
<h2 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h2><ul>
<li>页面按钮控制，未到时间按钮不能点击，需要页面定时请求后台获取最新的北京时间，不能以页面本地时间为准</li>
<li>在用户点击过后，再把按钮设置无效，防止无效重复点击</li>
</ul>
<h2 id="问题三"><a href="#问题三" class="headerlink" title="问题三"></a>问题三</h2><p>接口地址动态化，通过MD5之类的加密算法加密随机的字符串去做url，然后通过前端代码获取url后台校验才能通过</p>
<h2 id="问题四"><a href="#问题四" class="headerlink" title="问题四"></a>问题四</h2><h3 id="处理流程："><a href="#处理流程：" class="headerlink" title="处理流程："></a>处理流程：</h3><p>典型的读多先少场景，使用mysql等nosql，把库存存入redis中，进行库存预热。通过三级缓冲保证数据库压力，本地内存标记，库存修改在redis中进行预存，接着通过mq进行异步下单，处理数据库。若下单成功，页面轮询接口返回订单处理状态。</p>
<h3 id="解决超卖方案"><a href="#解决超卖方案" class="headerlink" title="解决超卖方案"></a>解决超卖方案</h3><ul>
<li>防止数据库内存为0，在修改时进行库存判断，大于0才更新。</li>
<li>用户id与商品id建立唯一所以，防止同一用户重复购买同一件商品。</li>
<li>实现乐观锁，商品信息中年增加version字段。每次更新时version+1，更新时候带上版本号，当提交前版本号等于更新前版本号，说明此时没有被其他线程影响到，正常更新，如果冲突了则不会进行提交更新。当库存是足够的情况下发生乐观锁冲突就进行一定次数的重试。</li>
</ul>
<p>一整套解决方案</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/11/16/16e72d24415cb009?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="秒杀"></p>
<h2 id="产生更多的问题"><a href="#产生更多的问题" class="headerlink" title="产生更多的问题"></a>产生更多的问题</h2><ul>
<li>redis集群，数据同步,分布式锁等</li>
<li>mq高可用</li>
<li>限流&amp;降级&amp;熔断&amp;隔离</li>
<li>分布式服务，事务处理。</li>
</ul>
]]></content>
      <categories>
        <category>active</category>
      </categories>
  </entry>
  <entry>
    <title>支付系统可能遇到的问题</title>
    <url>/2021/10/11/active/pay/</url>
    <content><![CDATA[<p>(资源)</p>
<p>资源不可用</p>
<p>资源响应超时</p>
<p>(外部服务)</p>
<p>通信中断</p>
<p>服务不可用</p>
<p>外部服务器响应超时</p>
<p>外部服务违背功能契约</p>
<p>应对方式(参考)：原则：避免发生，降低概率，控制影响，快速恢复。</p>
<table>
<thead>
<tr>
<th>故障条件</th>
<th>应对方式</th>
</tr>
</thead>
<tbody><tr>
<td>超量请求</td>
<td>配额控制，如订单号提前生成，控制额度</td>
</tr>
<tr>
<td>重复请求</td>
<td>幂等控制</td>
</tr>
<tr>
<td>并发请求</td>
<td>并发控制netty、mina等</td>
</tr>
<tr>
<td>请求积压</td>
<td>请求丢弃</td>
</tr>
<tr>
<td>服务/资源响应超时</td>
<td>时间控制</td>
</tr>
<tr>
<td>可恢复通信故障</td>
<td>合理重试</td>
</tr>
<tr>
<td>处理中断</td>
<td>事务/补偿机制</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>active</category>
      </categories>
  </entry>
  <entry>
    <title>缓存概要</title>
    <url>/2019/10/25/cache/index/</url>
    <content><![CDATA[<h1 id="一、缓存特征"><a href="#一、缓存特征" class="headerlink" title="一、缓存特征"></a>一、缓存特征</h1><h2 id="命中率"><a href="#命中率" class="headerlink" title="命中率"></a>命中率</h2><p>当某个请求能够通过访问缓存而得到响应时，称为缓存命中。</p>
<p>缓存命中率越高，缓存的利用率也就越高。</p>
<h2 id="最大空间"><a href="#最大空间" class="headerlink" title="最大空间"></a>最大空间</h2><p>缓存通常位于内存中，内存的空间通常比磁盘空间小的多，因此缓存的最大空间不可能非常大。</p>
<p>当缓存存放的数据量超过最大空间时，就需要淘汰部分数据来存放新到达的数据。</p>
<h2 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h2><ul>
<li><p>FIFO（First In First Out）：先进先出策略，在实时性的场景下，需要经常访问最新的数据，那么就可以使用 FIFO，使得最先进入的数据（最晚的数据）被淘汰。</p>
</li>
<li><p>LRU（Least Recently Used）：最近最久未使用策略，优先淘汰最久未使用的数据，也就是上次被访问时间距离现在最久的数据。该策略可以保证内存中的数据都是热点数据，也就是经常被访问的数据，从而保证缓存命中率。</p>
</li>
<li><p>LFU（Least Frequently Used）：最不经常使用策略，优先淘汰一段时间内使用次数最少的数据。</p>
</li>
</ul>
<h1 id="二、LRU"><a href="#二、LRU" class="headerlink" title="二、LRU"></a>二、LRU</h1><p>以下是基于 双向链表 + HashMap 的 LRU 算法实现，对算法的解释如下：</p>
<p>访问某个节点时，将其从原来的位置删除，并重新插入到链表头部。这样就能保证链表尾部存储的就是最近最久未使用的节点，当节点数量大于缓存最大空间时就淘汰链表尾部的节点。<br>为了使删除操作时间复杂度为 O(1)，就不能采用遍历的方式找到某个节点。HashMap 存储着 Key 到节点的映射，通过 Key 就能以 O(1) 的时间得到节点，然后再以 O(1) 的时间将其从双向队列中删除。</p>
<p><a href="https://github.com/MarchNineteen/spring-example/blob/master/spring-example-test/src/main/java/com/wyb/test/algorithms/cache/LRU.java" target="_blank" rel="noopener">LRU实现</a></p>
<h1 id="三、CDN"><a href="#三、CDN" class="headerlink" title="三、CDN"></a>三、CDN</h1><p>内容分发网络（Content distribution network，CDN）是一种互连的网络系统，它利用更靠近用户的服务器从而更快更可靠地将 HTML、CSS、JavaScript、音乐、图片、视频等静态资源分发给用户。</p>
<p>CDN 主要有以下优点：</p>
<ul>
<li>更快地将数据分发给用户；</li>
<li>通过部署多台服务器，从而提高系统整体的带宽性能；</li>
<li>多台服务器可以看成是一种冗余机制，从而具有高可用性。</li>
</ul>
<h1 id="四、缓存问题"><a href="#四、缓存问题" class="headerlink" title="四、缓存问题"></a>四、缓存问题</h1><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>指对某一个一定不存在的数据进行请求，该请求会将穿透缓存到达数据库。</p>
<p>解决方案：</p>
<ul>
<li>对这些不存在的数据缓存一个空数据</li>
<li>对这类请求进行过滤</li>
</ul>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>指的是由于数据没有被加载到缓存中，或者缓存数据在同一时间大面积失效（过期），又或者缓存服务器宕机，导致大量的请求都到达数据库。</p>
<p>在有缓存的系统中，系统非常依赖于缓存，缓存分担了很大一部分的数据请求。当发生缓存雪崩时，数据库无法处理这么大的请求，导致数据库崩溃。</p>
<p>解决方案：</p>
<ul>
<li>为了防止缓存在同一时间大面积过期导致的缓存雪崩，可以通过观察用户行为，合理设置缓存过期时间来实现；</li>
<li>为了防止缓存服务器宕机出现的缓存雪崩，可以使用分布式缓存，分布式缓存中每一个节点只缓存部分的数据，当某个节点宕机时可以保证其它节点的缓存仍然可用。</li>
<li>也可以进行缓存预热，避免在系统刚启动不久由于还未将大量数据进行缓存而导致缓存雪崩。</li>
</ul>
<h2 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h2><p>缓存一致性要求数据更新的同时缓存数据也能够实时更新。</p>
<p>解决方案：</p>
<ul>
<li>在数据更新的同时立即去更新缓存；</li>
<li>在读缓存之前先判断缓存是否是最新的，如果不是最新的先进行更新。</li>
</ul>
<h2 id="缓存-“无底洞”-现象"><a href="#缓存-“无底洞”-现象" class="headerlink" title="缓存 “无底洞” 现象"></a>缓存 “无底洞” 现象</h2><p>指的是为了满足业务要求添加了大量缓存节点，但是性能不但没有好转反而下降了的现象。</p>
<p>产生原因：缓存系统通常采用 hash 函数将 key 映射到对应的缓存节点，随着缓存节点数目的增加，键值分布到更多的节点上，导致客户端一次批量操作会涉及多次网络操作，这意味着批量操作的耗时会随着节点数目的增加而不断增大。此外，网络连接数变多，对节点的性能也有一定影响。</p>
<p>解决方案：</p>
<ul>
<li>优化批量数据操作命令；</li>
<li>减少网络通信次数；</li>
<li>降低接入成本，使用长连接 / 连接池，NIO 等。</li>
</ul>
<h1 id="五、数据分布"><a href="#五、数据分布" class="headerlink" title="五、数据分布"></a>五、数据分布</h1><h2 id="哈希分布"><a href="#哈希分布" class="headerlink" title="哈希分布"></a>哈希分布</h2><p>哈希分布就是将数据计算哈希值之后，按照哈希值分配到不同的节点上。例如有 N 个节点，数据的主键为 key，则将该数据分配的节点序号为：hash(key)%N。</p>
<p>传统的哈希分布算法存在一个问题：当节点数量变化时，也就是 N 值变化，那么几乎所有的数据都需要重新分布，将导致大量的数据迁移。</p>
<h2 id="顺序分布"><a href="#顺序分布" class="headerlink" title="顺序分布"></a>顺序分布</h2><p>将数据划分为多个连续的部分，按数据的 ID 或者时间分布到不同节点上。例如 User 表的 ID 范围为 1 ~ 7000，使用顺序分布可以将其划分成多个子表，对应的主键范围为 1 ~ 1000，1001 ~ 2000，…，6001 ~ 7000。</p>
<p>顺序分布相比于哈希分布的主要优点如下：</p>
<ul>
<li>能保持数据原有的顺序；</li>
<li>并且能够准确控制每台服务器存储的数据量，从而使得存储空间的利用率最大。</li>
</ul>
<h1 id="六、一致性哈希"><a href="#六、一致性哈希" class="headerlink" title="六、一致性哈希"></a>六、一致性哈希</h1><p>Distributed Hash Table（DHT） 是一种哈希分布方式，其目的是为了克服传统哈希分布在服务器节点数量变化时大量数据迁移的问题。</p>
<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>将哈希空间 [0, 2n-1] 看成一个哈希环，每个服务器节点都配置到哈希环上。每个数据对象通过哈希取模得到哈希值之后，存放到哈希环中顺时针方向第一个大于等于该哈希值的节点上。</p>
<p><img src="/uploads/cache/%E4%B8%80%E8%87%B4%E6%80%A7hash%E5%8E%9F%E7%90%86%E5%9B%BE.jpg" alt="一致性hash原理图"></p>
<p>一致性哈希在增加或者删除节点时只会影响到哈希环中相邻的节点，例如下图中新增节点 X，只需要将它前一个节点 C 上的数据重新进行分布即可，对于节点 A、B、D 都没有影响。</p>
<p><img src="/uploads/cache/%E4%B8%80%E8%87%B4%E6%80%A7hash%E5%A2%9E%E5%8A%A0%E8%8A%82%E7%82%B9%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="一致性hash增加节点示意图"></p>
<h2 id="虚拟节点"><a href="#虚拟节点" class="headerlink" title="虚拟节点"></a>虚拟节点</h2><p>上面描述的一致性哈希存在数据分布不均匀的问题，节点存储的数据量有可能会存在很大的不同。</p>
<p>数据不均匀主要是因为节点在哈希环上分布的不均匀，这种情况在节点数量很少的情况下尤其明显。</p>
<p>解决方式是通过增加虚拟节点，然后将虚拟节点映射到真实节点上。虚拟节点的数量比真实节点来得多，那么虚拟节点在哈希环上分布的均匀性就会比原来的真实节点好，从而使得数据分布也更加均匀。</p>
]]></content>
      <categories>
        <category>cache</category>
      </categories>
  </entry>
  <entry>
    <title>redis</title>
    <url>/2019/10/25/cache/redis/</url>
    <content><![CDATA[<h1 id="一、概述（什么是redis）"><a href="#一、概述（什么是redis）" class="headerlink" title="一、概述（什么是redis）"></a>一、概述（什么是redis）</h1><p>redis是开源免费的key-value内存数据库。</p>
<p>redis可以存储5种数据类型。键只支持string，值支持string，list，map，set，zset五种。</p>
<p>redis支持数据持久化，使用复制来扩展读性能，使用分片来扩展写性能。</p>
<h1 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a>二、数据类型</h1><table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">可以存储的值</th>
<th align="center">操作</th>
</tr>
</thead>
<tbody><tr>
<td align="center">STRING</td>
<td align="center">字符串、整数或者浮点数</td>
<td align="center">对整个字符串或者字符串的其中一部分执行操作<br> 对整数和浮点数执行自增或者自减操作</td>
</tr>
<tr>
<td align="center">LIST</td>
<td align="center">列表</td>
<td align="center">从两端压入或者弹出元素 <br> 对单个或者多个元素进行修剪，<br> 只保留一个范围内的元素</td>
</tr>
<tr>
<td align="center">SET</td>
<td align="center">无序集合</td>
<td align="center">添加、获取、移除单个元素<br> 检查一个元素是否存在于集合中<br> 计算交集、并集、差集<br> 从集合里面随机获取元素</td>
</tr>
<tr>
<td align="center">HASH</td>
<td align="center">包含键值对的无序散列表</td>
<td align="center">添加、获取、移除单个键值对<br> 获取所有键值对<br> 检查某个键是否存在</td>
</tr>
<tr>
<td align="center">ZSET</td>
<td align="center">有序集合</td>
<td align="center">添加、获取、删除元素<br> 根据分值范围或者成员来获取元素<br> 计算一个键的排名</td>
</tr>
</tbody></table>
<h1 id="三、数据结构"><a href="#三、数据结构" class="headerlink" title="三、数据结构"></a>三、数据结构</h1><h1 id="四、redis应用场景"><a href="#四、redis应用场景" class="headerlink" title="四、redis应用场景"></a>四、redis应用场景</h1><h2 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h2><p>利用string类型可以存储整数和浮点数，进行自增自减操作。</p>
<h2 id="缓存（用的最多的场景）"><a href="#缓存（用的最多的场景）" class="headerlink" title="缓存（用的最多的场景）"></a>缓存（用的最多的场景）</h2><p>将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。</p>
<p>将不经常改变的数据存入缓存，访问频繁访问数据库。</p>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息</p>
<p>不过最好使用 Kafka、RabbitMQ 等消息中间件。</p>
<p><a href="https://github.com/MarchNineteen/spring-example/blob/master/spring-example-cache/src/test/java/com/wyb/cache/RedisMqTests.java" target="_blank" rel="noopener">redis 实现 点对点  发布/订阅 消息队列 </a></p>
<h2 id="会话缓存"><a href="#会话缓存" class="headerlink" title="会话缓存"></a>会话缓存</h2><p>可以使用 Redis 来统一存储多台应用服务器的会话信息。</p>
<p>当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。</p>
<h2 id="分布式锁实现"><a href="#分布式锁实现" class="headerlink" title="分布式锁实现"></a>分布式锁实现</h2><p>在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。</p>
<p>可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。</p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>Set 可以实现交集、并集等操作，从而实现共同好友等功能。</p>
<p>ZSet 可以实现有序性操作，从而实现排行榜等功能。</p>
<h1 id="五、数据淘汰策略"><a href="#五、数据淘汰策略" class="headerlink" title="五、数据淘汰策略"></a>五、数据淘汰策略</h1><p>可以设置内存最大使用量，当内存使用量超出时，会施行数据淘汰策略。</p>
<p>Redis 具体有 6 种淘汰策略：</p>
<table>
<thead>
<tr>
<th align="center">策略</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">volatile-lru</td>
<td align="center">从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</td>
</tr>
<tr>
<td align="center">volatile-ttl</td>
<td align="center">从已设置过期时间的数据集中挑选将要过期的数据淘汰</td>
</tr>
<tr>
<td align="center">volatile-random</td>
<td align="center">从已设置过期时间的数据集中任意选择数据淘汰</td>
</tr>
<tr>
<td align="center">allkeys-lru</td>
<td align="center">从所有数据集中挑选最近最少使用的数据淘汰</td>
</tr>
<tr>
<td align="center">allkeys-random</td>
<td align="center">从所有数据集中任意选择数据进行淘汰</td>
</tr>
<tr>
<td align="center">noeviction</td>
<td align="center">禁止驱逐数据</td>
</tr>
</tbody></table>
<p>作为内存数据库，出于对性能和内存消耗的考虑，Redis 的淘汰算法实际实现上并非针对所有 key，而是抽样一小部分并且从中选出被淘汰的 key。</p>
<p>使用 Redis 缓存数据时，为了提高缓存命中率，需要保证缓存数据都是热点数据。可以将内存最大使用量设置为热点数据占用的内存量，然后启用 allkeys-lru 淘汰策略，将最近最少使用的数据淘汰。</p>
<p>Redis 4.0 引入了 volatile-lfu 和 allkeys-lfu 淘汰策略，LFU 策略通过统计访问频率，将访问频率最少的键值对淘汰。</p>
<h1 id="六、持久化"><a href="#六、持久化" class="headerlink" title="六、持久化"></a>六、持久化</h1><h2 id="RDB-持久化"><a href="#RDB-持久化" class="headerlink" title="RDB 持久化"></a>RDB 持久化</h2><p>将某个时间点的所有数据都存放到硬盘上。</p>
<p>可以将快照复制到其它服务器从而创建具有相同数据的服务器副本。</p>
<p>如果系统发生故障，将会丢失最后一次创建快照之后的数据。</p>
<p>如果数据量很大，保存快照的时间会很长。</p>
<h2 id="AOF-持久化"><a href="#AOF-持久化" class="headerlink" title="AOF 持久化"></a>AOF 持久化</h2><p>将写命令添加到 AOF 文件（Append Only File）的末尾。</p>
<p>使用 AOF 持久化需要设置同步选项，从而确保写命令同步到磁盘文件上的时机。这是因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘。有以下同步选项：</p>
<table>
<thead>
<tr>
<th align="center">选项</th>
<th align="center">同步频率</th>
</tr>
</thead>
<tbody><tr>
<td align="center">always</td>
<td align="center">每个写命令都同步</td>
</tr>
<tr>
<td align="center">everysec</td>
<td align="center">每秒同步一次</td>
</tr>
<tr>
<td align="center">no</td>
<td align="center">让操作系统来决定何时同步</td>
</tr>
</tbody></table>
<ul>
<li>always 选项会严重减低服务器的性能；</li>
<li>everysec 选项比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响；</li>
<li>no 选项并不能给服务器性能带来多大的提升，而且也会增加系统崩溃时数据丢失的数量。</li>
</ul>
<p>随着服务器写请求的增多，AOF 文件会越来越大。Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令。</p>
<h1 id="七、事务"><a href="#七、事务" class="headerlink" title="七、事务"></a>七、事务</h1><p>一个事务包含了多个命令，服务器在执行事务期间，不会改去执行其它客户端的命令请求。</p>
<p>事务中的多个命令被一次性发送给服务器，而不是一条一条发送，这种方式被称为流水线，它可以减少客户端与服务器之间的网络通信次数从而提升性能。</p>
<p>Redis 最简单的事务实现方式是使用 MULTI 和 EXEC 命令将事务操作包围起来。</p>
<p>通过使用 slaveof host port 命令来让一个服务器成为另一个服务器的从服务器。</p>
<p>一个从服务器只能有一个主服务器，并且不支持主主复制。</p>
<h1 id="八、复制"><a href="#八、复制" class="headerlink" title="八、复制"></a>八、复制</h1><h2 id="连接过程"><a href="#连接过程" class="headerlink" title="连接过程"></a>连接过程</h2><ol>
<li><p>主服务器创建快照文件，发送给从服务器，并在发送期间使用缓冲区记录执行的写命令。快照文件发送完毕之后，开始向从服务器发送存储在缓冲区中的写命令；</p>
</li>
<li><p>从服务器丢弃所有旧数据，载入主服务器发来的快照文件，之后从服务器开始接受主服务器发来的写命令；</p>
</li>
<li><p>主服务器每执行一次写命令，就向从服务器发送相同的写命令。</p>
</li>
</ol>
<h2 id="主从链"><a href="#主从链" class="headerlink" title="主从链"></a>主从链</h2><p>随着负载不断上升，主服务器可能无法很快地更新所有从服务器，或者重新连接和重新同步从服务器将导致系统超载。为了解决这个问题，可以创建一个中间层来分担主服务器的复制工作。中间层的服务器是最上层服务器的从服务器，又是最下层服务器的主服务器。</p>
<h1 id="九、Sentinel"><a href="#九、Sentinel" class="headerlink" title="九、Sentinel"></a>九、Sentinel</h1><p>Sentinel（哨兵）可以监听集群中的服务器，并在主服务器进入下线状态时，自动从从服务器中选举出新的主服务器。</p>
<h1 id="十、分片"><a href="#十、分片" class="headerlink" title="十、分片"></a>十、分片</h1><p>分片是将数据划分为多个部分的方法，可以将数据存储到多台机器里面，这种方法在解决某些问题时可以获得线性级别的性能提升。</p>
<p>假设有 4 个 Redis 实例 R0，R1，R2，R3，还有很多表示用户的键 user:1，user:2，… ，有不同的方式来选择一个指定的键存储在哪个实例中。</p>
<ul>
<li>最简单的方式是范围分片，例如用户 id 从 0~1000 的存储到实例 R0 中，用户 id 从 1001~2000 的存储到实例 R1 中，等等。但是这样需要维护一张映射范围表，维护操作代价很高。</li>
<li>还有一种方式是哈希分片，使用 CRC32 哈希函数将键转换为一个数字，再对实例数量求模就能知道应该存储的实例。</li>
</ul>
<p>根据执行分片的位置，可以分为三种分片方式：</p>
<ul>
<li>客户端分片：客户端使用一致性哈希等算法决定键应当分布到哪个节点。</li>
<li>代理分片：将客户端请求发送到代理上，由代理转发请求到正确的节点上。</li>
<li>服务器分片：Redis Cluster。</li>
</ul>
]]></content>
      <categories>
        <category>cache</category>
      </categories>
  </entry>
  <entry>
    <title>mysql概要</title>
    <url>/2018/09/05/database/2.mysql/</url>
    <content><![CDATA[<p>提到mysql等数据库，当然绕不开它最基本的概念，数据结构，数据库的索引就是数据结构最好的应用。<br><a href="/2019/01/04/datastructure/index/">对数据结构没有概念的同学请点击</a></p>
<h1 id="一：存储引擎（存储引擎提供不同的存储机制、索引技巧、锁定水平等功能）"><a href="#一：存储引擎（存储引擎提供不同的存储机制、索引技巧、锁定水平等功能）" class="headerlink" title="一：存储引擎（存储引擎提供不同的存储机制、索引技巧、锁定水平等功能）"></a>一：存储引擎（存储引擎提供不同的存储机制、索引技巧、锁定水平等功能）</h1><h2 id="InnoDB与MYISAM比较"><a href="#InnoDB与MYISAM比较" class="headerlink" title="InnoDB与MYISAM比较"></a>InnoDB与MYISAM比较</h2><table>
<thead>
<tr>
<th align="center">功 能</th>
<th align="center">MYISAM</th>
<th align="center">InnoDB</th>
</tr>
</thead>
<tbody><tr>
<td align="center">存储限制</td>
<td align="center">256TB</td>
<td align="center">64TB</td>
</tr>
<tr>
<td align="center">支持事物</td>
<td align="center">不支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">支持锁级别</td>
<td align="center">表级锁</td>
<td align="center">表级锁，行级锁</td>
</tr>
<tr>
<td align="center">支持外键</td>
<td align="center">不支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">支持全文索引</td>
<td align="center">支持</td>
<td align="center">不支持</td>
</tr>
<tr>
<td align="center">支持数索引</td>
<td align="center">支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">支持哈希索引</td>
<td align="center">不支持</td>
<td align="center">不支持</td>
</tr>
<tr>
<td align="center">支持数据缓存</td>
<td align="center">不支持</td>
<td align="center">支持</td>
</tr>
</tbody></table>
<h1 id="二：索引"><a href="#二：索引" class="headerlink" title="二：索引"></a>二：索引</h1><p>索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。</p>
<h2 id="1-B-Tree-索引"><a href="#1-B-Tree-索引" class="headerlink" title="1. B+Tree 索引"></a>1. B+Tree 索引</h2><p>是大多数 MySQL 存储引擎的默认索引类型。</p>
<p>因为不再需要进行全表扫描，只需要<strong>对树进行搜索</strong>即可，所以查找速度快很多。</p>
<p>除了用于查找，还可以用于排序和分组。</p>
<p>可以指定多个列作为索引列，多个索引列共同组成键。</p>
<p>适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。</p>
<p>InnoDB 的 B+Tree 索引分为主索引和辅助索引。主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p>
<p>辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。</p>
<h2 id="2-哈希索引"><a href="#2-哈希索引" class="headerlink" title="2. 哈希索引"></a>2. 哈希索引</h2><p>哈希索引能以 O(1) 时间进行查找，但是失去了有序性：</p>
<ul>
<li>无法用于排序与分组；</li>
<li>只支持精确查找，无法用于部分查找和范围查找。</li>
<li>数据量大时，会产生hash冲突，性能降低。</li>
</ul>
<p>InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。</p>
<h2 id="3-全文索引"><a href="#3-全文索引" class="headerlink" title="3. 全文索引"></a>3. 全文索引</h2><p>MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。</p>
<p>查找条件使用 MATCH AGAINST，而不是普通的 WHERE。</p>
<p>全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。</p>
<p>InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。</p>
<h2 id="4-空间数据索引"><a href="#4-空间数据索引" class="headerlink" title="4. 空间数据索引"></a>4. 空间数据索引</h2><p>MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。</p>
<p>必须使用 GIS 相关的函数来维护数据。</p>
<h1 id="三：数据库拆分"><a href="#三：数据库拆分" class="headerlink" title="三：数据库拆分"></a>三：数据库拆分</h1><h1 id="四：数据库主从与读写分离"><a href="#四：数据库主从与读写分离" class="headerlink" title="四：数据库主从与读写分离"></a>四：数据库主从与读写分离</h1>]]></content>
      <categories>
        <category>database</category>
      </categories>
  </entry>
  <entry>
    <title>explain工具</title>
    <url>/2022/03/22/database/3.explain/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>使用EXPLAIN关键字可以模拟优化器执行SQL语句，分析你的查询语句或是结构的性能瓶颈在select语句之前增加 xplain 关键字，<br>MySQL 会在查询上设置一个标记，执行查询会返 回执行计划的信息， 而不是执行这条SQL 注意：如果 from 中包含子查询，<br>仍会执行该子查询，将结果放入临时表中</p>
<h1 id="explain中的列"><a href="#explain中的列" class="headerlink" title="explain中的列"></a>explain中的列</h1><p><strong>1.id列:</strong></p>
<p>id列的编号是 select 的序列号，有几个 select 就有几个id，并且id的顺序是按 select 出现的 顺序增长的。<br>从大到小，越大的执行优先级越高，相同的从上到下执行，id为null最后执行。</p>
<p><strong>2.select_type列</strong></p>
<p>select_type 表示对应行是简单还是复杂的查询。</p>
<ul>
<li>simple:简单查询。</li>
<li>primary:复杂查询中最外层的 select</li>
<li>subquery:包含在 select 中的子查询（不在 from 子句中）</li>
<li>derived:包含在 from 子句中的子查询。MySQL会将结果存放在一个临时表中，也称为 派生表（derived的英文含义）</li>
</ul>
<p><strong>3.table列</strong></p>
<p>这一列表示 explain 的一行正在访问哪个表。 当 from 子句中有子查询时，table列是 <derivenN> 格式，表示当前查询依赖 id=N 的查询，<br>于是先执行 id=N 的查询。 当有 union 时，UNION RESULT 的 table 列的值为&lt;union1,2&gt;，1和2表示参与 union 的 select 行id。</derivenN></p>
<p><strong>4.type列</strong></p>
<p>这一列表示关联类型或访问类型，即MySQL决定如何查找表中的行，查找数据行记录的大概 范围。</p>
<p>依次从最优到最差分别为：system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; all</p>
<p>一般来说，得保证查询达到range级别，最好达到ref。</p>
<ul>
<li>NULL：mysql能够在优化阶段分解查询语句，在执行阶段用不着再访问表或索引。例如：在 索引列中选取最小值，可以单独查找索引来完成，不需要在执行时访问表</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain select min(id) from film;</span><br></pre></td></tr></table></figure>

<ul>
<li>const, system：mysql能对查询的某部分进行优化并将其转化成一个常量（可以看show warnings 的结果）。<br>用于 primary key 或 unique key 的所有列与常数比较时，所以表最多 有一个匹配行，读取1次，速度比较快。system是const的特例，表里只有一条元组匹配时为 system</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain extended select * from (select * from film where id &#x3D; 1) tmp;</span><br></pre></td></tr></table></figure>

<ul>
<li>eq_ref:primary key 或 unique key 索引的所有部分被连接使用 ，最多只会返回一条符合条件的记录。<br>这可能是在 const 之外最好的联接类型了，简单的 select 查询不会出现这种 type。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain select * from film_actor left join film on film_actor.film_id &#x3D; film.id;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>ref:相比 eq_ref，不使用唯一索引，而是使用普通索引或者唯一性索引的部分前缀，索引要和某个值相比较，可能会找到多个符合条件的行。</p>
</li>
<li><p>range:范围扫描通常出现在 in(), between ,&gt; ,&lt;, &gt;= 等操作中。使用一个索引来检索给定 范围的行。</p>
</li>
<li><p>index：扫描全表索引，这通常比ALL快一些</p>
</li>
<li><p>ALL：即全表扫描，意味着mysql需要从头到尾去查找所需要的行。通常情况下这需要增加索 引来进行优化了</p>
</li>
</ul>
<p><strong>5. possible_keys列</strong></p>
<p>这一列显示查询可能使用哪些索引来查找。 explain 时可能出现 possible_keys 有列，而 key 显示 NULL 的情况，这种情况是因为表中 数据不多，<br>mysql认为索引对此查询帮助不大，选择了全表查询。 如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查 where 子句看是否可 以创造一个适当的索引来提高查询性能，<br>然后用 explain 查看效果</p>
<p><strong>6. key列</strong> </p>
<p>这一列显示mysql实际采用哪个索引来优化对该表的访问。<br>如果没有使用索引，则该列是 NULL。如果想强制mysql使用或忽视possible_keys列中的索 引，在查询中使用 force index、ignore index。</p>
<p><strong>7. key_len列</strong> </p>
<p>这一列显示了mysql在索引里使用的字节数，通过这个值可以算出具体使用了索引中的哪些 列。举例来说，film_actor的联合索引 idx_film_actor_id 由 film_id 和 actor_id 两个int列组成，<br>并且每个int是4字节。 通过结果中的key_len=4可推断出查询使用了第一个列：film_id列来执 行索引查找。 mysql&gt; explain sele</p>
<p>key_len计算规则如下： </p>
<ul>
<li>字符串 char(n)：n字节长度 varchar(n)：2字节存储字符串长度，如果是utf-8，则长度 3n + 2</li>
<li>数值类型tinyint：1字节 smallint：2字节 int：4字节 bigint：8字节 </li>
<li>时间类型：date：3字节 timestamp：4字节 datetime：8字节</li>
<li>如果字段允许为 NULL，需要1字节记录是否为 NULL </li>
</ul>
<p>索引最大长度是768字节，当字符串过长时，mysql会做一个类似左前缀索引的处理，将前半 部分的字符提取出来做索引。</p>
<p><strong>8. ref列</strong> </p>
<p>这一列显示了在key列记录的索引中，表查找值所用到的列或常量，常见的有：const（常 量），字段名（例：film.id）</p>
<p><strong>9. rows列</strong> </p>
<p>这一列是mysql估计要读取并检测的行数，注意这个不是结果集里的行数</p>
<p><strong>10. Extra列</strong> </p>
<p>这一列展示的是额外信息。常见的重要值如下：</p>
<ul>
<li>Using index：使用覆盖索引</li>
<li>Using where：使用 where 语句来处理结果，查询的列未被索引覆盖</li>
<li>Using index condition：查询的列不完全被索引覆盖，where条件中是一个前导列的范围</li>
<li>Using temporary：mysql需要创建一张临时表来处理查询。出现这种情况一般是要进行 优化的，首先是想到用索引来优化。</li>
<li>Using filesort：将用外部排序而不是索引排序，数据较小时从内存排序，否则需要在磁盘 完成排序。这种情况下一般也是要考虑使用索引来优化的。</li>
<li>Select tables optimized away：使用某些聚合函数（比如 max、min）来访问存在索引 的某个字段是</li>
</ul>
]]></content>
      <categories>
        <category>database</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构概念</title>
    <url>/2019/01/04/datastructure/index/</url>
    <content><![CDATA[<h1 id="数据结构算法学习（一）：数据结构与算法概念解析"><a href="#数据结构算法学习（一）：数据结构与算法概念解析" class="headerlink" title="数据结构算法学习（一）：数据结构与算法概念解析"></a>数据结构算法学习（一）：数据结构与算法概念解析</h1><h2 id="什么是数据结构"><a href="#什么是数据结构" class="headerlink" title="什么是数据结构"></a>什么是数据结构</h2><p>数据（data）：符号集合，处理对象。</p>
<p>数据元素（data element），由数据项（data item） 组成。</p>
<p>关键字（key）识别元素，主关键字（primary key） 唯一识别元素。</p>
<p>数据结构（data structure）指数据元素之间存在的关系。包含以下三方面：</p>
<ul>
<li>数据的逻辑结构</li>
<li>数据的存储结构</li>
<li>数据操作</li>
</ul>
<h3 id="数据的逻辑结构"><a href="#数据的逻辑结构" class="headerlink" title="数据的逻辑结构"></a>数据的逻辑结构</h3><p>线性结构：数据元素只有一个前驱数据元素和一个后继数据元素。结构中的数据元素之间存在<strong>一对一</strong>的关系。</p>
<p>非线性结构：</p>
<p>1.树结构：每个数据元素只有一个前驱数据元素，可有零个或若干个后继数据元素。结构中的数据元素之间存在<strong>一对多</strong>的关系。</p>
<p>2.图结构：每个数据元素可有零个或若干个前驱数据元素，零个或若干个后继数据元素。结构中的数据元素之间存在<strong>多对多</strong>的关系。</p>
<h3 id="数据的存储结构"><a href="#数据的存储结构" class="headerlink" title="数据的存储结构"></a>数据的存储结构</h3><p>顺序存储结构:用数据元素在存储器中的<strong>相对位置</strong>来表示数据元素之间的逻辑关系。 </p>
<p>链式存储结构：在每一个数据元素中增加一个存放地址的<strong>指针</strong>，用此指针来表示数据元素之间的逻辑关系。 </p>
<h3 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h3><p>1.初始化。<br>2.判断是否空状态。<br>3.存取，指获得、设置指定元素值。<br>4.统计数据元素个数。<br>5.遍历（traverse），指按照某种次序访问一个数据结构中的所有元素，并且每个数据元素只被访问一次。遍历一种数据结构，将得到一个所有数据元素的线性序列。<br>6.插入（insert）、删除（remove）指定元素。<br>7.查找（search），指在数据结构中寻找满足给定条件的数据元素。<br>8.排序（sort），指对数据元素按照指定关键字值的大小递增（或递减）次序重新排列。</p>
<h2 id="什么是算法"><a href="#什么是算法" class="headerlink" title="什么是算法"></a>什么是算法</h2><p>一个算法（Algorithm）是一个有穷规则的集合，其规则确定一个解决某一特定类型问题的操作序列。 </p>
<p>算法定义：有穷性，确定性，输入，输出，可行性</p>
<p>算法设计目标：正确性，可读性，健壮性，高时间效率，高空间效率</p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>算法的时间效率指算法的执行时间随问题规模的增长而增长的趋势，通常采用时间复杂度来度量算法的时间效率。T(n)=O(f(n)) </p>
<p>一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)</p>
<p>一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n)),称O(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。</p>
<p>常见的算法的时间 复杂度之间的关系为：</p>
<p>O(1)&lt;O(logn)&lt;O(n)&lt;O(nlog n)&lt;O(n2)&lt;O(2n)&lt;O(n!)&lt;O(n的n次幂) </p>
<pre><code>1.一条简单语句的时间复杂度是O(1)。
int count=0; 
2.一个循环的时间复杂度是O(n)。
int n=8, count=0;
for (int i=1; i&lt;=n; i++)
    count++;                              //循环体执行n次
3.以下循环语句的时间复杂度是O(log2 n)。
for (int i=1; i&lt;=n; i*=2)        //i按2的幂（1,2,4,8）递增
    count++;                           //循环体执行1+               次
4.以下二重循环的时间复杂度为O(n2)。
for (int i=1; i&lt;=n; i++) 
    for (int j=1; j&lt;=n; j++)
5.以下二重循环的时间复杂度是O(n×log2n)。
for (int i=1; i&lt;=n; i*=2)        //循环log2n次
    for (int j=1; j&lt;=n; j++)     //循环n次
6.以下二重循环的时间复杂度是O(n)。
for (int i=1; i&lt;=n; i*=2)        //循环log2n次
    for (int j=1; j&lt;=i; j++)      //循环i次
    //循环次数 </code></pre><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>算法所需存储空间的度量，记作： S(n)=O( f(n) ) 其中 n 为问题的规模。</p>
<p>一个算法在计算机存储器上所占用的存储空间，包括存储算法本身所占用的存储空间，算法的输入输出数据所占用的存储空间和算法在运行过程中临时占用的存储空间这三个方面。如果额外空间相对于输入数据量来说是个常数，则称此算法是原地工作。</p>
<p>算法的输入输出数据所占用的存储空间是由要解决的问题决定的，是通过参数表由调用函数传递而来的，它不随本算法的不同而改变。存储算法本身所占用的存储空间与算法书写的长短成正比，要压缩这方面的存储空间，就必须编写出较短的算法。</p>
]]></content>
      <categories>
        <category>datastructure</category>
      </categories>
  </entry>
  <entry>
    <title>chmod指令学习</title>
    <url>/2018/11/29/linux-command/chmod/</url>
    <content><![CDATA[<h1 id="命令格式："><a href="#命令格式：" class="headerlink" title="命令格式："></a>命令格式：</h1><p>chmod [-cfvR] [–help] [–version] mode file   </p>
<h1 id="命令功能："><a href="#命令功能：" class="headerlink" title="命令功能："></a>命令功能：</h1><p>用于改变文件或目录的访问权限，用它控制文件或目录的访问权限。</p>
<h1 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h1><h2 id="必要参数："><a href="#必要参数：" class="headerlink" title="必要参数："></a>必要参数：</h2><pre><code>-c 当发生改变时，报告处理信息
-f 错误信息不输出
-R 处理指定目录以及其子目录下的所有文件
-v 运行时显示详细处理信息</code></pre><h2 id="选择参数："><a href="#选择参数：" class="headerlink" title="选择参数："></a>选择参数：</h2><pre><code>--reference=&lt;目录或者文件&gt; 设置成具有指定目录或者文件具有相同的权限
--version 显示版本信息
&lt;权限范围&gt;+&lt;权限设置&gt; 使权限范围内的目录或者文件具有指定的权限
&lt;权限范围&gt;-&lt;权限设置&gt; 删除权限范围的目录或者文件的指定权限
&lt;权限范围&gt;=&lt;权限设置&gt; 设置权限范围内的目录或者文件的权限为指定的值    </code></pre><h3 id="权限范围："><a href="#权限范围：" class="headerlink" title="权限范围："></a>权限范围：</h3><pre><code>u ：目录或者文件的当前的用户
g ：目录或者文件的当前的群组
o ：除了目录或者文件的当前用户或群组之外的用户或者群组
a ：所有的用户及群组</code></pre><h3 id="权限代号："><a href="#权限代号：" class="headerlink" title="权限代号："></a>权限代号：</h3><pre><code>r ：读权限，用数字4表示
w ：写权限，用数字2表示
x ：执行权限，用数字1表示
- ：删除权限，用数字0表示
s ：特殊权限 </code></pre><h3 id="文字设定法"><a href="#文字设定法" class="headerlink" title="文字设定法:"></a>文字设定法:</h3><pre><code>chmod ［who］ ［+ | - | =］ ［mode］ 文件名
例子：
chmod u+r 给拥有者添加可读权限   </code></pre><h3 id="数字设定法"><a href="#数字设定法" class="headerlink" title="数字设定法:"></a>数字设定法:</h3><ul>
<li>0表示没有权限，1表示可执行权限，2表示可写权限，4表示可读权限，然后将其相加。所以数字属性的格式应为3个从0到7的八进制数，其顺序是（u）（g）（o）</li>
</ul>
<pre><code>chmod ［mode］ 文件名
chmod 751 file 给file的属主分配读、写、执行(7)的权限，给file的所在组分配读、执行(5)的权限，给其他用户分配执行(1)的权限         </code></pre>]]></content>
      <categories>
        <category>linux-command</category>
      </categories>
  </entry>
  <entry>
    <title>chown指令学习</title>
    <url>/2018/11/29/linux-command/chown/</url>
    <content><![CDATA[<h1 id="命令格式："><a href="#命令格式：" class="headerlink" title="命令格式："></a>命令格式：</h1><p>chown [选项]… [所有者][:[组]] 文件…</p>
<h1 id="命令功能："><a href="#命令功能：" class="headerlink" title="命令功能："></a>命令功能：</h1><p>通过chown改变文件的拥有者和群组。在更改文件的所有者或所属群组时，可以使用用户名称和用户识别码设置。普通用户不能将自己的文件改变成其他的拥有者。其操作权限一般为管理员。</p>
<h1 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h1><h2 id="必要参数："><a href="#必要参数：" class="headerlink" title="必要参数："></a>必要参数：</h2><pre><code>-c 显示更改的部分的信息
-f 忽略错误信息
-h 修复符号链接
-R 处理指定目录以及其子目录下的所有文件
-v 显示详细的处理信息
-deference 作用于符号链接的指向，而不是链接文件本身</code></pre><h2 id="选择参数："><a href="#选择参数：" class="headerlink" title="选择参数："></a>选择参数：</h2><pre><code>--reference=&lt;目录或文件&gt; 把指定的目录/文件作为参考，把操作的文件/目录设置成参考文件/目录相同拥有者和群组
--from=&lt;当前用户：当前群组&gt; 只有当前用户和群组跟指定的用户和群组相同时才进行改变
--help 显示帮助信息
--version 显示版本信息</code></pre>]]></content>
      <categories>
        <category>linux-command</category>
      </categories>
  </entry>
  <entry>
    <title>ls指令学习</title>
    <url>/2017/07/05/linux-command/ls/</url>
    <content><![CDATA[<h1 id="命令格式："><a href="#命令格式：" class="headerlink" title="命令格式："></a>命令格式：</h1><p>ls [选项] [目录名]</p>
<h1 id="命令功能："><a href="#命令功能：" class="headerlink" title="命令功能："></a>命令功能：</h1><p>列出目标目录中所有的子目录和文件。</p>
<h1 id="常用参数："><a href="#常用参数：" class="headerlink" title="常用参数："></a>常用参数：</h1><ul>
<li><p>-a, –all 列出目录下的所有文件，包括以 . 开头的隐含文件</p>
</li>
<li><p>-A 同-a，但不列出“.”(表示当前目录)和“..”(表示当前目录的父目录)。  </p>
</li>
<li><p>-c  配合 -lt：根据 ctime 排序及显示 ctime (文件状态最后更改的时间)配合 -l：显示 ctime 但根据名称排序否则：根据 ctime 排序</p>
</li>
<li><p>-C 每栏由上至下列出项目</p>
</li>
<li><p>–color[=WHEN] 控制是否使用色彩分辨文件。WHEN 可以是’never’、’always’或’auto’其中之一</p>
</li>
<li><p>-d, –directory 将目录象文件一样显示，而不是显示其下的文件。</p>
</li>
<li><p>-D, –dired 产生适合 Emacs 的 dired 模式使用的结果</p>
</li>
<li><p>-f 对输出的文件不进行排序，-aU 选项生效，-lst 选项失效</p>
</li>
<li><p>-g 类似 -l,但不列出所有者   </p>
</li>
<li><p>-G, –no-group 不列出任何有关组的信息</p>
</li>
<li><p>-h, –human-readable 以容易理解的格式列出文件大小 (例如 1K 234M 2G)</p>
</li>
<li><p>–si 类似 -h,但文件大小取 1000 的次方而不是 1024</p>
</li>
<li><p>-H, –dereference-command-line 使用命令列中的符号链接指示的真正目的地</p>
</li>
<li><p>–indicator-style=方式 指定在每个项目名称后加上指示符号&lt;方式&gt;：none (默认)，classify (-F)，file-type (-p)</p>
</li>
<li><p>-i, –inode 印出每个文件的 inode 号</p>
</li>
<li><p>-I, –ignore=样式 不印出任何符合 shell 万用字符&lt;样式&gt;的项目</p>
</li>
<li><p>-k 即 –block-size=1K,以 k 字节的形式表示文件的大小。</p>
</li>
<li><p>-l 除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来。</p>
</li>
<li><p>-L, –dereference 当显示符号链接的文件信息时，显示符号链接所指示的对象而并非符号链接本身的信息</p>
</li>
<li><p>-m 所有项目以逗号分隔，并填满整行行宽</p>
</li>
<li><p>-o 类似 -l,显示文件的除组信息外的详细信息。   </p>
</li>
<li><p>-r, –reverse 依相反次序排列</p>
</li>
<li><p>-R, –recursive 同时列出所有子目录层</p>
</li>
<li><p>-s, –size 以块大小为单位列出所有文件的大小</p>
</li>
<li><p>-S 根据文件大小排序</p>
</li>
<li><p>–sort=WORD 以下是可选用的 WORD 和它们代表的相应选项：</p>
<p>  extension -X status -c</p>
<p>  none -U time -t</p>
<p>  size -S atime -u</p>
<p>  time -t access -u</p>
<p>  version -v use -u</p>
</li>
<li><p>-t 以文件修改时间排序</p>
</li>
<li><p>-u 配合 -lt:显示访问时间而且依访问时间排序 配合 -l:显示访问时间但根据名称排序否则：根据访问时间排序</p>
</li>
<li><p>-U 不进行排序;依文件系统原有的次序列出项目</p>
</li>
<li><p>-v 根据版本进行排序</p>
</li>
<li><p>-w, –width=COLS 自行指定屏幕宽度而不使用目前的数值</p>
</li>
<li><p>-x 逐行列出项目而不是逐栏列出</p>
</li>
<li><p>-X 根据扩展名排序</p>
</li>
<li><p>-1 每行只列出一个文件</p>
</li>
<li><p>–help 显示此帮助信息并离开</p>
</li>
<li><p>–version 显示版本信息并离开</p>
</li>
</ul>
]]></content>
      <categories>
        <category>linux-command</category>
      </categories>
  </entry>
  <entry>
    <title>rm特殊删除</title>
    <url>/2018/10/29/linux-command/rm/</url>
    <content><![CDATA[<h1 id="特殊删除"><a href="#特殊删除" class="headerlink" title="特殊删除"></a>特殊删除</h1><h2 id="删除所有-p开头的文件"><a href="#删除所有-p开头的文件" class="headerlink" title="删除所有-p开头的文件"></a>删除所有-p开头的文件</h2><p>rm – -P.* </p>
<p>需要用–进行特殊处理</p>
<h2 id="自定义回收站功能"><a href="#自定义回收站功能" class="headerlink" title="自定义回收站功能"></a>自定义回收站功能</h2><p>myrm(){ D=/tmp/$(date +%Y%m%d%H%M%S); mkdir -p $D;  mv “$@” $D &amp;&amp; echo “moved to $D ok”; }</p>
<p>alias rm=’myrm’</p>
]]></content>
      <categories>
        <category>linux-command</category>
      </categories>
  </entry>
  <entry>
    <title>文件查找之which&amp;whereis&amp;locate</title>
    <url>/2018/12/04/linux-command/which&amp;whereis&amp;locate/</url>
    <content><![CDATA[<h1 id="which"><a href="#which" class="headerlink" title="which"></a>which</h1><h2 id="which命令格式："><a href="#which命令格式：" class="headerlink" title="which命令格式："></a>which命令格式：</h2><p>which 可执行文件名称 </p>
<h2 id="命令功能："><a href="#命令功能：" class="headerlink" title="命令功能："></a>命令功能：</h2><p>在<strong>PATH变量指定的路径</strong>中，搜索某个系统命令的位置，并且返回第一个搜索结果。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。 </p>
<h3 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h3><pre><code>-n 　指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。

-p 　与-n参数相同，但此处的包括了文件的路径。

-w 　指定输出时栏位的宽度。

-V 　显示版本信息</code></pre><h1 id="whereis"><a href="#whereis" class="headerlink" title="whereis"></a>whereis</h1><p>whereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。</p>
<p>和find相比，whereis查找的速度非常快，这是因为linux系统会将 系统内的所有文件都记录在一个数据库文件中，当使用whereis和下面即将介绍的locate时，会从数据库中查找数据，而不是像find命令那样，通 过遍历硬盘来查找，效率自然会很高。 </p>
<p>但是该数据库文件并不是实时更新，默认情况下时一星期更新一次，因此，我们在用whereis和locate 查找文件时，有时会找到已经被删除的数据，或者刚刚建立文件，却无法查找到，原因就是因为数据库文件没有被更新。 </p>
<h2 id="whereis命令格式："><a href="#whereis命令格式：" class="headerlink" title="whereis命令格式："></a>whereis命令格式：</h2><p>whereis [-bmsu] [BMS 目录名 -f ] 文件名</p>
<h2 id="命令功能：-1"><a href="#命令功能：-1" class="headerlink" title="命令功能："></a>命令功能：</h2><p>whereis命令是定位<strong>可执行文件</strong>、<strong>源代码文件</strong>、<strong>帮助文件在文件系统中的位置</strong>。这些文件的属性应属于原始代码，二进制文件，或是帮助文件。whereis 程序还具有搜索源代码、指定备用搜索路径和搜索不寻常项的能力</p>
<h2 id="命令参数-1"><a href="#命令参数-1" class="headerlink" title="命令参数"></a>命令参数</h2><pre><code>-b   定位可执行文件。

-m   定位帮助文件。

-s   定位源代码文件。

-u   搜索默认路径下除可执行文件、源代码文件、帮助文件以外的其它文件。

-B   指定搜索可执行文件的路径。

-M   指定搜索帮助文件的路径。

-S   指定搜索源代码文件的路径。</code></pre><h1 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h1><p>locate 让使用者可以很快速的搜寻档案系统内是否有指定的档案。其方法是先建立一个包括系统内所有档案名称及路径的数据库，之后当寻找时就只需查询这个数据库，而不必实际深入档案系统之中了。在一般的 distribution 之中，数据库的建立都被放在 crontab 中自动执行。</p>
<h2 id="locate命令格式："><a href="#locate命令格式：" class="headerlink" title="locate命令格式："></a>locate命令格式：</h2><p>whereis [-bmsu] [BMS 目录名 -f ] 文件名</p>
<h2 id="命令功能：-2"><a href="#命令功能：-2" class="headerlink" title="命令功能："></a>命令功能：</h2><p>locate命令可以在搜寻数据库时快速找到档案，数据库由updatedb程序来更新，updatedb是由cron daemon周期性建立的，locate命令在搜寻数据库时比由整个由硬盘资料来搜寻资料来得快，但较差劲的是locate所找到的档案若是最近才建立或 刚更名的，可能会找不到，在内定值中，updatedb每天会跑一次，可以由修改crontab来更新设定值。(etc/crontab)</p>
<p>locate指定用在搜寻符合条件的档案，它会去储存档案与目录名称的数据库内，寻找合乎范本样式条件的档案或目录录，可以使用特殊字元（如”<em>” 或”?”等）来指定范本样式，如指定范本为kcpa</em>ner, locate会找出所有起始字串为kcpa且结尾为ner的档案或目录，如名称为kcpartner若目录录名称为kcpa_ner则会列出该目录下包括 子目录在内的所有档案。</p>
<p>locate指令和find找寻档案的功能类似，但locate是透过update程序将硬盘中的所有档案和目录资料先建立一个索引数据库，在 执行loacte时直接找该索引，查询速度会较快，索引数据库一般是由操作系统管理，但也可以直接下达update强迫系统立即修改索引数据库。</p>
<h2 id="命令参数-2"><a href="#命令参数-2" class="headerlink" title="命令参数"></a>命令参数</h2><pre><code>-e   将排除在寻找的范围之外。

-1  如果 是 1．则启动安全模式。在安全模式下，使用者不会看到权限无法看到    的档案。这会始速度减慢，因为 locate 必须至实际的档案系统中取得档案的    权限资料。

-f   将特定的档案系统排除在外，例如我们没有到理要把 proc 档案系统中的档案    放在资料库中。

-q  安静模式，不会显示任何错误讯息。

-n 至多显示 n个输出。

-r 使用正规运算式 做寻找的条件。

-o 指定资料库存的名称。

-d 指定资料库的路径

-h 显示辅助讯息

-V 显示程式的版本讯息  </code></pre>]]></content>
      <categories>
        <category>linux-command</category>
      </categories>
  </entry>
  <entry>
    <title>nginx基础配置</title>
    <url>/2018/12/03/nginx/nginxBase/</url>
    <content><![CDATA[<pre><code>#全局块 start
#配置影响nginx全局的指令。一般有运行nginx服务器的用户组，nginx进程pid存放路径，日志存放路径，配置文件引入，允许生成worker process数等。
########### 每个指令必须有分号结束。#################

#user  nobody; #配置用户或者组，默认为nobody nobody。
worker_processes  1;#允许生成的进程数，默认为1

#制定日志路径，级别。这个设置可以放入全局块，http块，server块，级别以此为：debug|info|notice|warn|error|crit|alert|emerg
#error_log  logs/error.log;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;

#pid        logs/nginx.pid;#指定nginx进程运行文件存放地址

#全局块 end

#events块 start
#配置影响nginx服务器或与用户的网络连接。有每个进程的最大连接数，选取哪种事件驱动模型处理连接请求，是否允许同时接受多个网路连接，开启多个网络连接序列化等

events {
    accept_mutex on;   #设置网路连接序列化，防止惊群现象发生，默认为on
    multi_accept on;  #设置一个进程是否同时接受多个网络连接，默认为off
    #use epoll;      #事件驱动模型，select|poll|kqueue|epoll|resig|/dev/poll|eventport
    worker_connections  1024;    #最大连接数，默认为1024
}

#events块 end

#http块 start
#可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。如文件引入，mime-type定义，日志自定义，是否使用sendfile传输文件，连接超时时间，单连接请求数等。
http {
    include       mime.types;#文件扩展名与文件类型映射表 
    default_type  application/octet-stream;#默认文件类型
    #access_log off; #取消服务日志   

    #log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; #自定义格式
    #                  &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;
    #                  &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;

    #access_log  logs/access.log  main;  #combined为日志格式的默认值

    sendfile        on; #允许sendfile方式传输文件，默认为off，可以在http块，server块，location块。
    #sendfile_max_chunk 100k;  #每个进程每次调用传输数量不能大于设定的值，默认为0，即不设上限。

    #tcp_nopush     on; 
    #开启或者关闭nginx在FreeBSD上使用TCP_NOPUSH套接字选项， 在Linux上使用TCP_CORK套接字选项。 选项仅在使用sendfile的时候才开启。 #开启此选项允许在Linux和FreeBSD4.*上将响应头和正文的开始部分一起发送；一次性发送整个文件

    #keepalive_timeout  0; #连接超时时间，默认为65s，可以在http，server，location块。
    keepalive_timeout  65;

    #gzip  on;是否开启Gzip 压缩
    #gzip_min_length 1k; 不压缩临界值，大于1K的才压缩，一般不用改
    #gzip_buffers 4 16k;
    #gzip_http_version 1.0; 用了反向代理的话，末端通信是HTTP/1.0，默认是HTTP/1.1
    #gzip_comp_level 2; 压缩级别，1-10，数字越大压缩的越好，时间也越长
    #gzip_types text/plain application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png; #进行压缩的文件类型，缺啥补啥就行了，JavaScript有两种写法，最好都写上吧，总有人抱怨js文件没有压缩，其实多写一种格式就行了
    #gzip_vary off; 跟Squid等缓存服务有关，on的话会在Header里增加&quot;Vary: Accept-Encoding&quot;
    #gzip_disable &quot;MSIE [1-6]\.&quot;; IE6对Gzip不怎么友好，不给它Gzip了

    #server块 start
    #配置虚拟主机的相关参数，一个http中可以有多个server。

    server {
        listen       8080; #监听端口
        server_name  localhost; #监听地址 

        #charset koi8-r;

        #access_log  logs/host.access.log  main;

        #location块 start 
        #配置请求的路由，以及各种页面的处理情况。

        location / {
            root   html; #根目录
            index  index.html index.htm; #设置默认页
        }
        #location块 end 

        #error_page  404              /404.html;

        # redirect server error pages to the static page /50x.html
        #
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }

        # proxy the PHP scripts to Apache listening on 127.0.0.1:80
        #
        #location ~ \.php$ {
        #    proxy_pass   http://127.0.0.1;
        #}

        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
        #
        #location ~ \.php$ {
        #    root           html;
        #    fastcgi_pass   127.0.0.1:9000;
        #    fastcgi_index  index.php;
        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;
        #    include        fastcgi_params;
        #}

        # deny access to .htaccess files, if Apache&apos;s document root
        # concurs with nginx&apos;s one
        #
        #location ~ /\.ht {
        #    deny  all;
        #}
    }

    #server块 end

    # another virtual host using mix of IP-, name-, and port-based configuration
    #
    #server {
    #    listen       8000;
    #    listen       somename:8080;
    #    server_name  somename  alias  another.alias;

    #    location / {
    #        root   html;
    #        index  index.html index.htm;
    #    }
    #}


    # HTTPS server
    #
    #server {
    #    listen       443 ssl;
    #    server_name  localhost;

    #    ssl_certificate      cert.pem;
    #    ssl_certificate_key  cert.key;

    #    ssl_session_cache    shared:SSL:1m;
    #    ssl_session_timeout  5m;

    #    ssl_ciphers  HIGH:!aNULL:!MD5;
    #    ssl_prefer_server_ciphers  on;

    #    location / {
    #        root   html;
    #        index  index.html index.htm;
    #    }
    #}

}
#http块 end</code></pre>]]></content>
      <categories>
        <category>nginx</category>
      </categories>
  </entry>
  <entry>
    <title>杭州地铁规划2025</title>
    <url>/2020/04/10/other/hangzhoumetro2025/</url>
    <content><![CDATA[<h1 id="杭州地铁规划2025"><a href="#杭州地铁规划2025" class="headerlink" title="杭州地铁规划2025"></a>杭州地铁规划2025</h1><p><img src="/uploads/other/%E6%9D%AD%E5%B7%9E%E5%9C%B0%E9%93%81%E8%A7%84%E5%88%922025.jpg" alt="杭州地铁规划2025.jpg"></p>
]]></content>
      <categories>
        <category>other</category>
      </categories>
  </entry>
  <entry>
    <title>Filter详解</title>
    <url>/2017/02/28/servlet/filter/</url>
    <content><![CDATA[<h1 id="web-xml中元素执行的顺序listener-gt-filter-gt-struts拦截器-gt-servlet。"><a href="#web-xml中元素执行的顺序listener-gt-filter-gt-struts拦截器-gt-servlet。" class="headerlink" title="web.xml中元素执行的顺序listener-&gt;filter-&gt;struts拦截器-&gt;servlet。"></a>web.xml中元素执行的顺序listener-&gt;filter-&gt;struts拦截器-&gt;servlet。</h1><ul>
<li>1.过滤器的概念</li>
</ul>
<p>Java中的Filter 并不是一个标准的Servlet ，它不能处理用户请求，也不能对客户端生成响应。 主要用于对HttpServletRequest 进行预处理，也可以对HttpServletResponse 进行后处理，是个典型的处理链。</p>
<p>优点：过滤链的好处是，执行过程中任何时候都可以打断，只要不执行chain.doFilter()就不会再执行后面的过滤器和请求的内容。而在实际使用时，就要特别注意过滤链的执行顺序问题</p>
<ul>
<li>2.过滤器的作用描述</li>
</ul>
<p>在HttpServletRequest 到达Servlet 之前，拦截客户的HttpServletRequest 。根据需要检查HttpServletRequest ，也可以修改HttpServletRequest 头和数据。在HttpServletResponse 到达客户端之前，拦截HttpServletResponse 。根据需要检查HttpServletResponse ，可以修改HttpServletResponse 头和数据。</p>
<ul>
<li>3.过滤器的执行流程</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/4942449-1824dc9cb75ad1b0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<ul>
<li>4.Filter接口</li>
</ul>
<p>4.1 如何驱动</p>
<p>在 web 应用程序启动时，web 服务器将根据 web.xml 文件中的配置信息来创建每个注册的 Filter 实例对象，并将其保存在服务器的内存中</p>
<p>4.2 方法介绍</p>
<p>init()  Init 方法在 Filter 生命周期中仅执行一次，web 容器在调用 init 方法时   tomcat启动时出调用</p>
<p>doFilter()  Filter 链的执行  过滤方法在请求发出后立即调用，过滤特定的URL</p>
<p>destory()  在Web容器卸载 Filter 对象之前被调用。该方法在Filter的生命周期中仅执行一次。在这个方法中，可以释放过滤器使用的资源。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4942449-cdddc0cc56b94c13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<ul>
<li>5.FilterChain接口</li>
</ul>
<p>5.1 如何实例化    代表当前 Filter 链的对象。由容器实现，容器将其实例作为参数传入过滤器对象的doFilter()方法中</p>
<p>5.2 作用   调用过滤器链中的下一个过滤器</p>
<ul>
<li>filter实例：</li>
</ul>
<p>web.xml配置:<br><img src="http://upload-images.jianshu.io/upload_images/4942449-d4cbf63d54949495.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>编码拦截器：<br><img src="http://upload-images.jianshu.io/upload_images/4942449-8e160d51f7cc6291.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>日志拦截器：<br><img src="http://upload-images.jianshu.io/upload_images/4942449-37a534181fd5c6ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>HelloServlet类：<br><img src="http://upload-images.jianshu.io/upload_images/4942449-19a6c30a4c2d5be0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>结果：<br><img src="http://upload-images.jianshu.io/upload_images/4942449-38eda2225f71a42c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<ul>
<li>总结：</li>
</ul>
<p>1.过滤器执行流程</p>
<p>2.常用过滤器</p>
<h1 id="FilterConfig接口"><a href="#FilterConfig接口" class="headerlink" title="FilterConfig接口"></a>FilterConfig接口</h1><p>1、与普通的Servlet程序一样，Filter程序也很可能需要访问Servlet容器。Servlet规范将代表ServletContext对象和Filter的配置参数信息都封装到一个称为FilterConfig的对象中。</p>
<p>2、FilterConfig接口则用于定义FilterConfig对象应该对外提供的方法，以便在Filter程序中可以调用这些方法来获取ServletContext对象，以及获取在web.xml文件中为Filter设置的友好名称和初始化参数。</p>
<p>3、FilterConfig接口定义的各个方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interfaceFilterConfig &#123;</span><br><span class="line"></span><br><span class="line">    String getFilterName();</span><br><span class="line"></span><br><span class="line">    ServletContext getServletContext();</span><br><span class="line"></span><br><span class="line">    String getInitParameter(String var1);</span><br><span class="line"></span><br><span class="line">    Enumeration getInitParameterNames();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getFilterName方法，返回元素的设置值。</p>
<p>getServletContext方法，返回FilterConfig对象中所包装的ServletContext对象的引用。</p>
<p>getInitParameter方法，用于返回在web.xml文件中为Filter所设置的某个名称的初始化的参数值。</p>
<p>getInitParameterNames方法，返回一个Enumeration集合对象。</p>
]]></content>
      <categories>
        <category>servlet</category>
      </categories>
  </entry>
  <entry>
    <title>Spring Bean 生命周期</title>
    <url>/2019/12/06/spring/beanLifeCycle/</url>
    <content><![CDATA[<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p><img src="/uploads/spring/springBeanLifeCycle.png" alt="生命周期"></p>
<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p><img src="/uploads/spring/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8Fspringbean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg" alt="单例模式生命周期"></p>
<h1 id="多例模式"><a href="#多例模式" class="headerlink" title="多例模式"></a>多例模式</h1><p>需求主动调用才会创建对象，原因见下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LifeCycle lifeCycle &#x3D; (LifeCycle) applicationContext.getBean(&quot;lifeCycle&quot;);</span><br></pre></td></tr></table></figure>


<p><img src="/uploads/spring/%E5%A4%9A%E4%BE%8B%E6%A8%A1%E5%BC%8Fspringbean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg" alt="多例模式生命周期"></p>
<h1 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h1><h2 id="单例模式-1"><a href="#单例模式-1" class="headerlink" title="单例模式"></a>单例模式</h2><p>bean在单例模式下，spring容器启动时解析xml文件发现该bean标签后，直接创建该bean对象存入内部map中保存，<br>此后无论调用多少次getBean()获取该bean都是从map中获取该对象返回，一直是一个对象。<br>此对象一直被spring容器持有，直到容器推出时，随着容器的退出对象被销毁。</p>
<h2 id="多例模式-1"><a href="#多例模式-1" class="headerlink" title="多例模式"></a>多例模式</h2><p>bean在多例模式下，spring容器启动时解析xml发下该bean标签后，只是将该bean进行管理，并不会创建对象，<br>此后每层使用getBean()获取该bean时，spring都会重新创建该对象返回，每层都是一个新的对象。<br>这个对象spring容器并不会持有，什么时候销毁却决于该对象的用户自己什么时候销毁该对象。</p>
<h1 id="相应测试源码"><a href="#相应测试源码" class="headerlink" title="相应测试源码"></a><a href="https://github.com/MarchNineteen/spring-example/blob/master/spring-example-test/src/main/java/com/wyb/test/spring/bean/LifeCycle.java" target="_blank" rel="noopener">相应测试源码</a></h1>]]></content>
      <categories>
        <category>spring</category>
      </categories>
  </entry>
  <entry>
    <title>Spring 加载XML文件的六种方式</title>
    <url>/2019/12/06/spring/springLoadXml/</url>
    <content><![CDATA[<h1 id="一-XmlBeanFactory-引用资源"><a href="#一-XmlBeanFactory-引用资源" class="headerlink" title="一: XmlBeanFactory 引用资源"></a>一: XmlBeanFactory 引用资源</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Resource resource &#x3D; new ClassPathResource(&quot;appcontext.xml&quot;);</span><br><span class="line">BeanFactory factory &#x3D; new XmlBeanFactory(resource);</span><br><span class="line">BaseEntity entity &#x3D; (BaseEntity) factory.getBean(&quot;baseEntity1&quot;);</span><br><span class="line">System.out.println(&quot;XmlBeanFactory 获取 bean ：&quot; + entity.getId());</span><br></pre></td></tr></table></figure>

<h1 id="二-ClassPathXmlApplicationContext-编译路径"><a href="#二-ClassPathXmlApplicationContext-编译路径" class="headerlink" title="二: ClassPathXmlApplicationContext  编译路径"></a>二: ClassPathXmlApplicationContext  编译路径</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 单个文件</span><br><span class="line">ApplicationContext applicationContext &#x3D; new ClassPathXmlApplicationContext(&quot;classpath:appcontext.xml&quot;);</span><br><span class="line">&#x2F;&#x2F; 多个文件</span><br><span class="line">ApplicationContext multiApplicationContext &#x3D; new ClassPathXmlApplicationContext(&quot;classpath:appcontext.xml&quot;, &quot;classpath:appcontext2.xml&quot;);</span><br><span class="line">BaseEntity entity &#x3D; (BaseEntity) applicationContext.getBean(&quot;baseEntity&quot;);</span><br><span class="line"></span><br><span class="line">BaseEntity entity2 &#x3D; (BaseEntity) multiApplicationContext.getBean(&quot;baseEntity2&quot;);</span><br><span class="line">System.out.println(&quot;ClassPathXmlApplicationContext 获取 bean ：&quot; + entity.getId());</span><br><span class="line">System.out.println(&quot;ClassPathXmlApplicationContext 获取 bean2 ：&quot; + entity2.getId());</span><br></pre></td></tr></table></figure>

<h1 id="三-用文件系统的路径"><a href="#三-用文件系统的路径" class="headerlink" title="三: 用文件系统的路径"></a>三: 用文件系统的路径</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; classPath</span><br><span class="line">ApplicationContext fileSystemXmlApplicationContext &#x3D; new FileSystemXmlApplicationContext(&quot;classpath:appcontext.xml&quot;);</span><br><span class="line">&#x2F;&#x2F; 文件系统</span><br><span class="line">ApplicationContext fileSystemXmlApplicationContext2 &#x3D; new FileSystemXmlApplicationContext(&quot;spring-example-test&#x2F;src&#x2F;main&#x2F;resources&#x2F;appcontext.xml&quot;);</span><br><span class="line">ApplicationContext fileSystemXmlApplicationContext3 &#x3D; new FileSystemXmlApplicationContext(&quot;file:E:\\marcher\\spring-example\\spring-example-test\\src\\main\\resources&#x2F;appcontext.xml&quot;);</span><br><span class="line">ApplicationContext fileSystemXmlApplicationContext4 &#x3D; new FileSystemXmlApplicationContext(&quot;E:\\marcher\\spring-example\\spring-example-test\\src\\main\\resources&#x2F;appcontext.xml&quot;);</span><br><span class="line"></span><br><span class="line">BaseEntity entity &#x3D; (BaseEntity) fileSystemXmlApplicationContext.getBean(&quot;baseEntity&quot;);</span><br><span class="line">System.out.println(&quot;ClassPathXmlApplicationContext 获取 bean ：&quot; + entity.getId());</span><br><span class="line"></span><br><span class="line">BaseEntity entity2 &#x3D; (BaseEntity) fileSystemXmlApplicationContext2.getBean(&quot;baseEntity&quot;);</span><br><span class="line">System.out.println(&quot;ClassPathXmlApplicationContext 获取 bean ：&quot; + entity2.getId());</span><br><span class="line"></span><br><span class="line">BaseEntity entity3 &#x3D; (BaseEntity) fileSystemXmlApplicationContext3.getBean(&quot;baseEntity&quot;);</span><br><span class="line">System.out.println(&quot;ClassPathXmlApplicationContext 获取 bean ：&quot; + entity2.getId());</span><br><span class="line"></span><br><span class="line">BaseEntity entity4 &#x3D; (BaseEntity) fileSystemXmlApplicationContext4.getBean(&quot;baseEntity&quot;);</span><br><span class="line">System.out.println(&quot;ClassPathXmlApplicationContext 获取 bean ：&quot; + entity2.getId());</span><br></pre></td></tr></table></figure>

<h1 id="四-XmlWebApplicationContext是专为Web工程定制的。"><a href="#四-XmlWebApplicationContext是专为Web工程定制的。" class="headerlink" title="四: XmlWebApplicationContext是专为Web工程定制的。"></a>四: XmlWebApplicationContext是专为Web工程定制的。</h1><p>ServletContext servletContext = request.getSession().getServletContext();<br>ApplicationContext ctx = WebApplicationContextUtils.getWebApplicationContext(servletContext ); </p>
<h1 id="五-使用BeanFactory"><a href="#五-使用BeanFactory" class="headerlink" title="五: 使用BeanFactory"></a>五: 使用BeanFactory</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BeanDefinitionRegistry reg &#x3D; new DefaultListableBeanFactory();</span><br><span class="line">XmlBeanDefinitionReader reader &#x3D; new XmlBeanDefinitionReader(reg);</span><br><span class="line">reader.loadBeanDefinitions(new ClassPathResource(&quot;appcontext.xml&quot;));</span><br><span class="line">reader.loadBeanDefinitions(new ClassPathResource(&quot;appcontext2.xml&quot;));</span><br><span class="line">BeanFactory bf &#x3D; (BeanFactory) reg;</span><br><span class="line">BaseEntity entity &#x3D; (BaseEntity) bf.getBean(&quot;baseEntity&quot;);</span><br><span class="line">BaseEntity entity2 &#x3D; (BaseEntity) bf.getBean(&quot;baseEntity2&quot;);</span><br><span class="line">System.out.println(&quot;ClassPathXmlApplicationContext 获取 bean ：&quot; + entity.getId());</span><br><span class="line">System.out.println(&quot;ClassPathXmlApplicationContext 获取 bean ：&quot; + entity2.getId());</span><br></pre></td></tr></table></figure>

<h1 id="六：Web-应用启动时加载多个配置文件"><a href="#六：Web-应用启动时加载多个配置文件" class="headerlink" title="六：Web 应用启动时加载多个配置文件"></a>六：Web 应用启动时加载多个配置文件</h1><p>通过ContextLoaderListener 也可加载多个配置文件，在web.xml文件中利用<br><context-pararn>元素来指定多个配置文件位置，其配置如下: </context-pararn></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;context-param&gt;  </span><br><span class="line">    &lt;!-- Context Configuration locations for Spring XML files --&gt;  </span><br><span class="line">       &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;  </span><br><span class="line">       &lt;param-value&gt;  </span><br><span class="line">       .&#x2F;WEB-INF&#x2F;**&#x2F;Appserver-resources.xml,  </span><br><span class="line">       classpath:config&#x2F;aer&#x2F;aerContext.xml,  </span><br><span class="line">       classpath:org&#x2F;codehaus&#x2F;xfire&#x2F;spring&#x2F;xfire.xml,  </span><br><span class="line">       .&#x2F;WEB-INF&#x2F;**&#x2F;*.spring.xml  </span><br><span class="line">       &lt;&#x2F;param-value&gt;  </span><br><span class="line">   &lt;&#x2F;context-param&gt;</span><br></pre></td></tr></table></figure>

<p>这个方法加载配置文件的前提是已经知道配置文件在哪里，虽然可以利用“*”通配符，但灵活度有限。 </p>
<h1 id="获取配套代码"><a href="#获取配套代码" class="headerlink" title="获取配套代码"></a><a href="https://github.com/MarchNineteen/spring-example/tree/master/spring-example-test/src/main/java/com/wyb/test/spring/loadXml" target="_blank" rel="noopener">获取配套代码</a></h1>]]></content>
      <categories>
        <category>spring</category>
      </categories>
  </entry>
  <entry>
    <title>Spring MVC入门</title>
    <url>/2017/07/05/spring/springMVC/</url>
    <content><![CDATA[<h1 id="1-架构"><a href="#1-架构" class="headerlink" title="1.架构"></a>1.架构</h1><ul>
<li><p>1.1架构图<br><img src="http://images2015.cnblogs.com/blog/932062/201609/932062-20160909153624488-530274633.png" alt="架构天"></p>
</li>
<li><p>1.2架构流程</p>
</li>
</ul>
<p>1.用户发送请求至前端控制器DispatcherServlet</p>
<p>2.DispatcherServlet收到请求调用HandlerMapping处理器映射器。</p>
<p>3.处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。</p>
<p>4.DispatcherServlet通过HandlerAdapter处理器适配器调用处理器</p>
<p>5.执行处理器(Controller，也叫后端控制器)。</p>
<p>6.Controller执行完成返回ModelAndView</p>
<p>7.HandlerAdapter将controller执行结果ModelAndView返回</p>
<p>8.DispatcherServlet</p>
<p>DispatcherServlet将ModelAndView传给ViewReslover视图解析器</p>
<p>9.ViewReslover解析后返回具体View</p>
<p>10.DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）。</p>
<p>11.DispatcherServlet响应用户</p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
  </entry>
  <entry>
    <title>springXMLSchema</title>
    <url>/2017/07/05/spring/springXMLSchema/</url>
    <content><![CDATA[<blockquote>
<p>出处 <a href="http://www.jianshu.com/p/1e35c15d0cb8" target="_blank" rel="noopener">http://www.jianshu.com/p/1e35c15d0cb8</a></p>
</blockquote>
<blockquote>
<p>参考资料 <a href="http://www.w3school.com.cn/schema/index.asp" target="_blank" rel="noopener">http://www.w3school.com.cn/schema/index.asp</a></p>
</blockquote>
<h1 id="自己理解整理："><a href="#自己理解整理：" class="headerlink" title="自己理解整理："></a>自己理解整理：</h1><ul>
<li>基本概念：</li>
</ul>
<p>XML Schema也被称为XML Schema定义（XML Schema Definition，XSD）。和DTD一样，Schema也是XML的约束，同样用于定义合法的XML文档构建模块。与DTD不同的是，XML Schema是用一套预先定义好的XML元素和属性创建的，这些元素和属性规定了XML文档的结构和内容模式，且XML Schema规定XML文档实例的结构和每一个元素或属性的数据类型。另外，Schema相对于DTD有一个明显的好处就是，Schema是基于XML编写的，自己本身也是一个XML文档（文件后缀名为.xsd），而不是像DTD有自成一套的语法，这也是Schema能比DTD更被广泛应用的原因。</p>
<ul>
<li>名称空间：</li>
</ul>
<p>在编写了一个XML Schema约束文档后，通常需要把这个文档定义的元素和属性绑定到一个URI地址上，这个地址就叫做名称空间。接着XML文档通过这个名称空间告诉解析引擎，文档中的元素和属性来自哪里。名称空间有什么用呢？就是用来唯一标识元素和属性来自哪个Schema。简单来说，当一个XML实例文档引用了多个Schema的时候，倘若这些Schema定义了同名的元素或属性，名称空间就可以将它们区分开来。</p>
<p>引用其他Schema</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4942449-bd466d293a47249c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="引用其他Schema"></p>
<p>自定义schema 给自己的文件命名方便其他文件调用</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4942449-575c97f367170ff5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4942449-09a4197ec412e170.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>xmlns后的属性即表示该文件中的context属性来源于这个ns</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4942449-09a4197ec412e170.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4942449-000dac2e6124f4d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<ul>
<li>修改XML实例文档:</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/4942449-e87ee2b5f0532d77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4942449-20e2d37ed4275474.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
  </entry>
  <entry>
    <title>git常用指令</title>
    <url>/2019/08/27/tool/git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="工作区与暂存区"><a href="#工作区与暂存区" class="headerlink" title="工作区与暂存区"></a>工作区与暂存区</h1><ul>
<li>版本回退：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log (git log --pretty&#x3D;oneline) 查看提交日志</span><br><span class="line">git log --graph --pretty&#x3D;oneline --abbrev-commit 简化查看日志</span><br><span class="line">git reset --hard commitid(HEAD^ HEAD表示当前版本 ^表示上个版本 以此类推,也可以使用~num,num表示几个^) (windows命令行下需要git reset --hard &quot;HEAD^&quot; ) </span><br><span class="line">git reflog 查看命令历史</span><br></pre></td></tr></table></figure>

<ul>
<li>管理修改：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add xx 把文件添加到版本库</span><br><span class="line">git status 查看当前版本库状态</span><br><span class="line">git commit -m &quot;msg&quot; 提交修改 -m表示提交注释 ps:若使用命令行提交，每次commit都需add</span><br><span class="line">git diff </span><br><span class="line">git diff HEAD -- xx.file 查看工作区和版本库里面最新版本的区别 (HEAD^ 与版本回退同理)</span><br></pre></td></tr></table></figure>

<ul>
<li>撤销修改：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -- xx 把文件在工作区的修改全部撤销。第一种情况修改后未被放入暂存区，撤销修改与版本库一致，第二种已经添加到了暂存区，又作了修改，撤销修改回到add时的状态。让这个文件回到最近一次git commit或git add时的状态</span><br><span class="line"></span><br><span class="line">git reset HEAD &lt;file&gt; 把暂存区的修改回退到工作区,适用于add未commit</span><br></pre></td></tr></table></figure>

<ul>
<li>删除文件：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rm 用于删除一个文件</span><br></pre></td></tr></table></figure>

<ul>
<li>取消文件跟踪：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rm --cached xx.txt 删除readme1.txt的跟踪，并保留在本地。之后git commit </span><br><span class="line"></span><br><span class="line">git rm --f xx.txt 删除readme1.txt的跟踪，并且删除本地文件。之后git commit</span><br></pre></td></tr></table></figure>

<h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><ul>
<li>添加远程库：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add origin xx.git 添加远程仓库地址</span><br><span class="line">git push -u origin master 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令</span><br><span class="line">git push origin master推送最新修改</span><br></pre></td></tr></table></figure>

<ul>
<li>从远程库克隆：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone xx.git</span><br></pre></td></tr></table></figure>

<ul>
<li>多人协作：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote -v 查看远程库信息</span><br><span class="line">git fetch origin &lt;branch-name&gt; 从远程拉去分支代码</span><br><span class="line">git merge 合并代码</span><br><span class="line">git pull &#x3D; git fetch + git merge</span><br><span class="line">git push origin &lt;branch-name&gt; 推送修改</span><br><span class="line">git checkout -b &lt;branch-name&gt; origin&#x2F;&lt;branch-name&gt; 本地创建和远程分支对应的分支,名称最好一致</span><br><span class="line">git branch --set-upstream &lt;branch-name&gt; origin&#x2F;&lt;branch-name&gt; 建立本地分支和远程分支的关联</span><br></pre></td></tr></table></figure>

<ul>
<li>git放弃本地修改，强制更新：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git fetch --all 下载远程仓库最新内容，不做合并</span><br><span class="line">git reset --hard origin&#x2F;master 把HEAD指向master最新版本</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure>

<h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><ul>
<li>创建与合并分支：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch dev 创建dev分支</span><br><span class="line">git checkout dev 切换至dev分支</span><br><span class="line">git checkout -b dev 创建并切换至dev分支</span><br><span class="line">git branch 查看当前分支</span><br><span class="line">git merge dev 合并dev分支代码至当前分支</span><br><span class="line">git branch -d dev 删除dev分支</span><br></pre></td></tr></table></figure>

<ul>
<li>解决冲突：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log --graph 命令可以看到分支合并图</span><br></pre></td></tr></table></figure>

<ul>
<li>Bug分支：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash 暂存当前工作区代码</span><br><span class="line">git stash list 查看暂存代码记录</span><br><span class="line">git stash apply 恢复代码至工作区，但不删除暂存内容</span><br><span class="line">git stash drop 删除暂存内容</span><br><span class="line">git stash pop &#x3D; git stash apply + git stash drop 恢复代码至工作区并删除暂存内容</span><br><span class="line">git cherry-pick &lt;commitid&gt; 复制某一次提交代码至当前分支</span><br></pre></td></tr></table></figure>

<h1 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h1><ul>
<li>创建标签：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git tag &lt;tagname&gt; 用于新建一个标签，默认为HEAD，也可以指定一个commit id</span><br><span class="line">git tag -a &lt;tagname&gt; -m &quot;msg&quot; 可以指定标签信息</span><br><span class="line">git tag 查看所有标签</span><br><span class="line">git show &lt;tagname&gt; 查看说明</span><br></pre></td></tr></table></figure>

<ul>
<li>操作标签：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git tag -d &lt;tagname&gt; 删除一个本地标签</span><br><span class="line">git push origin :refs&#x2F;tags&#x2F;&lt;tagname&gt; 删除一个远程标签</span><br><span class="line">git push origin &lt;tagname&gt; 推送标签至远程</span><br><span class="line">git push origin --tags 一次性推送全部尚未推送到远程的本地标签</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>tool</category>
      </categories>
  </entry>
  <entry>
    <title>maven-dependence</title>
    <url>/2019/05/30/tool/maven-dependence/</url>
    <content><![CDATA[<h1 id="scope参数在dependence中表示依赖的范围。"><a href="#scope参数在dependence中表示依赖的范围。" class="headerlink" title="scope参数在dependence中表示依赖的范围。"></a>scope参数在dependence中表示依赖的范围。</h1><p>首先需要知道，maven在编译项目主代码的时候需要使用一套classpath。例如在编译项目主代码的时候需要用到spring-core，该文件以依赖的方式被引入到classpath中。<br>其次，maven在编译和执行测试的时候会使用另一套classpath，Junit就是一个很好的例子，该文件也以依赖的方式引入到测试使用的classpath中，不同的是这里的依赖<br>范围是test。最后，实际运行maven项目的时候，又会使用一套classpath。</p>
<p>依赖范围就是用来控制依赖与这三种classpath（编辑classpath、测试classpath、运行classpath）的关系，maven有以下几种依赖范围：</p>
<p><strong>Compile</strong>：编译依赖范围。如果没有指定，就会默认使用该依赖范围。使用此依赖范围的maven依赖，对于<strong>编译、测试、运行</strong>三种classpath都有效。<br>典型的例子是spring-core，在编译、测试和运行的时候都需要使用该依赖。</p>
<p><strong>Test</strong>：测试依赖范围。使用此依赖范围的maven依赖，只对于<strong>测试</strong>的classpath有效，在编译主代码或者运行项目的使用时将无法使用此类依赖。典型的例子是Junit，<br>它只有在编辑测试代码及运行测试的时候才需要。</p>
<p><strong>Provided</strong>：已提供依赖范围。使用此依赖范围的maven依赖，对于<strong>编译</strong>和<strong>测试</strong>classpath有效，但在运行时无效。典型的例子是servlet-api，<br>编译和测试项目的时候需要该依赖，但在运行项目的时候，由于容器已经提供，就不需要maven重复的引入一遍。</p>
<p><strong>Runtime</strong>：运行时依赖范围。使用该依赖范围的maven依赖，对于测试和运行classpath有效，但在编译主代码时无效。典型的例子是JDBC驱动实现，项目主代码的编译<br>只需要JDK提供的JDBC接口，只有在执行测试或者运行项目的时候才需要实现上述的具体JDBC驱动。</p>
<p><strong>System</strong>：系统依赖范围。该依赖与三种classpath的关系，<strong>和Provided依赖范围完全一致</strong>。但是，使用System范围的依赖是必须通过systemPath元素显示地指定<br>依赖文件的路径。由于此类依赖不是通过maven仓库解析的，而且往往与本机的系统绑定，可能造成构建的不可移植，因此应该谨慎使用。systemPath元素可以引用环境<br>变量，如：</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;java.sql&lt;/groupId&gt;
    &lt;artifactId&gt;jdbc-stdext&lt;/artifactId&gt;
    &lt;version&gt;2.0&lt;/version&gt;
    &lt;scope&gt;system&lt;/scope&gt;
    &lt;systemPath&gt;${java.home}/lib/rt.jar&lt;/systemPath&gt;
&lt;/dependency&gt;</code></pre><p><strong>Import(maven2.0.9及以上)</strong>：导入依赖范围。该依赖范围不会对3中classpath产生实际影响。    </p>
<p>上述出import依赖的各种依赖范围3中classpath的关系如下表：</p>
<table>
<thead>
<tr>
<th align="center">依赖范围(scope)</th>
<th align="left">编译classpath有效</th>
<th align="left">测试classpath有效</th>
<th align="left">运行classpath有效</th>
<th align="left">例子</th>
</tr>
</thead>
<tbody><tr>
<td align="center">compile</td>
<td align="left">Y</td>
<td align="left">Y</td>
<td align="left">Y</td>
<td align="left">spring-core</td>
</tr>
<tr>
<td align="center">test</td>
<td align="left">-</td>
<td align="left">Y</td>
<td align="left">-</td>
<td align="left">junit</td>
</tr>
<tr>
<td align="center">provided</td>
<td align="left">Y</td>
<td align="left">Y</td>
<td align="left">-</td>
<td align="left">servlet-api</td>
</tr>
<tr>
<td align="center">runtime</td>
<td align="left">-</td>
<td align="left">Y</td>
<td align="left">Y</td>
<td align="left">JDBC驱动</td>
</tr>
<tr>
<td align="center">system</td>
<td align="left">Y</td>
<td align="left">Y</td>
<td align="left">-</td>
<td align="left">本地的，maven仓库之外的类库文件</td>
</tr>
</tbody></table>
<h1 id="maven传递性依赖"><a href="#maven传递性依赖" class="headerlink" title="maven传递性依赖"></a>maven传递性依赖</h1><p>传递性依赖和依赖范围：</p>
<p>依赖范围不仅可以控制依赖与三种classpath的关系，还对传递性依赖产生影响。例，account-email对于spring-core的依赖范围是compile，spring-core对于commons-logging<br>的依赖范围的是compile，那么account-email对于commons-logging这一传递依赖的范围也及时compile。假设A依赖与B，B依赖与C，我们说A对于B的依赖是第一直接依赖，<br>B对于C的依赖为第二直接依赖，A对于C是传递性依赖。第一直接依赖的范围是和第二直接依赖的范围决定了传递性依赖的范围，如下表所示，最左边一行表示第一直接依赖范围，<br>最上面一行便是第二直接依赖范围，中间的交叉单元格则便是传递性依赖范围:</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="left">compile</th>
<th align="left">test</th>
<th align="left">provided</th>
<th align="left">runtime</th>
</tr>
</thead>
<tbody><tr>
<td align="center">compile</td>
<td align="left">compile</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">runtime</td>
</tr>
<tr>
<td align="center">test</td>
<td align="left">test</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">test</td>
</tr>
<tr>
<td align="center">provided</td>
<td align="left">provided</td>
<td align="left">-</td>
<td align="left">provided</td>
<td align="left">provided</td>
</tr>
<tr>
<td align="center">runtime</td>
<td align="left">runtime</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">runtime</td>
</tr>
</tbody></table>
<p>仔细观察表格，可以发现规律：当第二直接依赖为compile的时候，传递性依赖的范围与第一直接依赖范围一致；当第二直接依赖范围是test的时候，依赖不会得以传递，<br>当第二直接依赖的范围是provided的时候，只传递第一直接依赖范围也为provided的依赖，且传递性依赖的范围同样为provided；当第二传递依赖是runtime的时候，<br>传递性依赖的范围与第一直接依赖的范围一致，丹compile例外，此时传递性依赖的范围为runtime。</p>
<h2 id="maven可选依赖"><a href="#maven可选依赖" class="headerlink" title="maven可选依赖"></a>maven可选依赖</h2><p>使用<optional>元素表示依赖为可选依赖，只会对当前项目产生影响，当其他项目依赖当前项目时，该依赖不会被传递</optional></p>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
  </entry>
  <entry>
    <title>springmvc整合swagger（非springboot项目）</title>
    <url>/2019/11/27/%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/springMVC&amp;swagger/</url>
    <content><![CDATA[<h1 id="项目需求"><a href="#项目需求" class="headerlink" title="项目需求"></a>项目需求</h1><p>公司原来的项目是struts2，然后想要改成前后端分离项目，又不想完全抛去原来的一些东西，选择了单独的springmvc，没有使用springboot，这就开启了我的难受之旅。</p>
<h1 id="需要依赖"><a href="#需要依赖" class="headerlink" title="需要依赖"></a>需要依赖</h1><p>万万没想到啊，还不是maven项目，jar包需要自己去探索到底需要哪些jar包，然后还得避免jar包冲突，我太南了…<br>过程中guava库需要升级 jackson库必须存在</p>
<p>最后根据maven项目的所引入的依赖分析，然后自己测试，需要jar包如下：</p>
<p><img src="/uploads/%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/swagger%E6%89%80%E9%9C%80jar.jpg" alt="swagger所需jar"></p>
<p><a href="/uploads/日常问题记录/swagger.rar">下载</a></p>
<h1 id="过程遇到的问题"><a href="#过程遇到的问题" class="headerlink" title="过程遇到的问题"></a>过程遇到的问题</h1><p>上述过程完成后，好不容易项目启动不报错了，但是访问swagger-ui.html，会出现弹框提示错误，这个错误网上随便一搜就会知道是swagger-ui的页面没有映射出来，需要加个静态资源映射。<br>但是并没有那么简单。</p>
<p>网上搜索大部分搜索出来的都是在xml文件中添加swagger文件的映射，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;mvc:resources mapping&#x3D;&quot;swagger-ui.html&quot; location&#x3D;&quot;classpath*:&#x2F;META-INF&#x2F;resources&#x2F;&quot;&#x2F;&gt;</span><br><span class="line">&lt;mvc:resources mapping&#x3D;&quot;webjars&#x2F;**&quot; location&#x3D;&quot;classpath*:&#x2F;META-INF&#x2F;resources&#x2F;webjars&#x2F;&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>但是在我的工程中没有效果，我也不知道为什么。</p>
<p>解决办法一：</p>
<p>由于项目还是采用web.xml格式配置，dispatcherServlet需拦截所有请求，如果加*.htm这种类型，生成的文档接口也必须手动修改访问路径，因为swagger是根据mapping去生成请求路径的。</p>
<p>这样配置之后静态资源也会访问springMVC的servlet，这是我们不需要的，所以我们需要在springmvc.xml添加<a href="mvc:default-servlet-handler/">mvc:default-servlet-handler/</a>,添加一个默认servlet，会自动过滤静态资源请求。</p>
<p>解决办法二：</p>
<p>去swagger的网站下载zip包，把dist文件目录copy至自己的页面下，修改index.htm文件中的url地址, /v2/api-docs即为swagger访问数据的地址。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.onload &#x3D; function() &#123;</span><br><span class="line">  &#x2F;&#x2F; Begin Swagger UI call region</span><br><span class="line">  const ui &#x3D; SwaggerUIBundle(&#123;</span><br><span class="line">    &#x2F;&#x2F; url: &quot;https:&#x2F;&#x2F;petstore.swagger.io&#x2F;v2&#x2F;swagger.json&quot;,</span><br><span class="line">    url: &quot;http:&#x2F;&#x2F;xx.xx.xx&#x2F;v2&#x2F;api-docs&quot;,</span><br><span class="line">    dom_id: &#39;#swagger-ui&#39;,</span><br><span class="line">    deepLinking: true,</span><br><span class="line">    presets: [</span><br><span class="line">      SwaggerUIBundle.presets.apis,</span><br><span class="line">      SwaggerUIStandalonePreset</span><br><span class="line">    ],</span><br><span class="line">    plugins: [</span><br><span class="line">      SwaggerUIBundle.plugins.DownloadUrl</span><br><span class="line">    ],</span><br><span class="line">    layout: &quot;StandaloneLayout&quot;</span><br><span class="line">  &#125;)</span><br><span class="line">  &#x2F;&#x2F; End Swagger UI call region</span><br><span class="line"></span><br><span class="line">  window.ui &#x3D; ui</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样添加之后，我们需要去直接访问自己的页面地址，而不是访问swagger-ui.html，例如/swagger/index.html。<br>如果采用<em>.htm或者</em>.do这种方式，可能会出现页面访问得到的，提示/v2/api-docs接口无法请求。解决方案是配置把swagger或者数据的接口置入dispatcherServlet中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;SpringmvcDispatcherServlet&lt;&#x2F;servlet-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;&#x2F;v2&#x2F;api-docs&lt;&#x2F;url-pattern&gt;</span><br><span class="line">&lt;&#x2F;servlet-mapping&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>日常问题记录</category>
      </categories>
  </entry>
  <entry>
    <title>webXml和spring初始化顺序问题</title>
    <url>/2019/10/17/%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/webXml%E5%92%8Cspring%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="问题产生"><a href="#问题产生" class="headerlink" title="问题产生"></a>问题产生</h1><p>同事想要在项目初始化完成后，开启线程池执行业务逻辑的代码，其中需要注入spring的bean，他想到使用servlet的listener，但是无法在listener中无法直接通过@Resource注解获取实例。</p>
<h1 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h1><p>在tomcat容器中，listener，filter，servlet等都不是交给spring容器管理，两者环境不一致当然就获取不到了。</p>
<h1 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h1><p>如果需要在tomcat等web容器环境中获取spring实例需要获取ServletContext，通过webContext去获取springIOC容器从而获取spring实例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;ServletContext,是一个全局的储存信息的空间，服务器开始，其就存在，服务器关闭，其才释放。request，一个用户可有多个；session，一个用户一个；而servletContext，所有用户共用一个。</span><br><span class="line">&#x2F;&#x2F;所以，为了节省空间，提高效率，ServletContext中，要放必须的、重要的、所有用户需要共享的线程又是安全的一些信息。</span><br><span class="line">    @Override</span><br><span class="line">    public void contextInitialized(ServletContextEvent servletContextEvent) &#123;</span><br><span class="line">        WebApplicationContext springContext &#x3D; WebApplicationContextUtils.getWebApplicationContext(servletContextEvent.getServletContext());</span><br><span class="line">        Init init &#x3D; (Init) springContext.getBean(&quot;Init&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(init);</span><br><span class="line">        System.out.println(&quot;listener init&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="问题延伸"><a href="#问题延伸" class="headerlink" title="问题延伸"></a>问题延伸</h1><h2 id="web-xml文件中各个节点参数的启动顺序"><a href="#web-xml文件中各个节点参数的启动顺序" class="headerlink" title="web.xml文件中各个节点参数的启动顺序"></a>web.xml文件中各个节点参数的启动顺序</h2><p>可以明确的是初始化顺序context-param -&gt; listener-&gt; filter -&gt; servlet。</p>
<p>在代码中分别自定义listener，filter，spring bean（Init）。启动项目可以看出先打印 listener init,再打印filter init。</p>
<p>那么spring容器的bean呢，在什么时候会进行初始化。新建Init类实现InitializingBean，然后在xml中配置该bean，这样spring容器初始化是会去执行afterPropertiesSet方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void afterPropertiesSet() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;InitializingBean&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>创建完java文件后，咱们先来看看 web.xml。</p>
<p>一般springIOC容器在context-param进行初始化，<strong>此时spring就已经在初始化xml文件中的实例了</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--在web.xml中通过contextConfigLocation配置spring，contextConfigLocation--&gt;</span><br><span class="line">    &lt;context-param&gt;</span><br><span class="line">        &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;</span><br><span class="line">        &lt;param-value&gt;</span><br><span class="line">            classpath:spring-context.xml</span><br><span class="line">        &lt;&#x2F;param-value&gt;</span><br><span class="line">    &lt;&#x2F;context-param&gt;</span><br></pre></td></tr></table></figure>

<p>spring的xml其实也可以放在其它地方进行加载，比如说listener，servlet中，例如springMVC的xml文件，会配置在servlet中，进行路由转发。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 请求转发器 --&gt;</span><br><span class="line">  &lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;dispatcher&lt;&#x2F;servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">      &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;</span><br><span class="line">      &lt;param-value&gt;classpath:spring-mvc.xml&lt;&#x2F;param-value&gt;</span><br><span class="line">    &lt;&#x2F;init-param&gt;</span><br><span class="line">    &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt;</span><br><span class="line">  &lt;&#x2F;servlet&gt;</span><br><span class="line">  &lt;servlet-mapping&gt;</span><br><span class="line">  &lt;servlet-name&gt;dispatcher&lt;&#x2F;servlet-name&gt;</span><br><span class="line">  &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt;</span><br><span class="line">  &lt;&#x2F;servlet-mapping&gt;</span><br></pre></td></tr></table></figure>

<p>如若此时在contextConfigLocation下增加classpath:spring-context.xml，spring同样也会去初始化配置文件。所以可以得出结论，springIOC环境的<br>初始化与web context的初始化顺序无直接关联。</p>
<p>那么问题来了，在listener，filter中获取WebApplicationContext可以获得spring bean吗？</p>
<p>我们先把spring-context.xml放在context-param中，让它在lister之前进行spring初始化，看看效果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   修改xml文件</span><br><span class="line">   &lt;context-param&gt;</span><br><span class="line">       &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;</span><br><span class="line">       &lt;param-value&gt;</span><br><span class="line">           classpath:spring-context.xml</span><br><span class="line">       &lt;&#x2F;param-value&gt;</span><br><span class="line">   &lt;&#x2F;context-param&gt;</span><br><span class="line">   </span><br><span class="line">修改自定义CustomListener   </span><br><span class="line">@Override</span><br><span class="line">   public void contextInitialized(ServletContextEvent servletContextEvent) &#123;</span><br><span class="line">       WebApplicationContext springContext &#x3D; WebApplicationContextUtils.getWebApplicationContext(servletContextEvent.getServletContext());</span><br><span class="line">       Init init &#x3D; (Init) springContext.getBean(&quot;init&quot;);</span><br><span class="line"></span><br><span class="line">       System.out.println(init);</span><br><span class="line">       System.out.println(&quot;listener init&quot;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>此时InitializingBean最先打印出来，说明其在listener，filter之前执行了。<br>控制台输出 com.wyb.web.config.Init@e082c17，说明在listen之前，spring的Context已经初始化，可以获取到bean，那么我们把spring-context.xml<br>放在servlet中去初始化，即在listener之后初始化会怎么样呢？</p>
<p>修改web.xml代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;dispatcher&lt;&#x2F;servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">      &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;</span><br><span class="line">      &lt;param-value&gt;classpath:spring-mvc.xml,classpath:spring-context.xml&lt;&#x2F;param-value&gt;</span><br><span class="line">    &lt;&#x2F;init-param&gt;</span><br><span class="line">    &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt;</span><br><span class="line">  &lt;&#x2F;servlet&gt;</span><br><span class="line">  &lt;servlet-mapping&gt;</span><br><span class="line">  &lt;servlet-name&gt;dispatcher&lt;&#x2F;servlet-name&gt;</span><br><span class="line">  &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt;</span><br><span class="line">  &lt;&#x2F;servlet-mapping&gt;</span><br></pre></td></tr></table></figure>

<p>此时InitializingBean最后打印，说明其在listener，filter之后执行了。<br>CustomListener抛出NoSuchBeanDefinitionException异常，即无法获得该实例，由此得出结论，spring bean的初始化顺序由配置文件在web.xml中什么时候加载有关，与listener，filter无直接关系。<br><strong>若listener想获得spring bean，该bean需要在listener之前<br>进行初始化</strong>。</p>
<p>两个spring bean之间进行相互注入依赖，则要看xml文件在web.xml进行加载的顺序。绝对了spring bean初始化的顺序。</p>
]]></content>
      <categories>
        <category>日常问题记录</category>
      </categories>
  </entry>
  <entry>
    <title>mybatis-plus 原理</title>
    <url>/2022/08/08/mybatis/mybatis-plus/</url>
    <content><![CDATA[<h3 id="MapperScan"><a href="#MapperScan" class="headerlink" title="@MapperScan"></a>@MapperScan</h3><p>@MapperScan的作用可以理解为@Import注解 + @MapperScan中配置的包名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span>(proxyTargetClass = <span class="keyword">true</span>, exposeProxy = <span class="keyword">true</span>)</span><br><span class="line"><span class="meta">@EnableFeignClients</span>(&#123;<span class="string">"com.***.***.common.proxy.api"</span>&#125;)</span><br><span class="line"><span class="meta">@EnableApolloConfig</span>(<span class="string">"application"</span>)</span><br><span class="line"><span class="meta">@MapperScan</span>(<span class="string">"com.***.***.backend.**.dao"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SopBackendApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SopBackendApplication<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SpringBoot启动时会记录启动类上的注解信息，然后Spring会通过ConfigurationClassPostProcessor解析对应的注解bean，<br>当获取到@MapperScan注解中有@Import注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(MapperScannerRegistrar<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">Repeatable</span>(<span class="title">MapperScans</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">MapperScan</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后会通过ConfigurationClassPostProcessor类把@Import中的MapperScannerRegistrar加入到Spring的启动逻辑中，<br>因为MapperScannerRegistrar实现了Spring的ImportBeanDefinitionRegistrar接口，所以会被调用到registerBeanDefinitions()方法。<br>而registerBeanDefinitions()方法的逻辑会判断类上面是否有@MapperScan注解，<br>有的话就会通过MapperScannerConfigurer扫描@MapperScan配置的目录，<br>通过ClassPathMapperScanner类扫描@Mapperscan配置目录下的所有加了@Repository注解的mapper，<br>并生成对应的beandefinition信息保存到spring容器中，<br>其中这些beandefinition的beanclass被设置成了MapperFactoryBean。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RepeatingRegistrar</span> <span class="keyword">extends</span> <span class="title">MapperScannerRegistrar</span> </span>&#123;</span><br><span class="line">    RepeatingRegistrar() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        AnnotationAttributes mapperScansAttrs = AnnotationAttributes.fromMap(importingClassMetadata.getAnnotationAttributes(MapperScans<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()))</span>;</span><br><span class="line">        <span class="keyword">if</span> (mapperScansAttrs != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Arrays.stream(mapperScansAttrs.getAnnotationArray(<span class="string">"value"</span>)).forEach((mapperScanAttrs) -&gt; &#123;</span><br><span class="line">                <span class="keyword">this</span>.registerBeanDefinitions(mapperScanAttrs, registry);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationAttributes annoAttrs, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        ClassPathMapperScanner scanner = <span class="keyword">new</span> ClassPathMapperScanner(registry);</span><br><span class="line">        Optional.ofNullable(<span class="keyword">this</span>.resourceLoader).ifPresent(scanner::setResourceLoader);</span><br><span class="line">        Class&lt;? extends Annotation&gt; annotationClass = annoAttrs.getClass(<span class="string">"annotationClass"</span>);</span><br><span class="line">        <span class="keyword">if</span> (!Annotation<span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">annotationClass</span>)) </span>&#123;</span><br><span class="line">            scanner.setAnnotationClass(annotationClass);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; markerInterface = annoAttrs.getClass(<span class="string">"markerInterface"</span>);</span><br><span class="line">        <span class="keyword">if</span> (!Class<span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">markerInterface</span>)) </span>&#123;</span><br><span class="line">            scanner.setMarkerInterface(markerInterface);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Class&lt;? extends BeanNameGenerator&gt; generatorClass = annoAttrs.getClass(<span class="string">"nameGenerator"</span>);</span><br><span class="line">        <span class="keyword">if</span> (!BeanNameGenerator<span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">generatorClass</span>)) </span>&#123;</span><br><span class="line">            scanner.setBeanNameGenerator((BeanNameGenerator) BeanUtils.instantiateClass(generatorClass));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Class&lt;? extends MapperFactoryBean&gt; mapperFactoryBeanClass = annoAttrs.getClass(<span class="string">"factoryBean"</span>);</span><br><span class="line">        <span class="keyword">if</span> (!MapperFactoryBean<span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">mapperFactoryBeanClass</span>)) </span>&#123;</span><br><span class="line">            scanner.setMapperFactoryBean((MapperFactoryBean) BeanUtils.instantiateClass(mapperFactoryBeanClass));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        scanner.setSqlSessionTemplateBeanName(annoAttrs.getString(<span class="string">"sqlSessionTemplateRef"</span>));</span><br><span class="line">        scanner.setSqlSessionFactoryBeanName(annoAttrs.getString(<span class="string">"sqlSessionFactoryRef"</span>));</span><br><span class="line">        List&lt;String&gt; basePackages = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        basePackages.addAll((Collection) Arrays.stream(annoAttrs.getStringArray(<span class="string">"value"</span>)).filter(StringUtils::hasText).collect(Collectors.toList()));</span><br><span class="line">        basePackages.addAll((Collection) Arrays.stream(annoAttrs.getStringArray(<span class="string">"basePackages"</span>)).filter(StringUtils::hasText).collect(Collectors.toList()));</span><br><span class="line">        basePackages.addAll((Collection) Arrays.stream(annoAttrs.getClassArray(<span class="string">"basePackageClasses"</span>)).map(ClassUtils::getPackageName).collect(Collectors.toList()));</span><br><span class="line">        scanner.registerFilters();</span><br><span class="line">        scanner.doScan(StringUtils.toStringArray(basePackages));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>doScan–&gt;processBeanDefinitions</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathMapperScanner</span> <span class="keyword">extends</span> <span class="title">ClassPathBeanDefinitionScanner</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processBeanDefinitions</span><span class="params">(Set&lt;BeanDefinitionHolder&gt; beanDefinitions)</span> </span>&#123;</span><br><span class="line">        GenericBeanDefinition definition;</span><br><span class="line">        <span class="keyword">for</span> (BeanDefinitionHolder holder : beanDefinitions) &#123;</span><br><span class="line">            definition = (GenericBeanDefinition) holder.getBeanDefinition();</span><br><span class="line">            String beanClassName = definition.getBeanClassName();</span><br><span class="line">            LOGGER.debug(() -&gt; <span class="string">"Creating MapperFactoryBean with name '"</span> + holder.getBeanName()</span><br><span class="line">                    + <span class="string">"' and '"</span> + beanClassName + <span class="string">"' mapperInterface"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// the mapper interface is the original class of the bean</span></span><br><span class="line">            <span class="comment">// but, the actual class of the bean is MapperFactoryBean</span></span><br><span class="line">            definition.getConstructorArgumentValues().addGenericArgumentValue(beanClassName); <span class="comment">// issue #59</span></span><br><span class="line">            definition.setBeanClass(<span class="keyword">this</span>.mapperFactoryBean.getClass());</span><br><span class="line"></span><br><span class="line">            definition.getPropertyValues().add(<span class="string">"addToConfig"</span>, <span class="keyword">this</span>.addToConfig);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> explicitFactoryUsed = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasText(<span class="keyword">this</span>.sqlSessionFactoryBeanName)) &#123;</span><br><span class="line">                definition.getPropertyValues().add(<span class="string">"sqlSessionFactory"</span>, <span class="keyword">new</span> RuntimeBeanReference(<span class="keyword">this</span>.sqlSessionFactoryBeanName));</span><br><span class="line">                explicitFactoryUsed = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.sqlSessionFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">                definition.getPropertyValues().add(<span class="string">"sqlSessionFactory"</span>, <span class="keyword">this</span>.sqlSessionFactory);</span><br><span class="line">                explicitFactoryUsed = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasText(<span class="keyword">this</span>.sqlSessionTemplateBeanName)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (explicitFactoryUsed) &#123;</span><br><span class="line">                    LOGGER.warn(() -&gt; <span class="string">"Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                definition.getPropertyValues().add(<span class="string">"sqlSessionTemplate"</span>, <span class="keyword">new</span> RuntimeBeanReference(<span class="keyword">this</span>.sqlSessionTemplateBeanName));</span><br><span class="line">                explicitFactoryUsed = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.sqlSessionTemplate != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (explicitFactoryUsed) &#123;</span><br><span class="line">                    LOGGER.warn(() -&gt; <span class="string">"Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                definition.getPropertyValues().add(<span class="string">"sqlSessionTemplate"</span>, <span class="keyword">this</span>.sqlSessionTemplate);</span><br><span class="line">                explicitFactoryUsed = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!explicitFactoryUsed) &#123;</span><br><span class="line">                LOGGER.debug(() -&gt; <span class="string">"Enabling autowire by type for MapperFactoryBean with name '"</span> + holder.getBeanName() + <span class="string">"'."</span>);</span><br><span class="line">                definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而MapperFactoryBean实现了spring的FactoryBean接口，当spring通过BeanDefinitionMap创建bean的过程中，<br>会调用MapperFactoryBean的getObject()方法生成xxxMapper接口的代理对象MybatisMapperProxy。<br>到此Mapper接口就可以有代理对象被调用了。</p>
<h3 id="xxxMapper-xml"><a href="#xxxMapper-xml" class="headerlink" title="xxxMapper.xml"></a>xxxMapper.xml</h3><p>MybatisPlusAutoConfiguration被spring解释的时候，通过调用sqlSessionFactory()方法，<br>加载默认路径下mapper.xml文件，保存到MappedStatement中，<br>包括查询类型，sql语句，参数信息等，通过namespace和mapper对应上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Accessors</span>(chain = <span class="keyword">true</span>)</span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = Constants.MYBATIS_PLUS)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisPlusProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String[] mapperLocations = <span class="keyword">new</span> String[]&#123;<span class="string">"classpath*:/mapper/**/*.xml"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Resource[] resolveMapperLocations() &#123;</span><br><span class="line">        <span class="keyword">return</span> Stream.of(Optional.ofNullable(<span class="keyword">this</span>.mapperLocations).orElse(<span class="keyword">new</span> String[<span class="number">0</span>]))</span><br><span class="line">                .flatMap(location -&gt; Stream.of(getResources(location)))</span><br><span class="line">                .toArray(Resource[]::<span class="keyword">new</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Resource[] getResources(String location) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> resourceResolver.getResources(location);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Resource[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisSqlSessionFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">SqlSessionFactory</span>&gt;, <span class="title">InitializingBean</span>, <span class="title">ApplicationListener</span>&lt;<span class="title">ApplicationEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.mapperLocations !=<span class="keyword">null</span>)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.mapperLocations.length == <span class="number">0</span>) &#123;</span><br><span class="line">            LOGGER.warn(() -&gt; <span class="string">"Property 'mapperLocations' was specified but matching resources are not found."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Resource mapperLocation : <span class="keyword">this</span>.mapperLocations) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mapperLocation == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//解析xml文件，生成MapperStatement</span></span><br><span class="line">                    XMLMapperBuilder xmlMapperBuilder = <span class="keyword">new</span> XMLMapperBuilder(mapperLocation.getInputStream(),</span><br><span class="line">                            targetConfiguration, mapperLocation.toString(), targetConfiguration.getSqlFragments());</span><br><span class="line">                    xmlMapperBuilder.parse();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NestedIOException(<span class="string">"Failed to parse mapping resource: '"</span> + mapperLocation + <span class="string">"'"</span>, e);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    ErrorContext.instance().reset();</span><br><span class="line">                &#125;</span><br><span class="line">                LOGGER.debug(() -&gt; <span class="string">"Parsed mapper file: '"</span> + mapperLocation + <span class="string">"'"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BaseMapper"><a href="#BaseMapper" class="headerlink" title="BaseMapper"></a>BaseMapper<T></T></h3><p>BaseMapper，继承了该接口后，无需编写mapper.xml文件，即可以获得CRUD功能，那么MyBatis-Plus又是如何做到无需配置mapper.xml就能获得CRUD功能呢？<br>答案就是通过sql注入器AbstractSqlInjector自己生成sql。</p>
<h3 id="TableName"><a href="#TableName" class="headerlink" title="@TableName"></a>@TableName</h3><p>在AbstractSqlInject中inspectInject方法会获取BaseMapper<T>中的泛型类型，然后获取Entity上@tableName配置的表名以及@TableField注解字段的信息。</T></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SqlMethod &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    INSERT_ONE(<span class="string">"insert"</span>, <span class="string">"插入一条数据（选择字段插入）"</span>, <span class="string">"&lt;script&gt;\nINSERT INTO %s %s VALUES %s\n&lt;/script&gt;"</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractSqlInjector</span> <span class="keyword">implements</span> <span class="title">ISqlInjector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(AbstractSqlInjector<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inspectInject</span><span class="params">(MapperBuilderAssistant builderAssistant, Class&lt;?&gt; mapperClass)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//  获取BaseMapper中的泛型类型，，通过TableName获取mapper关联的是哪个表</span></span><br><span class="line">        Class&lt;?&gt; modelClass = extractModelClass(mapperClass);</span><br><span class="line">        <span class="keyword">if</span> (modelClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String className = mapperClass.toString();</span><br><span class="line">            Set&lt;String&gt; mapperRegistryCache = GlobalConfigUtils.getMapperRegistryCache(builderAssistant.getConfiguration());</span><br><span class="line">            <span class="keyword">if</span> (!mapperRegistryCache.contains(className)) &#123;</span><br><span class="line">                List&lt;AbstractMethod&gt; methodList = <span class="keyword">this</span>.getMethodList(mapperClass);</span><br><span class="line">                <span class="keyword">if</span> (CollectionUtils.isNotEmpty(methodList)) &#123;</span><br><span class="line">                    TableInfo tableInfo = TableInfoHelper.initTableInfo(builderAssistant, modelClass);</span><br><span class="line">                    <span class="comment">// 循环注入自定义方法</span></span><br><span class="line">                    methodList.forEach(m -&gt; m.inject(builderAssistant, mapperClass, modelClass, tableInfo));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    logger.debug(mapperClass.toString() + <span class="string">", No effective injection method was found."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                mapperRegistryCache.add(className);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TableInfoHelper</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 实体类反射获取表信息【初始化】</span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz 反射实体类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 数据库表反射信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> TableInfo <span class="title">initTableInfo</span><span class="params">(MapperBuilderAssistant builderAssistant, Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">        TableInfo tableInfo = TABLE_INFO_CACHE.get(clazz);</span><br><span class="line">        <span class="keyword">if</span> (tableInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (builderAssistant != <span class="keyword">null</span>) &#123;</span><br><span class="line">                tableInfo.setConfiguration(builderAssistant.getConfiguration());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> tableInfo;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 没有获取到缓存信息,则初始化 */</span></span><br><span class="line">        tableInfo = <span class="keyword">new</span> TableInfo(clazz);</span><br><span class="line">        GlobalConfig globalConfig;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != builderAssistant) &#123;</span><br><span class="line">            tableInfo.setCurrentNamespace(builderAssistant.getCurrentNamespace());</span><br><span class="line">            tableInfo.setConfiguration(builderAssistant.getConfiguration());</span><br><span class="line">            globalConfig = GlobalConfigUtils.getGlobalConfig(builderAssistant.getConfiguration());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 兼容测试场景</span></span><br><span class="line">            globalConfig = GlobalConfigUtils.defaults();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 初始化表名相关 */</span></span><br><span class="line">        initTableName(clazz, globalConfig, tableInfo);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 初始化字段相关 */</span></span><br><span class="line">        initTableFields(clazz, globalConfig, tableInfo);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 放入缓存 */</span></span><br><span class="line">        TABLE_INFO_CACHE.put(clazz, tableInfo);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 缓存 lambda */</span></span><br><span class="line">        LambdaUtils.installCache(tableInfo);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 自动构建 resultMap */</span></span><br><span class="line">        tableInfo.initResultMapIfNeed();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tableInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 初始化 表数据库类型,表名,resultMap</span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz        实体类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> globalConfig 全局配置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableInfo    数据库表反射信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initTableName</span><span class="params">(Class&lt;?&gt; clazz, GlobalConfig globalConfig, TableInfo tableInfo)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* 数据库全局配置 */</span></span><br><span class="line">        GlobalConfig.DbConfig dbConfig = globalConfig.getDbConfig();</span><br><span class="line">        TableName table = clazz.getAnnotation(TableName<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        String tableName = clazz.getSimpleName();</span><br><span class="line">        String tablePrefix = dbConfig.getTablePrefix();</span><br><span class="line">        String schema = dbConfig.getSchema();</span><br><span class="line">        <span class="keyword">boolean</span> tablePrefixEffect = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (table != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isNotEmpty(table.value())) &#123;</span><br><span class="line">                tableName = table.value();</span><br><span class="line">                <span class="keyword">if</span> (StringUtils.isNotEmpty(tablePrefix) &amp;&amp; !table.keepGlobalPrefix()) &#123;</span><br><span class="line">                    tablePrefixEffect = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tableName = initTableNameWithDbConfig(tableName, dbConfig);</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
  </entry>
  <entry>
    <title>数据库系统原理(转载)</title>
    <url>/2019/04/12/database/1.%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md" target="_blank" rel="noopener">原文</a></p>
<ul>
<li><a href="#一事务">一、事务</a><ul>
<li><a href="#概念">概念</a></li>
<li><a href="#acid">ACID</a></li>
<li><a href="#autocommit">AUTOCOMMIT</a></li>
</ul>
</li>
<li><a href="#二并发一致性问题">二、并发一致性问题</a><ul>
<li><a href="#丢失修改">丢失修改</a></li>
<li><a href="#读脏数据">读脏数据</a></li>
<li><a href="#不可重复读">不可重复读</a></li>
<li><a href="#幻影读">幻影读</a></li>
</ul>
</li>
<li><a href="#三封锁">三、封锁</a><ul>
<li><a href="#封锁粒度">封锁粒度</a></li>
<li><a href="#封锁类型">封锁类型</a></li>
<li><a href="#封锁协议">封锁协议</a></li>
<li><a href="#mysql-隐式与显示锁定">MySQL 隐式与显示锁定</a></li>
</ul>
</li>
<li><a href="#四隔离级别">四、隔离级别</a><ul>
<li><a href="#未提交读read-uncommitted">未提交读（READ UNCOMMITTED）</a></li>
<li><a href="#提交读read-committed">提交读（READ COMMITTED）</a></li>
<li><a href="#可重复读repeatable-read">可重复读（REPEATABLE READ）</a></li>
<li><a href="#可串行化serializable">可串行化（SERIALIZABLE）</a></li>
</ul>
</li>
<li><a href="#五多版本并发控制">五、多版本并发控制</a><ul>
<li><a href="#版本号">版本号</a></li>
<li><a href="#隐藏的列">隐藏的列</a></li>
<li><a href="#undo-日志">Undo 日志</a></li>
<li><a href="#实现过程">实现过程</a></li>
<li><a href="#快照读与当前读">快照读与当前读</a></li>
</ul>
</li>
<li><a href="#六next-key-locks">六、Next-Key Locks</a><ul>
<li><a href="#record-locks">Record Locks</a></li>
<li><a href="#gap-locks">Gap Locks</a></li>
<li><a href="#next-key-locks">Next-Key Locks</a></li>
</ul>
</li>
<li><a href="#七关系数据库设计理论">七、关系数据库设计理论</a><ul>
<li><a href="#函数依赖">函数依赖</a></li>
<li><a href="#异常">异常</a></li>
<li><a href="#范式">范式</a></li>
</ul>
</li>
<li><a href="#八er-图">八、ER 图</a><ul>
<li><a href="#实体的三种联系">实体的三种联系</a></li>
<li><a href="#表示出现多次的关系">表示出现多次的关系</a></li>
<li><a href="#联系的多向性">联系的多向性</a></li>
<li><a href="#表示子类">表示子类</a></li>
</ul>
</li>
<li><a href="#参考资料">参考资料</a><!-- GFM-TOC -->


</li>
</ul>
<h1 id="一、事务"><a href="#一、事务" class="headerlink" title="一、事务"></a>一、事务</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。</p>
<div align="center"> <img src="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/f74144be-857a-40cd-8ec7-87626ef4e20b.png"> </div><br>

<h2 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h2><h3 id="1-原子性（Atomicity）"><a href="#1-原子性（Atomicity）" class="headerlink" title="1. 原子性（Atomicity）"></a>1. 原子性（Atomicity）</h3><p>事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。</p>
<p>回滚可以用回滚日志来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</p>
<h3 id="2-一致性（Consistency）"><a href="#2-一致性（Consistency）" class="headerlink" title="2. 一致性（Consistency）"></a>2. 一致性（Consistency）</h3><p>数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。</p>
<h3 id="3-隔离性（Isolation）"><a href="#3-隔离性（Isolation）" class="headerlink" title="3. 隔离性（Isolation）"></a>3. 隔离性（Isolation）</h3><p>一个事务所做的修改在最终提交以前，对其它事务是不可见的。</p>
<h3 id="4-持久性（Durability）"><a href="#4-持久性（Durability）" class="headerlink" title="4. 持久性（Durability）"></a>4. 持久性（Durability）</h3><p>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。</p>
<p>使用重做日志来保证持久性。</p>
<hr>
<p>事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系：</p>
<ul>
<li>只有满足一致性，事务的执行结果才是正确的。</li>
<li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。</li>
<li>在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</li>
<li>事务满足持久化是为了能应对数据库崩溃的情况。</li>
</ul>
<div align="center"> <img src="https://github.com//CyC2018/CS-Notes/raw/master/notes/pics/417bc315-4409-48c6-83e0-59e8d405429e.jpg" width="700"> </div><br>

<h2 id="AUTOCOMMIT"><a href="#AUTOCOMMIT" class="headerlink" title="AUTOCOMMIT"></a>AUTOCOMMIT</h2><p>MySQL 默认采用自动提交模式。也就是说，如果不显式使用<code>START TRANSACTION</code>语句来开始一个事务，那么每个查询都会被当做一个事务自动提交。</p>
<h1 id="二、并发一致性问题"><a href="#二、并发一致性问题" class="headerlink" title="二、并发一致性问题"></a>二、并发一致性问题</h1><p>在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。</p>
<h2 id="丢失修改"><a href="#丢失修改" class="headerlink" title="丢失修改"></a>丢失修改</h2><p>T<sub>1</sub> 和 T<sub>2</sub> 两个事务都对一个数据进行修改，T<sub>1</sub> 先修改，T<sub>2</sub> 随后修改，T<sub>2</sub> 的修改覆盖了 T<sub>1</sub> 的修改。</p>
<div align="center"> <img src="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/75184b58-c627-4edc-8dcf-605762ebb733.png" width="350"> </div><br>

<h2 id="读脏数据"><a href="#读脏数据" class="headerlink" title="读脏数据"></a>读脏数据</h2><p>T<sub>1</sub> 修改一个数据，T<sub>2</sub> 随后读取这个数据。如果 T<sub>1</sub> 撤销了这次修改，那么 T<sub>2</sub> 读取的数据是脏数据。</p>
<div align="center"> <img src="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/af0e94d9-502d-4531-938f-d46dd29de52d.png" width="400"> </div><br>

<h2 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h2><p>T<sub>2</sub> 读取一个数据，T<sub>1</sub> 对该数据做了修改。如果 T<sub>2</sub> 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p>
<div align="center"> <img src="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/66ae164c-ad47-4905-895e-51fe38ce797a.png" width="400"> </div><br>


<h2 id="幻影读"><a href="#幻影读" class="headerlink" title="幻影读"></a>幻影读</h2><p>T<sub>1</sub> 读取某个范围的数据，T<sub>2</sub> 在这个范围内插入新的数据，T<sub>1</sub> 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</p>
<div align="center"> <img src="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/8fdc577d-552d-4b43-b5e4-a8f98bc2cb51.png" width="400"> </div><br>


<hr>
<p>产生并发不一致性问题主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。</p>
<h1 id="三、封锁"><a href="#三、封锁" class="headerlink" title="三、封锁"></a>三、封锁</h1><h2 id="封锁粒度"><a href="#封锁粒度" class="headerlink" title="封锁粒度"></a>封锁粒度</h2><p>MySQL 中提供了两种封锁粒度：行级锁以及表级锁。</p>
<p>应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。</p>
<p>但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。</p>
<p>在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。</p>
<div align="center"> <img src="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/1a851e90-0d5c-4d4f-ac54-34c20ecfb903.jpg" width="300"> </div><br>

<h2 id="封锁类型"><a href="#封锁类型" class="headerlink" title="封锁类型"></a>封锁类型</h2><h3 id="1-读写锁"><a href="#1-读写锁" class="headerlink" title="1. 读写锁"></a>1. 读写锁</h3><ul>
<li>排它锁（Exclusive），简写为 X 锁，又称写锁。</li>
<li>共享锁（Shared），简写为 S 锁，又称读锁。</li>
</ul>
<p>有以下两个规定：</p>
<ul>
<li>一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。</li>
<li>一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。</li>
</ul>
<p>锁的兼容关系如下：</p>
<table>
<thead>
<tr>
<th align="center">-</th>
<th align="center">X</th>
<th align="center">S</th>
</tr>
</thead>
<tbody><tr>
<td align="center">X</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">S</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
</tbody></table>
<h3 id="2-意向锁"><a href="#2-意向锁" class="headerlink" title="2. 意向锁"></a>2. 意向锁</h3><p>使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。</p>
<p>在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。</p>
<p>意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：</p>
<ul>
<li>一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；</li>
<li>一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。</li>
</ul>
<p>通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。</p>
<p>各种锁的兼容关系如下：</p>
<table>
<thead>
<tr>
<th align="center">-</th>
<th align="center">X</th>
<th align="center">IX</th>
<th align="center">S</th>
<th align="center">IS</th>
</tr>
</thead>
<tbody><tr>
<td align="center">X</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">IX</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">S</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">IS</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
</tbody></table>
<p>解释如下：</p>
<ul>
<li>任意 IS/IX 锁之间都是兼容的，因为它们只是表示想要对表加锁，而不是真正加锁；</li>
<li>S 锁只与 S 锁和 IS 锁兼容，也就是说事务 T 想要对数据行加 S 锁，其它事务可以已经获得对表或者表中的行的 S 锁。</li>
</ul>
<h2 id="封锁协议"><a href="#封锁协议" class="headerlink" title="封锁协议"></a>封锁协议</h2><h3 id="1-三级封锁协议"><a href="#1-三级封锁协议" class="headerlink" title="1. 三级封锁协议"></a>1. 三级封锁协议</h3><p><strong>一级封锁协议</strong> </p>
<p>事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。</p>
<p>可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。</p>
<table>
<thead>
<tr>
<th align="center">T<sub>1</sub></th>
<th align="center">T<sub>2</sub></th>
</tr>
</thead>
<tbody><tr>
<td align="center">lock-x(A)</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">read A=20</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">lock-x(A)</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">wait</td>
</tr>
<tr>
<td align="center">write A=19</td>
<td align="center">.</td>
</tr>
<tr>
<td align="center">commit</td>
<td align="center">.</td>
</tr>
<tr>
<td align="center">unlock-x(A)</td>
<td align="center">.</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">obtain</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">read A=19</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">write A=21</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">commit</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">unlock-x(A)</td>
</tr>
</tbody></table>
<p><strong>二级封锁协议</strong> </p>
<p>在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。</p>
<p>可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。</p>
<table>
<thead>
<tr>
<th align="center">T<sub>1</sub></th>
<th align="center">T<sub>2</sub></th>
</tr>
</thead>
<tbody><tr>
<td align="center">lock-x(A)</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">read A=20</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">write A=19</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">lock-s(A)</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">wait</td>
</tr>
<tr>
<td align="center">rollback</td>
<td align="center">.</td>
</tr>
<tr>
<td align="center">A=20</td>
<td align="center">.</td>
</tr>
<tr>
<td align="center">unlock-x(A)</td>
<td align="center">.</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">obtain</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">read A=20</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">unlock-s(A)</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">commit</td>
</tr>
</tbody></table>
<p><strong>三级封锁协议</strong> </p>
<p>在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。</p>
<p>可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。</p>
<table>
<thead>
<tr>
<th align="center">T<sub>1</sub></th>
<th align="center">T<sub>2</sub></th>
</tr>
</thead>
<tbody><tr>
<td align="center">lock-s(A)</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">read A=20</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">lock-x(A)</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">wait</td>
</tr>
<tr>
<td align="center">read A=20</td>
<td align="center">.</td>
</tr>
<tr>
<td align="center">commit</td>
<td align="center">.</td>
</tr>
<tr>
<td align="center">unlock-s(A)</td>
<td align="center">.</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">obtain</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">read A=20</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">write A=19</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">commit</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">unlock-X(A)</td>
</tr>
</tbody></table>
<h3 id="2-两段锁协议"><a href="#2-两段锁协议" class="headerlink" title="2. 两段锁协议"></a>2. 两段锁协议</h3><p>加锁和解锁分为两个阶段进行。</p>
<p>可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。</p>
<p>事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)</span><br></pre></td></tr></table></figure>

<p>但不是必要条件，例如以下操作不满足两段锁协议，但是它还是可串行化调度。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)</span><br></pre></td></tr></table></figure>

<h2 id="MySQL-隐式与显示锁定"><a href="#MySQL-隐式与显示锁定" class="headerlink" title="MySQL 隐式与显示锁定"></a>MySQL 隐式与显示锁定</h2><p>MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。</p>
<p>InnoDB 也可以使用特定的语句进行显示锁定：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">LOCK</span> <span class="keyword">In</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<h1 id="四、隔离级别"><a href="#四、隔离级别" class="headerlink" title="四、隔离级别"></a>四、隔离级别</h1><h2 id="未提交读（READ-UNCOMMITTED）"><a href="#未提交读（READ-UNCOMMITTED）" class="headerlink" title="未提交读（READ UNCOMMITTED）"></a>未提交读（READ UNCOMMITTED）</h2><p>事务中的修改，即使没有提交，对其它事务也是可见的。</p>
<h2 id="提交读（READ-COMMITTED）"><a href="#提交读（READ-COMMITTED）" class="headerlink" title="提交读（READ COMMITTED）"></a>提交读（READ COMMITTED）</h2><p>一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。</p>
<h2 id="可重复读（REPEATABLE-READ）"><a href="#可重复读（REPEATABLE-READ）" class="headerlink" title="可重复读（REPEATABLE READ）"></a>可重复读（REPEATABLE READ）</h2><p>保证在同一个事务中多次读取同样数据的结果是一样的。</p>
<h2 id="可串行化（SERIALIZABLE）"><a href="#可串行化（SERIALIZABLE）" class="headerlink" title="可串行化（SERIALIZABLE）"></a>可串行化（SERIALIZABLE）</h2><p>强制事务串行执行。</p>
<hr>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻影读</th>
<th align="center">加锁读</th>
</tr>
</thead>
<tbody><tr>
<td align="center">未提交读</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">提交读</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">可重复读</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">可串行化</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
</tbody></table>
<h1 id="五、多版本并发控制"><a href="#五、多版本并发控制" class="headerlink" title="五、多版本并发控制"></a>五、多版本并发控制</h1><p>多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。</p>
<h2 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h2><ul>
<li>系统版本号：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。</li>
<li>事务版本号：事务开始时的系统版本号。</li>
</ul>
<h2 id="隐藏的列"><a href="#隐藏的列" class="headerlink" title="隐藏的列"></a>隐藏的列</h2><p>MVCC 在每行记录后面都保存着两个隐藏的列，用来存储两个版本号：</p>
<ul>
<li>创建版本号：指示创建一个数据行的快照时的系统版本号；</li>
<li>删除版本号：如果该快照的删除版本号大于当前事务版本号表示该快照有效，否则表示该快照已经被删除了。</li>
</ul>
<h2 id="Undo-日志"><a href="#Undo-日志" class="headerlink" title="Undo 日志"></a>Undo 日志</h2><p>MVCC 使用到的快照存储在 Undo 日志中，该日志通过回滚指针把一个数据行（Record）的所有快照连接起来。</p>
<div align="center"> <img src="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/e41405a8-7c05-4f70-8092-e961e28d3112.jpg" width> </div><br>

<h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><p>以下实现过程针对可重复读隔离级别。</p>
<p>当开始新一个事务时，该事务的版本号肯定会大于当前所有数据行快照的创建版本号，理解这一点很关键。</p>
<h3 id="1-SELECT"><a href="#1-SELECT" class="headerlink" title="1. SELECT"></a>1. SELECT</h3><p>多个事务必须读取到同一个数据行的快照，并且这个快照是距离现在最近的一个有效快照。但是也有例外，如果有一个事务正在修改该数据行，那么它可以读取事务本身所做的修改，而不用和其它事务的读取结果一致。</p>
<p>把没有对一个数据行做修改的事务称为 T，T 所要读取的数据行快照的创建版本号必须小于 T 的版本号，因为如果大于或者等于 T 的版本号，那么表示该数据行快照是其它事务的最新修改，因此不能去读取它。除此之外，T 所要读取的数据行快照的删除版本号必须大于 T 的版本号，因为如果小于等于 T 的版本号，那么表示该数据行快照是已经被删除的，不应该去读取它。</p>
<h3 id="2-INSERT"><a href="#2-INSERT" class="headerlink" title="2. INSERT"></a>2. INSERT</h3><p>将当前系统版本号作为数据行快照的创建版本号。</p>
<h3 id="3-DELETE"><a href="#3-DELETE" class="headerlink" title="3. DELETE"></a>3. DELETE</h3><p>将当前系统版本号作为数据行快照的删除版本号。</p>
<h3 id="4-UPDATE"><a href="#4-UPDATE" class="headerlink" title="4. UPDATE"></a>4. UPDATE</h3><p>将当前系统版本号作为更新前的数据行快照的删除版本号，并将当前系统版本号作为更新后的数据行快照的创建版本号。可以理解为先执行 DELETE 后执行 INSERT。</p>
<h2 id="快照读与当前读"><a href="#快照读与当前读" class="headerlink" title="快照读与当前读"></a>快照读与当前读</h2><h3 id="1-快照读"><a href="#1-快照读" class="headerlink" title="1. 快照读"></a>1. 快照读</h3><p>使用 MVCC 读取的是快照中的数据，这样可以减少加锁所带来的开销。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> ...;</span><br></pre></td></tr></table></figure>

<h3 id="2-当前读"><a href="#2-当前读" class="headerlink" title="2. 当前读"></a>2. 当前读</h3><p>读取的是最新的数据，需要加锁。以下第一个语句需要加 S 锁，其它都需要加 X 锁。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ? <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ? <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">insert</span>;</span><br><span class="line"><span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure>

<h1 id="六、Next-Key-Locks"><a href="#六、Next-Key-Locks" class="headerlink" title="六、Next-Key Locks"></a>六、Next-Key Locks</h1><p>Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现。</p>
<p>MVCC 不能解决幻读的问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。</p>
<h2 id="Record-Locks"><a href="#Record-Locks" class="headerlink" title="Record Locks"></a>Record Locks</h2><p>锁定一个记录上的索引，而不是记录本身。</p>
<p>如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。</p>
<h2 id="Gap-Locks"><a href="#Gap-Locks" class="headerlink" title="Gap Locks"></a>Gap Locks</h2><p>锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> c <span class="keyword">BETWEEN</span> <span class="number">10</span> <span class="keyword">and</span> <span class="number">20</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<h2 id="Next-Key-Locks"><a href="#Next-Key-Locks" class="headerlink" title="Next-Key Locks"></a>Next-Key Locks</h2><p>它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">(negative infinity, 10]</span><br><span class="line">(10, 11]</span><br><span class="line">(11, 13]</span><br><span class="line">(13, 20]</span><br><span class="line">(20, positive infinity)</span><br></pre></td></tr></table></figure>

<h1 id="七、关系数据库设计理论"><a href="#七、关系数据库设计理论" class="headerlink" title="七、关系数据库设计理论"></a>七、关系数据库设计理论</h1><h2 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h2><p>记 A-&gt;B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。</p>
<p>如果 {A1，A2，… ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。</p>
<p>对于 A-&gt;B，如果能找到 A 的真子集 A’，使得 A’-&gt; B，那么 A-&gt;B 就是部分函数依赖，否则就是完全函数依赖。</p>
<p>对于 A-&gt;B，B-&gt;C，则 A-&gt;C 是一个传递函数依赖。</p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>以下的学生课程关系的函数依赖为 Sno, Cname -&gt; Sname, Sdept, Mname, Grade，键码为 {Sno, Cname}。也就是说，确定学生和课程之后，就能确定其它信息。</p>
<table>
<thead>
<tr>
<th align="center">Sno</th>
<th align="center">Sname</th>
<th align="center">Sdept</th>
<th align="center">Mname</th>
<th align="center">Cname</th>
<th align="center">Grade</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">学生-1</td>
<td align="center">学院-1</td>
<td align="center">院长-1</td>
<td align="center">课程-1</td>
<td align="center">90</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">学生-2</td>
<td align="center">学院-2</td>
<td align="center">院长-2</td>
<td align="center">课程-2</td>
<td align="center">80</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">学生-2</td>
<td align="center">学院-2</td>
<td align="center">院长-2</td>
<td align="center">课程-1</td>
<td align="center">100</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">学生-3</td>
<td align="center">学院-2</td>
<td align="center">院长-2</td>
<td align="center">课程-2</td>
<td align="center">95</td>
</tr>
</tbody></table>
<p>不符合范式的关系，会产生很多异常，主要有以下四种异常：</p>
<ul>
<li>冗余数据：例如 <code>学生-2</code> 出现了两次。</li>
<li>修改异常：修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。</li>
<li>删除异常：删除一个信息，那么也会丢失其它信息。例如删除了 <code>课程-1</code> 需要删除第一行和第三行，那么 <code>学生-1</code> 的信息就会丢失。</li>
<li>插入异常：例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。</li>
</ul>
<h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><p>范式理论是为了解决以上提到四种异常。</p>
<p>高级别范式的依赖于低级别的范式，1NF 是最低级别的范式。</p>
<div align="center"> <img src="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/c2d343f7-604c-4856-9a3c-c71d6f67fecc.png" width="300"> </div><br>

<h3 id="1-第一范式-1NF"><a href="#1-第一范式-1NF" class="headerlink" title="1. 第一范式 (1NF)"></a>1. 第一范式 (1NF)</h3><p>属性不可分。</p>
<h3 id="2-第二范式-2NF"><a href="#2-第二范式-2NF" class="headerlink" title="2. 第二范式 (2NF)"></a>2. 第二范式 (2NF)</h3><p>每个非主属性完全函数依赖于键码。</p>
<p>可以通过分解来满足。</p>
<p><font size="4"> <strong>分解前</strong> </font><br></p>
<table>
<thead>
<tr>
<th align="center">Sno</th>
<th align="center">Sname</th>
<th align="center">Sdept</th>
<th align="center">Mname</th>
<th align="center">Cname</th>
<th align="center">Grade</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">学生-1</td>
<td align="center">学院-1</td>
<td align="center">院长-1</td>
<td align="center">课程-1</td>
<td align="center">90</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">学生-2</td>
<td align="center">学院-2</td>
<td align="center">院长-2</td>
<td align="center">课程-2</td>
<td align="center">80</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">学生-2</td>
<td align="center">学院-2</td>
<td align="center">院长-2</td>
<td align="center">课程-1</td>
<td align="center">100</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">学生-3</td>
<td align="center">学院-2</td>
<td align="center">院长-2</td>
<td align="center">课程-2</td>
<td align="center">95</td>
</tr>
</tbody></table>
<p>以上学生课程关系中，{Sno, Cname} 为键码，有如下函数依赖：</p>
<ul>
<li>Sno -&gt; Sname, Sdept</li>
<li>Sdept -&gt; Mname</li>
<li>Sno, Cname-&gt; Grade</li>
</ul>
<p>Grade 完全函数依赖于键码，它没有任何冗余数据，每个学生的每门课都有特定的成绩。</p>
<p>Sname, Sdept 和 Mname 都部分依赖于键码，当一个学生选修了多门课时，这些数据就会出现多次，造成大量冗余数据。</p>
<p><font size="4"> <strong>分解后</strong> </font><br></p>
<p>关系-1</p>
<table>
<thead>
<tr>
<th align="center">Sno</th>
<th align="center">Sname</th>
<th align="center">Sdept</th>
<th align="center">Mname</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">学生-1</td>
<td align="center">学院-1</td>
<td align="center">院长-1</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">学生-2</td>
<td align="center">学院-2</td>
<td align="center">院长-2</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">学生-3</td>
<td align="center">学院-2</td>
<td align="center">院长-2</td>
</tr>
</tbody></table>
<p>有以下函数依赖：</p>
<ul>
<li>Sno -&gt; Sname, Sdept</li>
<li>Sdept -&gt; Mname</li>
</ul>
<p>关系-2</p>
<table>
<thead>
<tr>
<th align="center">Sno</th>
<th align="center">Cname</th>
<th align="center">Grade</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">课程-1</td>
<td align="center">90</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">课程-2</td>
<td align="center">80</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">课程-1</td>
<td align="center">100</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">课程-2</td>
<td align="center">95</td>
</tr>
</tbody></table>
<p>有以下函数依赖：</p>
<ul>
<li>Sno, Cname -&gt;  Grade</li>
</ul>
<h3 id="3-第三范式-3NF"><a href="#3-第三范式-3NF" class="headerlink" title="3. 第三范式 (3NF)"></a>3. 第三范式 (3NF)</h3><p>非主属性不传递函数依赖于键码。</p>
<p>上面的 关系-1 中存在以下传递函数依赖：</p>
<ul>
<li>Sno -&gt; Sdept -&gt; Mname</li>
</ul>
<p>可以进行以下分解：</p>
<p>关系-11</p>
<table>
<thead>
<tr>
<th align="center">Sno</th>
<th align="center">Sname</th>
<th align="center">Sdept</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">学生-1</td>
<td align="center">学院-1</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">学生-2</td>
<td align="center">学院-2</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">学生-3</td>
<td align="center">学院-2</td>
</tr>
</tbody></table>
<p>关系-12</p>
<table>
<thead>
<tr>
<th align="center">Sdept</th>
<th align="center">Mname</th>
</tr>
</thead>
<tbody><tr>
<td align="center">学院-1</td>
<td align="center">院长-1</td>
</tr>
<tr>
<td align="center">学院-2</td>
<td align="center">院长-2</td>
</tr>
</tbody></table>
<h1 id="八、ER-图"><a href="#八、ER-图" class="headerlink" title="八、ER 图"></a>八、ER 图</h1><p>Entity-Relationship，有三个组成部分：实体、属性、联系。</p>
<p>用来进行关系型数据库系统的概念设计。</p>
<h2 id="实体的三种联系"><a href="#实体的三种联系" class="headerlink" title="实体的三种联系"></a>实体的三种联系</h2><p>包含一对一，一对多，多对多三种。</p>
<ul>
<li>如果 A 到 B 是一对多关系，那么画个带箭头的线段指向 B；</li>
<li>如果是一对一，画两个带箭头的线段；</li>
<li>如果是多对多，画两个不带箭头的线段。</li>
</ul>
<p>下图的 Course 和 Student 是一对多的关系。</p>
<div align="center"> <img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/pics/292b4a35-4507-4256-84ff-c218f108ee31.jpg" width> </div><br>

<h2 id="表示出现多次的关系"><a href="#表示出现多次的关系" class="headerlink" title="表示出现多次的关系"></a>表示出现多次的关系</h2><p>一个实体在联系出现几次，就要用几条线连接。</p>
<p>下图表示一个课程的先修关系，先修关系出现两个 Course 实体，第一个是先修课程，后一个是后修课程，因此需要用两条线来表示这种关系。</p>
<div align="center"> <img src="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/8b798007-e0fb-420c-b981-ead215692417.jpg" width> </div><br>

<h2 id="联系的多向性"><a href="#联系的多向性" class="headerlink" title="联系的多向性"></a>联系的多向性</h2><p>虽然老师可以开设多门课，并且可以教授多名学生，但是对于特定的学生和课程，只有一个老师教授，这就构成了一个三元联系。</p>
<div align="center"> <img src="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/423f2a40-bee1-488e-b460-8e76c48ee560.png" width> </div><br>

<p>一般只使用二元联系，可以把多元联系转换为二元联系。</p>
<div align="center"> <img src="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/de9b9ea0-1327-4865-93e5-6f805c48bc9e.png" width> </div><br>

<h2 id="表示子类"><a href="#表示子类" class="headerlink" title="表示子类"></a>表示子类</h2><p>用一个三角形和两条线来连接类和子类，与子类有关的属性和联系都连到子类上，而与父类和子类都有关的连到父类上。</p>
<div align="center"> <img src="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/7ec9d619-fa60-4a2b-95aa-bf1a62aad408.jpg" width> </div><br>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li>AbrahamSilberschatz, HenryF.Korth, S.Sudarshan, 等. 数据库系统概念 [M]. 机械工业出版社, 2006.</li>
<li>施瓦茨. 高性能 MYSQL(第3版)[M]. 电子工业出版社, 2013.</li>
<li>史嘉权. 数据库系统概论[M]. 清华大学出版社有限公司, 2006.</li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-storage-engine.html" target="_blank" rel="noopener">The InnoDB Storage Engine</a></li>
<li><a href="https://www.slideshare.net/ErnestoHernandezRodriguez/transaction-isolation-levels" target="_blank" rel="noopener">Transaction isolation levels</a></li>
<li><a href="http://scanftree.com/dbms/2-phase-locking-protocol" target="_blank" rel="noopener">Concurrency Control</a></li>
<li><a href="https://www.slideshare.net/brshristov/the-nightmare-of-locking-blocking-and-isolation-levels-46391666" target="_blank" rel="noopener">The Nightmare of Locking, Blocking and Isolation Levels!</a></li>
<li><a href="https://aksakalli.github.io/2012/03/12/database-normalization-and-normal-forms-with-an-example.html" target="_blank" rel="noopener">Database Normalization and Normal Forms with an Example</a></li>
<li><a href="https://blog.jcole.us/2014/04/16/the-basics-of-the-innodb-undo-logging-and-history-system/" target="_blank" rel="noopener">The basics of the InnoDB undo logging and history system</a></li>
<li><a href="https://www.brightbox.com/blog/2013/10/31/on-mysql-locks/" target="_blank" rel="noopener">MySQL locking for the busy web developer</a></li>
<li><a href="https://draveness.me/mysql-innodb" target="_blank" rel="noopener">浅入浅出 MySQL 和 InnoDB</a></li>
<li><a href="https://tech.meituan.com/2014/08/20/innodb-lock.html" target="_blank" rel="noopener">Innodb 中的事务隔离级别和锁的关系</a></li>
</ul>
]]></content>
      <categories>
        <category>database</category>
      </categories>
  </entry>
  <entry>
    <title>sql优化策略</title>
    <url>/2019/04/12/database/4.sqlOptimization/</url>
    <content><![CDATA[<h1 id="SQLOptimizationTree-SQL优化技术"><a href="#SQLOptimizationTree-SQL优化技术" class="headerlink" title="SQLOptimizationTree SQL优化技术"></a>SQLOptimizationTree SQL优化技术</h1><p><img src="https://i.imgur.com/tPBlMI3.png" alt></p>
<pre>
1) 最左前缀法则
2）在索引列上做类型转换，函数变换等操作
3）存储引擎不能使用范围条件右边的列作为索引
5）!= , > , < 不能使用索引
6）B-tree索引 is null不会走,is not null会走,位图索引 is null,is not null 都会走
7）like 通配符开头不能使用索引
8）尽量使用覆盖索引（只查询索引的列（索引列和查询列一致）），减少select *
9）没有使用查询条件，或者查询条件上没有建立索引
10）查询的数量是索引的大部分，30%以上
11）对小表查询
12）其他存储引擎认为使用索引反而查询性能更差时
13）in, not in ,not exist
15）在JOIN操作中（需要从多个数据表提取数据时），MYSQL只有在主键和外键的数据类型相同时才能使用索引，否则即使建立了索引也不会使用
16）在ORDER BY操作中，MYSQL只有在排序条件不是一个查询条件表达式的情况下才使用索引。尽管如此，在涉及多个数据表的查询里，即使有索引可用，那些索
引在加快ORDER BY操作方面也没什么作用
17）如果某个数据列里包含着许多重复的值，就算为它建立了索引也不会有很好的效果。比如说，如果某个数据列里包含了净是些诸如“0/1”或“Y/N”等值，就没有
必要为它创建一个索引
18）如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引
19）如果mysql估计使用全表扫描要比使用索引快,则不使用索引
20）尽量避免在where子句中使用or来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，可以使用 union来查询
21)如果在 where 子句中使用参数，也会导致全表扫描。因为 SQL 只有在运行时才会解析局部变
   量，但优化程序不能将访问计划的选择到运行时；它必须在编译时进行选择。然而，如果在编译时
   简历访问计划，变量的值还是未知的，因而无法作为索引选择的输入项
22)应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描
23)很多时候用 exists 代替 in 是一个好的选择
25)并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重
   复时，SQL查询可能不会去利用索引，如一表中有字段 sex，male、female几乎各一半，那么即
   使在sex上建了索引也对查询效率起不了作用。
26)尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性
   能，并会增加存储开销。这是因为引擎在处理查询和连接时会 逐个比较字符串中每一个字符，而
   对于数字型而言只需要比较一次就够了
27)尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以
   节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些
28)避免频繁创建和删除临时表，以减少系统表资源的消耗
29)尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写
30)尽量避免大事务操作，提高系统并发能力
</pre>

<h3 id="为排序使用索引"><a href="#为排序使用索引" class="headerlink" title="为排序使用索引"></a>为排序使用索引</h3><p><img src="https://i.imgur.com/msPgvCY.png" alt></p>
<p><a href="https://blog.csdn.net/tuesdayma/article/details/81783199" target="_blank" rel="noopener">https://blog.csdn.net/tuesdayma/article/details/81783199</a></p>
<h3 id="一条sql执行时间过长，如何优化，从哪些方面"><a href="#一条sql执行时间过长，如何优化，从哪些方面" class="headerlink" title="一条sql执行时间过长，如何优化，从哪些方面"></a>一条sql执行时间过长，如何优化，从哪些方面</h3><pre>
1）查看sql是否涉及多表的联表查询或者子查询，如果有，看是否能进行业务拆分，相关字段冗余或者
   合并成零时表。
2）涉及联表的查询，是否能进行分表查询，单表查询之后的结果进行字段整合。
3）如果以上两种情况都不能操作，非要联表查询，那么考虑对相应的查询条件做索引，加快查询速度。
5）针对数量大的表进行历史表分离
6）数据库主从分离，读写分离，降低读写针对同一表时的压力
7）explain分析SQL语句，查看执行计划，分析索引是否用得上，分析扫描行数。
8）查看Mysql执行日志，看看是否有其他方面的问题。
</pre>

<h3 id="Mysql深度分页"><a href="#Mysql深度分页" class="headerlink" title="Mysql深度分页"></a>Mysql深度分页</h3><pre>
一般刚开始学SQL的时候，会这样写
 SELECT * FROM table ORDER BY id LIMIT 1000, 10;
但在数据达到百万级的时候，这样写会慢死
 SELECT * FROM table ORDER BY id LIMIT 1000000, 10;
也许耗费几十秒

网上很多优化的方法是这样的
 SELECT * FROM table WHERE id >= (SELECT id FROM table LIMIT 1000000, 1) LIMIT 10;
是的，速度提升到0.x秒了，看样子还行了
可是，还不是完美的！

以下这句才是完美的！
  SELECT * FROM table WHERE id BETWEEN 1000000 AND 1000010;
比上面那句，还要再快5至10倍


从中我们也能总结出两件事情：
 1）limit语句的查询时间与起始记录的位置成正比
 2）mysql的limit语句是很方便，但是对记录很多的表并不适合直接使用。

2.对limit分页问题的性能优化方法
利用表的覆盖索引来加速分页查询
我们都知道，利用了索引查询的语句中如果只包含了那个索引列（覆盖索引），那么这种情况会查询很快。
因为利用索引查找有优化算法，且数据就在查询索引上面，不用再去找相关的数据地址了，这样节省了很多时间。另外Mysql中
也有相关的索引缓存，在并发高的时候利用缓存就效果更好了。

另外，如果需要查询 id 不是连续的一段，最佳的方法就是先找出 id ，然后用 in 查询
   SELECT * FROM table WHERE id IN(10000, 100000, 1000000...);
再分享一点
查询字段一较长字符串的时候，表设计时要为该字段多加一个字段,如，存储网址的字段
  查询的时候，不要直接查询字符串，效率低下，应该查诡该字串的crc32或md5。


在我们的例子中，我们知道id字段是主键，自然就包含了默认的主键索引。现在让我们看看利用覆盖索引的查询效果如何：
这次我们之间查询最后一页的数据（利用覆盖索引，只包含id列），如下：
 select id from order limit 800000, 20 0.2秒
 相对于查询了所有列的37.44秒，提升了大概100多倍的速度

那么如果我们也要查询所有列，有两种方法，一种是id>=的形式，另一种就是利用join，看下实际情况：
 SELECT * FROM order WHERE ID > =(select id from order limit 800000, 1) limit 20
查询时间为0.2秒，简直是一个质的飞跃啊，哈哈

另一种写法
 SELECT * FROM order a JOIN (select id from order limit 800000, 20) b ON a.ID = b.id
查询时间也很短
</pre>

<h3 id="查询锁表信息"><a href="#查询锁表信息" class="headerlink" title="查询锁表信息"></a>查询锁表信息</h3><pre>
当前运行的所有事务
select * from information_schema.innodb_trx
当前出现的锁
select * from information_schema.innodb_locks
锁等待的对应关系
select * from information_schema.innodb_lock_waits 
</pre>

<h3 id="Mysql一次插入几万条数据处理方式"><a href="#Mysql一次插入几万条数据处理方式" class="headerlink" title="Mysql一次插入几万条数据处理方式"></a>Mysql一次插入几万条数据处理方式</h3><pre>
1）Insert批量插入，调整max_allowed_packet
2) 开启事务，增大innodb_log_buffer_size，增加单事务提交日志量。
3）主键顺序插入，效率更高
5）对要插入的数据进行分组批量插入

INSERT INTO table (column1, column2, ..., column_n) VALUES 
(value11, value12, ..., value1n), 
(value21, value22, ... value2n), ..., (value_n1, value_n2, ... value_nn)

常用的插入语句如：
INSERT INTO `insert_table` (`datetime`, `uid`, `content`, `type`) 
     VALUES ('0', 'userid_0', 'content_0', 0);
INSERT INTO `insert_table` (`datetime`, `uid`, `content`, `type`) 
     VALUES ('1', 'userid_1', 'content_1', 1);
修改成：

INSERT INTO `insert_table` (`datetime`, `uid`, `content`, `type`) 
VALUES ('0', 'userid_0', 'content_0', 0), ('1', 'userid_1', 'content_1', 1);

修改后的插入操作能够提高程序的插入效率。这里第二种SQL执行效率高的主要原因是合并后日志量（MySQL的binlog和innodb的事务让
日志）减少了，降低日志刷盘的数据量和频率，从而提高效率。通过合并SQL语句，同时也能减少SQL语句解析的次数，减少网络传
输的IO。


数据有序插入。
  数据有序的插入是指插入记录在主键上是有序排列，例如datetime是记录的主键：
  INSERT INTO `insert_table` (`datetime`, `uid`, `content`, `type`) 
         VALUES ('1', 'userid_1', 'content_1', 1);
  INSERT INTO `insert_table` (`datetime`, `uid`, `content`, `type`) 
         VALUES ('0', 'userid_0', 'content_0', 0);
  INSERT INTO `insert_table` (`datetime`, `uid`, `content`, `type`) 
         VALUES ('2', 'userid_2', 'content_2',2);
  修改成：

  INSERT INTO `insert_table` (`datetime`, `uid`, `content`, `type`) 
         VALUES ('0', 'userid_0', 'content_0', 0);
  INSERT INTO `insert_table` (`datetime`, `uid`, `content`, `type`) 
         VALUES ('1', 'userid_1', 'content_1', 1);
  INSERT INTO `insert_table` (`datetime`, `uid`, `content`, `type`) 
         VALUES ('2', 'userid_2', 'content_2',2);
  由于数据库插入时，需要维护索引数据，无序的记录会增大维护索引的成本。我们可以参照InnoDB使用的B+tree索引，如果每次插
  入记录都在索引的最后面，索引的定位效率很高，并且对索引调整较小；如果插入的记录在索引中间，需要B+tree进行分裂合并等
  处理，会消耗比较多计算资源，并且插入记录的索引定位效率会下降，数据量较大时会有频繁的磁盘操作。


从测试结果来看，该优化方法的性能有所提高，但是提高并不是很明显。

SQL语句是有长度限制，在进行数据合并在同一SQL中务必不能超过SQL长度限制，通过max_allowed_packet配置可以修改，默认是1M，
测试时修改为8M。

事务需要控制大小，事务太大可能会影响执行的效率。MySQL有innodb_log_buffer_size配置项，超过这个值会把innodb的数据刷到
磁盘中，这时，效率会有所下降。所以比较好的做法是，在数据达到这个这个值前进行事务提交。
</pre>

<h3 id="Mysql配置优化提高SQL查询写入性能"><a href="#Mysql配置优化提高SQL查询写入性能" class="headerlink" title="Mysql配置优化提高SQL查询写入性能"></a>Mysql配置优化提高SQL查询写入性能</h3><pre>
提高数据库插入性能的中心思想：
      1）尽量将数据一次性写入到Data File
      2）减少数据库的checkpoint 操作

innodb_buffer_pool_size 
   如果用Innodb，那么这是一个重要变量。相对于MyISAM来说，Innodb对于
buffer size更敏感。MySIAM可能对于大数据量使用默认的key_buffer_size也还好，
但Innodb在大数据量时用默认值就感觉在爬了。 Innodb的缓冲池会缓存数据和索引，所
以不需要给系统的缓存留空间，如果只用Innodb，可以把这个值设为内存的70%-80%。
和 key_buffer相同，如果数据量比较小也不怎么增加，那么不要把这个值设太高也可以提
高内存的使用率。

innodb_log_file_size 
   此配置项作用设定innodb 数据库引擎UNDO日志的大小；从而减少数据库checkpoint
操作。

   对于写很多尤其是大数据量时非常重要。要注意，大的文件提供更高的性能，但数据库恢
复时会用更多的时间。我一般用64M-512M，具体取决于服务器的空间。

innodb_log_buffer_size 
   此配置项作用设定innodb 数据库引擎写日志缓存区；将此缓存段增大可以减少数据库写
数据文件次数

   默认值对于多数中等写操作和事务短的运用都是可以的。如 果经常做更新或者使用了
很多blob数据，应该增大这个值。但太大了也是浪费内存，因为1秒钟总会 flush（这个词
的中文怎么说呢？）一次，所以不需要设到超过1秒的需求。8M-16M一般应该够了。小的运用
可以设更小一点。

innodb_flush_log_at_trx_commit 
   0: Write the log buffer to the log file and flush the log file 
      every second, but do nothing at transaction commit. 
   1：the log buffer is written out to the log file at each 
      transaction commit and the flush to disk operation is performed 
      on the log file 
   2：the log buffer is written out to the file at each commit, but 
      the flush to disk operation is not performed on it 

   抱怨Innodb比MyISAM慢 100倍？那么你大概是忘了调整这个值。默认值1的意思是每一
次事务提交或事务外的指令都需要把日志写入（flush）硬盘，这是很费时的。特别是使用
电 池供电缓存（Battery backed up cache）时。设成2对于很多运用，特别是从MyISAM
表转过来的是可以的，它的意思是不写入硬盘而是写入系统缓存。日志仍然会每秒flush到
硬 盘，所以你一般不会丢失超过1-2秒的更新。设成0会更快一点，但安全方面比较差，即
使MySQL挂了也可能会丢失事务的数据。而值2只会在整个操作系统 挂了时才可能丢数据。

innodb_autoextend_increment 配置由于默认8M 调整到 128M
   此配置项作用主要是当tablespace 空间已经满了后，需要MySQL系统需要自动扩展多
少空间，每次tablespace 扩展都会让各个SQL 处于等待状态。增加自动扩展Size可以减
少tablespace自动扩展次数。

提高数据库插入性能中心思想： 
  1、尽量使数据库一次性写入Data File 
  2、减少数据库的checkpoint 操作 
  3、程序上尽量缓冲数据，进行批量式插入与提交 
  4、减少系统的IO冲突

提高数据库读取速度
</pre>

<h3 id="Mysql表查询优化经验"><a href="#Mysql表查询优化经验" class="headerlink" title="Mysql表查询优化经验"></a>Mysql表查询优化经验</h3><pre>

</pre>

<h3 id="Explain详细解析"><a href="#Explain详细解析" class="headerlink" title="Explain详细解析"></a>Explain详细解析</h3><pre>
table：表名
type：这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、eq_reg、ref、range、index和ALL
    system 表只有一行：system表。这是const连接类型的特殊情况

    const:表中的一个记录的最大值能够匹配这个查询（索引可以是主键或惟一索引）。因
      为只有一行，这个值实际就是常数，因为MYSQL先读这个值然后把它当做常数来对待

    eq_ref:在连接中，MYSQL在查询时，从前面的表中，对每一个记录的联合都从表中读取
          一个记录，它在查询使用了索引为主键或惟一键的全部时使用

    ref:这个连接类型只有在查询使用了不是惟一或主键的键或者是这些类型的部分
     （比如，利用最左边前缀）时发生。对于之前的表的每一个行联合，全部记录都将从
      表中读出。这个类型严重依赖于根据索引匹配的记录多少—越少越好

    range:这个连接类型使用索引返回一个范围中的行，比如使用 > 或 < 查找东西时发生的情况

    index: 这个连接类型对前面的表中的每一个记录联合进行完全扫描（比ALL更好，因为
         索引一般小于表数据）

    ALL:这个连接类型对于前面的每一个记录联合进行完全扫描，这一般比较糟糕，应该尽量避免

possible_keys：显示可能应用在这张表中的索引。如果为空，没有可能的索引。可以为相关
    的域从WHERE语句中选择一个合适的语句
key： 实际使用的索引。如果为NULL，则没有使用索引。很少的情况下，MYSQL会选择优化不足
    的索引。这种情况下，可以在SELECT语句中使用USE INDEX（indexname）来强制使
    用一个索引或者用IGNORE INDEX（indexname）来强制MYSQL忽略索引
key_len：使用的索引的长度。在不损失精确性的情况下，长度越短越好
ref：显示索引的哪一列被使用了，如果可能的话，是一个常数
rows：MYSQL认为必须检查的用来返回请求数据的行数

extra列返回的描述的意义
   Distinct:一旦MYSQL找到了与行相联合匹配的行，就不再搜索了

   Not exists: MYSQL优化了LEFT JOIN，一旦它找到了匹配LEFT JOIN标准的行，就不
               再搜索了

   Range checked for each Record（index map:#）:没有找到理想的索引，因此对
       于从前面表中来的每一个行组合，MYSQL检查使用哪个索引，并用它来从表中
       返回行。这是使用索引的最慢的连接之一

   Using filesort: 看到这个的时候，查询就需要优化了。MYSQL需要进行额外的步骤来
       发现如何对返回的行排序。它根据连接类型以及存储排序键值和匹配条件的全部行
       的行指针来排序全部行

   Using index: 列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返
                回的，这发生在对表的全部的请求列都是同一个索引的部分的时候

   Using temporary 看到这个的时候，查询需要优化了。这里，MYSQL需要创建一个临时
         表来存储结果，这通常发生在对不同的列集进行ORDER BY上，而不是GROUP BY上

   Where used 使用了WHERE从句来限制哪些行将与下一张表匹配或者是返回给用户。如果
        不想返回表中的全部行，并且连接类型ALL或index，这就会发生，或者是查询有
        问题不同连接类型的解释（按照效率高低的顺序排序）


</pre>

<h3 id="Using-index"><a href="#Using-index" class="headerlink" title="Using index"></a>Using index</h3><pre>
查询的列被索引覆盖，并且where筛选条件是索引的是前导列

Using where Using index
1:查询的列被索引覆盖，并且where筛选条件是索引列之一但是不是索引的不是前导列，
  Extra中为Using where; Using index，意味着无法直接通过索引查找来查询到符
  合条件的数据
2:查询的列被索引覆盖，并且where筛选条件是索引列前导列的一个范围，同样意味着无法
  直接通过索引查找查询到符合条件的数据
NULL（既没有Using index，也没有Using where Using index，也没有using where）
1，查询的列未被索引覆盖，并且where筛选条件是索引的前导列，
　　     意味着用到了索引，但是部分字段未被索引覆盖，必须通过“回表”来实现，不是纯粹地用
 到了索引，也不是完全没用到索引，Extra中为NULL(没有信息)
Using where
1，查询的列未被索引覆盖，where筛选条件非索引的前导列，Extra中为Using where
2，查询的列未被索引覆盖，where筛选条件非索引列，Extra中为Using where

using where 意味着通过索引或者表扫描的方式进程where条件的过滤，
　　    反过来说，也就是没有可用的索引查找，当然这里也要考虑索引扫描+回表与表扫描的代价。
　　    这里的type都是all，说明MySQL认为全表扫描是一种比较低的代价。
Using index condition
1，-- 查询的列不全在索引中，where条件中是一个前导列的范围
2，查询列不完全被索引覆盖，查询条件完全可以使用到索引（进行索引查找）
</pre>

<p><img src="https://i.imgur.com/UCgL2Vh.png" alt></p>
<h3 id="子查询-联合join查询效率"><a href="#子查询-联合join查询效率" class="headerlink" title="子查询 联合join查询效率"></a>子查询 联合join查询效率</h3><pre>

</pre>
]]></content>
      <categories>
        <category>database</category>
      </categories>
  </entry>
  <entry>
    <title>JMM&amp;volatile</title>
    <url>/2021/06/08/java/coucurrent/1.JMM&amp;volatile/</url>
    <content><![CDATA[<h1 id="现代计算机模型"><a href="#现代计算机模型" class="headerlink" title="现代计算机模型"></a>现代计算机模型</h1><p>冯诺依曼计算机模型<br><img src="/uploads/java/concurrent/%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A8%A1%E5%9E%8B.png" alt="冯诺依曼计算机模型"></p>
<p>现代计算机硬件基本结构<br><img src="/uploads/java/concurrent/%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.png" alt="现代计算机硬件基本结构"></p>
<p>CPU内部结构<br><img src="/uploads/java/concurrent/CPU%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.png" alt="CPU内部结构"></p>
<p>CPU多核缓存架构<br><img src="/uploads/java/concurrent/CPU%E5%A4%9A%E6%A0%B8%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.png" alt="CPU多核缓存架构"></p>
<p>缓存一致性协议(MESI)<br><img src="/uploads/java/concurrent/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE.png" alt="缓存一致性协议"></p>
<h2 id="具体流程："><a href="#具体流程：" class="headerlink" title="具体流程："></a>具体流程：</h2><p><strong>主存中存在变量x=1，多cpu多线程读取x（lock的是缓存行，当锁的数据横跨多个缓存行时就会进行总线加锁），copy副本到工作线程，此时所有线程中缓存行的状态<br>都是S，T1线程想要修改x时，把缓存行设为E，T1修改x之后，其它线程通过总线嗅探机制时刻监听着，其它线程对该缓存行的操作，<br>发现T1变成M之后，其它线程的变成I，T1对x的操作，等待某一个时间后，刷回主存。其它线程，当发现x被修改之后，会重新去主存中<br>copy，但是cpu不会等待，从而出现指令重排。</strong></p>
<p><img src="/uploads/java/concurrent/CPU%E5%A4%9A%E6%A0%B8%E7%BC%93%E5%AD%98%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" alt="具体流程"></p>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h2><p>进程是系统分配资源的基本单位，线程是调度CPU的基本单位，一个进程至少包含一个执行线程，<br>线程寄生在进程当中。每个线程都有一个程序计数器（记录要执行的下一条指令），<br>一组寄存器（保存当前线程的工作变量），堆栈（记录执行历史，其中每一帧保存了一个已经调用但未返回的过程）</p>
<p>线程分为两类：<br>用户级线程(User-Level Thread)<br>内核线线程(Kernel-Level Thread)</p>
<p>用户空间划分：<br>内核空间<br>用户空间</p>
<p><img src="/uploads/java/concurrent/%E7%BA%BF%E7%A8%8B%E6%B7%B1%E5%85%A5%E8%A7%A3%E8%AF%BB.png" alt="线程深入解读"></p>
<h2 id="Java线程与内核线程的关系"><a href="#Java线程与内核线程的关系" class="headerlink" title="Java线程与内核线程的关系"></a>Java线程与内核线程的关系</h2><p><img src="/uploads/java/concurrent/Java%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="Java线程与内核线程的关系"></p>
<h2 id="Java线程生命状态"><a href="#Java线程生命状态" class="headerlink" title="Java线程生命状态"></a>Java线程生命状态</h2><p><img src="/uploads/java/concurrent/Java%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E7%8A%B6%E6%80%81.png" alt="Java线程生命状态"></p>
<h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h2 id="为什么用到并发"><a href="#为什么用到并发" class="headerlink" title="为什么用到并发"></a>为什么用到并发</h2><ul>
<li>充分利用多核CPU的计算能力</li>
<li>方便业务拆分，提升应用性能</li>
</ul>
<h2 id="并发产生的问题"><a href="#并发产生的问题" class="headerlink" title="并发产生的问题"></a>并发产生的问题</h2><ul>
<li>高并发场景下，导致频繁的上下文切换</li>
<li>临界区线程安全问题，容易出现死锁的，产生死锁就会造成系统功能不可用</li>
<li>其它</li>
</ul>
<p><img src="/uploads/java/concurrent/%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E8%BF%87%E7%A8%8B.png" alt="线程上下文切换过程"></p>
<h1 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h1><p>JMM与JVM内存区域的划分是不同的概念层次，更恰当说JMM描述的是一组规则，通过这组规则控制程序中各个变量在共享数据区域和私有数据区域的访问方式，<br>JMM是围绕原子性，有序性、可见性展开。</p>
<p>简单来说：JMM是计算机CPU多核缓存架构java实现，是一种规则。</p>
<p><img src="/uploads/java/concurrent/JMM%E6%A8%A1%E5%9E%8B.png" alt="JMM模型"></p>
<h2 id="JVM虚拟机规范主内存与工作内存"><a href="#JVM虚拟机规范主内存与工作内存" class="headerlink" title="JVM虚拟机规范主内存与工作内存"></a>JVM虚拟机规范主内存与工作内存</h2><p><img src="/uploads/java/concurrent/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%A7%84%E8%8C%83%E4%B8%BB%E5%86%85%E5%AD%98%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98.png" alt="JVM虚拟机规范主内存与工作内存"></p>
<h2 id="Java内存模型与硬件内存架构的关系"><a href="#Java内存模型与硬件内存架构的关系" class="headerlink" title="Java内存模型与硬件内存架构的关系"></a>Java内存模型与硬件内存架构的关系</h2><p>JMM模型跟CPU缓存模型结构类似，是基于CPU缓存模型建立起来的，JMM模型是标准化的，<br>屏蔽掉了底层不同计算机的区别。对于硬件内存来说只有寄存器、缓存内存、主内存的概念，并没有工作内存(线程私有数据区域)和主内存(堆内存)之分，<br>也就是说Java内存模型对内存的划分对硬件内存并没有任何影响</p>
<p><img src="/uploads/java/concurrent/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%A1%AC%E4%BB%B6%E5%86%85%E5%AD%98%E6%9E%B6%E6%9E%84%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="Java内存模型与硬件内存架构的关系"></p>
<h2 id="Java内存模型内存交互操作"><a href="#Java内存模型内存交互操作" class="headerlink" title="Java内存模型内存交互操作"></a>Java内存模型内存交互操作</h2><p>1.lock(锁定)：作用于主内存的变量，把一个变量标记为一条线程独占状态<br>2.unlock(解锁)：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定<br>3.read(读取)：作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用<br>4.load(载入)：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中<br>5.use(使用)：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎<br>6.assign(赋值)：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量<br>7.store(存储)：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作<br>8.write(写入)：作用于工作内存的变量，它把store操作从工作内存中的一个变量的值传送到主内存的变量中</p>
<p>把一个变量从主内存中复制到工作内存中，就需要按顺序地执行read和load操作，如果把变量从工作内存中同步到主内存中，<br>就需要按顺序地执行store和write操作。但Java内存模型只要求上述8大操作(原子操作)必须按顺序执行，而没有保证必须是连续执行。</p>
<p><strong>read和load同时出现，store和write同时出现</strong></p>
<p><img src="/uploads/java/concurrent/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%86%85%E5%AD%98%E4%BA%A4%E4%BA%92%E6%93%8D%E4%BD%9C.png" alt="Java内存模型内存交互操作"></p>
<h2 id="Java内存模型内存同步规则"><a href="#Java内存模型内存同步规则" class="headerlink" title="Java内存模型内存同步规则"></a>Java内存模型内存同步规则</h2><p><img src="/uploads/java/concurrent/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%86%85%E5%AD%98%E5%90%8C%E6%AD%A5%E8%A7%84%E5%88%99.png" alt="Java内存模型内存同步规则"></p>
<h1 id="volatile原理与内存语义"><a href="#volatile原理与内存语义" class="headerlink" title="volatile原理与内存语义"></a>volatile原理与内存语义</h1><p>volatile是Java虚拟机提供的轻量级的同步机制</p>
<p>volatile语义有如下两个作用</p>
<ul>
<li>可见性：保证被volatile修饰的共享变量对所有线程总数可见的，也就是当一个线程修改了一个被volatile修饰共享变量的值，新值总是可以被其他线程立即得知。</li>
<li>有序性：禁止指令重排序优化。</li>
</ul>
<p>volatile缓存可见性实现原理</p>
<ul>
<li>JMM内存交互层面：volatile修饰的变量的read、load、use操作和assign、store、write必须是连续的，即修改后必须立即同步会主内存，使用时必须从主内存刷新，由此保证volatile变量的可见性。</li>
<li>底层实现：通过汇编lock前缀指令，它会锁定变量缓存行区域并写回主内存，这个操作称为“缓存锁定”，缓存一致性机制会阻止同时修改被两个以上处理器缓存的内存区域数据。一个处理器的缓存回写到内存内存会导致其他处理器的缓存无效</li>
<li>汇编代码查看<br>XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly -Xcomp</li>
</ul>
<h1 id="可见性-amp-原子性-amp-有序性"><a href="#可见性-amp-原子性-amp-有序性" class="headerlink" title="可见性&amp;原子性&amp;有序性"></a>可见性&amp;原子性&amp;有序性</h1><p>并发编程三大特性</p>
<ul>
<li>可见性</li>
<li>原子性</li>
<li>有序性</li>
</ul>
<p>volatile保证可见性与有序性，但是不能保证原子性，要保证原子性需要借助synchronized、Lock锁机制，同理也能保证有序性与可见性。因为synchronized和Lock能够保证任一时刻只有一个线程访问该代码块。</p>
<h1 id="有序性-amp-指令重排"><a href="#有序性-amp-指令重排" class="headerlink" title="有序性&amp;指令重排"></a>有序性&amp;指令重排</h1><p>java语言规范规定JVM线程内部维持顺序化语义。即只要程序的最终结果与它顺序化情况的结果相等，那么指令的执行顺序可以与代码顺序不一致，此过程叫指令的重排序。</p>
<p>指令重排序的意义：JVM能根据处理器特性（CPU多级缓存系统、多核处理器等）适当的对机器指令进行重排序，使机器指令能更符合CPU的执行特性，最大限度的发挥机器性能。</p>
<p>在编译器与CPU处理器中都能执行指令重排优化操作</p>
<p><img src="/uploads/java/concurrent/%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92.png" alt="指令重排"></p>
<h1 id="总线风暴–过度使用volatile可能产生的问题"><a href="#总线风暴–过度使用volatile可能产生的问题" class="headerlink" title="总线风暴–过度使用volatile可能产生的问题"></a>总线风暴–过度使用volatile可能产生的问题</h1>]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
  </entry>
  <entry>
    <title>synchronized&amp;Lock&amp;AQS</title>
    <url>/2021/06/09/java/coucurrent/2.synchronized&amp;Lock&amp;AQS/</url>
    <content><![CDATA[<h1 id="并发同步器"><a href="#并发同步器" class="headerlink" title="并发同步器"></a>并发同步器</h1><p>多线程编程中，有可能会出现多个线程同时访问同一个共享、可变资源的情况；这种资源可能是：对象、变量、文件等。</p>
<ul>
<li>共享：资源可以由多个线程同时访问</li>
<li>可变：资源可以在其生命周期内被修改</li>
</ul>
<p>引出的问题：<br>由于线程执行的过程是不可控的，所以需要采用同步机制来协同对对象可变状态的访问</p>
<p>加锁目的：序列化访问临界资源，即同一时刻只能有一个线程访问临界资源(同步互斥访问)</p>
<h1 id="Java锁体系"><a href="#Java锁体系" class="headerlink" title="Java锁体系"></a>Java锁体系</h1><p><img src="/uploads/java/concurrent/Java%E9%94%81%E4%BD%93%E7%B3%BB.png" alt="Java锁体系"></p>
<blockquote>
<p><a href="https://juejin.cn/post/6844904110085373966" target="_blank" rel="noopener">https://juejin.cn/post/6844904110085373966</a></p>
</blockquote>
<h1 id="synchronized使用与原理"><a href="#synchronized使用与原理" class="headerlink" title="synchronized使用与原理"></a>synchronized使用与原理</h1><p>加锁方式：</p>
<ul>
<li>同步实例方法，锁是当前实例对象</li>
<li>同步类方法，锁是当前类对象</li>
<li>同步代码块，锁是括号里面的对象</li>
</ul>
<p>底层原理:</p>
<p>JVM内置锁通过synchronized使用，通过内部对象Monitor(监视器锁)实现，基于进入与退出Monitor对象实现方法与<br>代码块同步，监视器锁的实现依赖底层操作系统的Mutex lock（互斥锁）实现，它是一个重量级锁性能较低</p>
<p><img src="/uploads/java/concurrent/synchronized.png" alt="synchronized"></p>
<h2 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h2><p>每个对象都有一个自己的Monitor(监视器锁)</p>
<p>JVM加锁过程：</p>
<p><img src="/uploads/java/concurrent/synchronized%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B.png" alt="synchronized加锁过程"></p>
<h2 id="对象内存结构详见jvm"><a href="#对象内存结构详见jvm" class="headerlink" title="对象内存结构详见jvm"></a>对象内存结构<a href="https://marchnineteen.github.io/2018/10/31/java/jvm/jvm(1">详见jvm</a></h2><p>认识对象的内存结构：</p>
<ul>
<li>对象头：比如 hash码，对象所属的年代，对象锁，锁状态标志，偏向锁（线程）ID，偏向时间，数组长度（数组对象）等</li>
<li>对象实际数据：即创建对象时，对象中成员变量，方法等</li>
<li>对齐填充：对象的大小必须是8字节的整数倍</li>
</ul>
<p>面试问题：</p>
<p>实例对象内存中存储在哪？</p>
<p>如果实例对象存储在堆区时：实例对象内存存在堆区，实例的引用存在栈上，实例的元数据class存在方法区或者元空间</p>
<p>Object实例对象一定是存在堆区的吗？</p>
<p>不一定，如果实例对象没有线程逃逸行为</p>
<p><img src="/uploads/java/concurrent/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png" alt="对象的内存结构"></p>
<h3 id="MarkWord"><a href="#MarkWord" class="headerlink" title="MarkWord"></a>MarkWord</h3><p>以32位JVM中存储内容为例</p>
<p><img src="/uploads/java/concurrent/MarkWord.png" alt="MarkWord"></p>
<h2 id="锁优化升级过程"><a href="#锁优化升级过程" class="headerlink" title="锁优化升级过程"></a>锁优化升级过程</h2><p>JDK1.6版本之后对synchronized的实现进行了各种优化，如自旋锁、偏向锁和轻量级锁<br>并默认开启偏向锁<br>开启偏向锁：-XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0<br>关闭偏向锁：-XX:-UseBiasedLocking</p>
<p>偏向锁：单线程场景<br>轻量级锁：线程间交替执行场景，本身竞争不是很激烈。</p>
<p><img src="/uploads/java/concurrent/JVM%E5%86%85%E7%BD%AE%E9%94%81%E4%BC%98%E5%8C%96%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B.png" alt="JVM内置锁优化升级过程"></p>
<p><img src="/uploads/java/concurrent/%E9%94%81%E4%BC%98%E5%8C%96%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B.png" alt="锁优化升级过程"></p>
<p><img src="/uploads/java/concurrent/JVM%E9%94%81%E7%9A%84%E8%86%A8%E8%83%80%E5%8D%87%E7%BA%A7.jpg" alt="JVM锁的膨胀升级"></p>
<h1 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h1><p><img src="/uploads/java/concurrent/lock.png" alt="lock"></p>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><blockquote>
<p><a href="https://juejin.cn/post/6844903598984282119" target="_blank" rel="noopener">https://juejin.cn/post/6844903598984282119</a></p>
</blockquote>
<h2 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h2><h1 id="AbstractQueuedSynchronizer"><a href="#AbstractQueuedSynchronizer" class="headerlink" title="AbstractQueuedSynchronizer"></a>AbstractQueuedSynchronizer</h1><p>Java并发编程核心在于java.concurrent.util包<br>而juc当中的大多数同步器实现都是围绕着共同的基础行为，比如等待队列、条件队列、独占获取、共享获取等，而这个行为的抽象就是基于AbstractQueuedSynchronizer简称AQS，<br>AQS定义了一套多线程访问共享资源的同步器框架，是一个依赖状态(state)的同步器。</p>
<p>AQS具备特性</p>
<ul>
<li>阻塞等待队列</li>
<li>共享/独占</li>
<li>公平/非公平</li>
<li>可重入</li>
<li>允许中断</li>
</ul>
<h2 id="并发编程包依赖于AQS的内部实现"><a href="#并发编程包依赖于AQS的内部实现" class="headerlink" title="并发编程包依赖于AQS的内部实现"></a>并发编程包依赖于AQS的内部实现</h2><p>Java.concurrent.util当中同步器的实现如Lock,Latch,Barrier等，都是基于AQS框架实现</p>
<ul>
<li>一般通过定义内部类Sync继承AQS</li>
<li>将同步器所有调用都映射到Sync对应的方法</li>
</ul>
<p>AQS框架-管理状态</p>
<p>AQS内部维护属性volatile int state (32位)</p>
<ul>
<li>state表示资源的可用状态</li>
</ul>
<p>State三种访问方式</p>
<ul>
<li>getState()、setState()、compareAndSetState()</li>
</ul>
<p>AQS定义两种资源共享方式</p>
<ul>
<li>Exclusive-独占，只有一个线程能执行，如ReentrantLock</li>
<li>Share-共享，多个线程可以同时执行，如Semaphore/CountDownLatch</li>
</ul>
<p>AQS定义两种队列</p>
<ul>
<li>同步等待队列</li>
<li>条件等待队列</li>
</ul>
<h2 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h2><p>CLH队列是Craig、Landin、Hagersten三人发明的一种基于双向链表数据结构的队列， 是FIFO先入先出线程等待队列，<br>Java中的CLH队列是原CLH队列的一个变种, 线程由原自旋机制改为阻塞机制。</p>
<p><img src="/uploads/java/concurrent/CLH%E9%98%9F%E5%88%97.png" alt="CLH队列"></p>
<h2 id="条件队列"><a href="#条件队列" class="headerlink" title="条件队列"></a>条件队列</h2><p>Condition是一个多线程间协调通信的工具类，使得某个，或者某些线程一起等待某个条件（Condition）,只有当该条件具备时 ，这些等待线程才会被唤醒，从而重新争夺锁</p>
<p><img src="/uploads/java/concurrent/%E6%9D%A1%E4%BB%B6%E9%98%9F%E5%88%97.png" alt="条件队列"></p>
<h2 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h2><p><img src="/uploads/java/concurrent/%E5%85%AC%E5%B9%B3%E9%94%81.png" alt="公平锁"></p>
<h2 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h2><p><img src="/uploads/java/concurrent/%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81.png" alt="非公平锁"></p>
<h2 id="重入锁"><a href="#重入锁" class="headerlink" title="重入锁"></a>重入锁</h2><p><img src="/uploads/java/concurrent/%E9%87%8D%E5%85%A5%E9%94%81.png" alt="重入锁"></p>
<h2 id="不可重入锁"><a href="#不可重入锁" class="headerlink" title="不可重入锁"></a>不可重入锁</h2><p><img src="/uploads/java/concurrent/%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81.png" alt="不可重入锁"></p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
  </entry>
  <entry>
    <title>CountDownLatch&amp;Semaphore-共享锁</title>
    <url>/2021/10/31/java/coucurrent/3.CountDownLatch&amp;Semaphore/</url>
    <content><![CDATA[<h1 id="1-Semaphore-是什么？"><a href="#1-Semaphore-是什么？" class="headerlink" title="1. Semaphore 是什么？"></a>1. Semaphore 是什么？</h1><p>Semaphore 字面意思是信号量的意思，它的作用是控制访问特定资源的线程数目。</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
  </entry>
  <entry>
    <title>Atomic&amp;Unsafe魔法类详解</title>
    <url>/2021/11/05/java/coucurrent/4.Atomic&amp;Unsafe%E9%AD%94%E6%B3%95%E7%B1%BB%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h1><p>处理器自动保证基本内存操作的原子性，如对同一个缓存行里进行16/32/64位的操作是原子的。<br>复杂的内存操作处理器不能自动保证其原子性，比如跨总线宽度，跨多个缓存行，跨页表的访问。</p>
<p>缓存加锁</p>
<p>总线加锁</p>
<h1 id="Atomic"><a href="#Atomic" class="headerlink" title="Atomic"></a>Atomic</h1><p>在Atomic包里一共有12个类，四种原子更新方式,原子更新基本类型,原子更新数组,原子更新引用,原子更新字段, Atomic包里的类基本都是使用Unsafe实现的包装类。</p>
<p>基本类：AtomicInteger、AtomicLong、AtomicBoolean；</p>
<p>引用类型：AtomicReference、AtomicReference的ABA实例、AtomicStampedRerence、AtomicMarkableReference；</p>
<p>数组类型：AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray</p>
<p>属性原子修改器（Updater）：AtomicIntegerFieldUpdater、AtomicLongFieldUpdater、AtomicReferenceFieldUpdater</p>
<h1 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h1><p>Unsafe是位于sun.misc包下的一个类，主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升Java运行效率、<br>增强Java语言底层资源操作能力方面起到了很大的作用。</p>
<p>Unsafe类为一单例实现，提供静态方法getUnsafe获取Unsafe实例，当且仅当调用getUnsafe方法的类为引导类加载器所加载时才合法，<br>否则抛出SecurityException异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Unsafe</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe theUnsafe;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Unsafe</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="meta">@CallerSensitive</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title">getUnsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Class var0 = Reflection.getCallerClass();       </span><br><span class="line">        <span class="comment">// 仅在引导类加载器`BootstrapClassLoader`加载时才合法       </span></span><br><span class="line">        <span class="keyword">if</span>(!VM.isSystemDomainLoader(var0.getClassLoader())) &#123;           </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"Unsafe"</span>);       </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;           </span><br><span class="line">            <span class="keyword">return</span> theUnsafe;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="如何获取Unsafe"><a href="#如何获取Unsafe" class="headerlink" title="如何获取Unsafe"></a>如何获取Unsafe</h2><p>1、把调用Unsafe相关方法的类Demo所在jar包路径追加到默认的bootstrap路径中，使得A被引导类加载器加载</p>
<ul>
<li>java -Xbootclasspath/Demo:${path} // 其中path为调用Unsafe相关方法的类所在jar包路径 </li>
</ul>
<p>2、通过反射获取单例对象theUnsafe</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeInstance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title">reflectGetUnsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field field = Unsafe.class.getDeclaredField("theUnsafe");</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> (Unsafe) field.get(<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Unsafe功能"><a href="#Unsafe功能" class="headerlink" title="Unsafe功能"></a>Unsafe功能</h2><p><img src="/uploads/java/concurrent/Unsafe%E5%8A%9F%E8%83%BD.png" alt="Unsafe功能.png"></p>
<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CAS</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o         包含要修改field的对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> offset    对象中某field的偏移量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> expected  期望值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> update    更新值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>          true | false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapObject</span><span class="params">(Object var1, <span class="keyword">long</span> var2, Object var4, Object var5)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapLong</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">long</span> var4, <span class="keyword">long</span> var6)</span></span>;</span><br></pre></td></tr></table></figure>

<p><img src="/uploads/java/concurrent/CAS.png" alt="CAS.png"></p>
<h2 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取消阻塞线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Object thread)</span></span>;</span><br><span class="line"><span class="comment">//阻塞线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(<span class="keyword">boolean</span> isAbsolute, <span class="keyword">long</span> time)</span></span>;</span><br><span class="line"><span class="comment">//获得对象锁（可重入锁）</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">monitorEnter</span><span class="params">(Object o)</span></span>;</span><br><span class="line"><span class="comment">//释放对象锁</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">monitorExit</span><span class="params">(Object o)</span></span>;</span><br><span class="line"><span class="comment">//尝试获取对象锁</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">tryMonitorEnter</span><span class="params">(Object o)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//内存屏障，禁止load操作重排序。屏障前的load操作不能被重排序到屏障后，屏障后的load操作不能被重排序到屏障前</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">loadFence</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//内存屏障，禁止store操作重排序。屏障前的store操作不能被重排序到屏障后，屏障后的store操作不能被重排序到屏障前</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">storeFence</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//内存屏障，禁止load、store操作重排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">fullFence</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">典型应用</span><br><span class="line">StampedLock的validate()方法使用内存屏障，防止指令重排</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validate</span><span class="params">(<span class="keyword">long</span> stamp)</span> </span>&#123;</span><br><span class="line">    U.loadFence();<span class="comment">// 内存屏障</span></span><br><span class="line">    reture (stamp &amp; SBITS) == (state &amp; SBITS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/uploads/java/concurrent/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C.png" alt="内存屏障.png"></p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
  </entry>
  <entry>
    <title>Collections&amp;Queue体系</title>
    <url>/2021/11/07/java/coucurrent/5.Collections&amp;Queue%E4%BD%93%E7%B3%BB/</url>
    <content><![CDATA[<h1 id="BlockingQueue阻塞队列"><a href="#BlockingQueue阻塞队列" class="headerlink" title="BlockingQueue阻塞队列"></a>BlockingQueue阻塞队列</h1><p>队列实质就是一种存储数据的结构</p>
<p>通常用链表或者数组实现</p>
<p>一般而言队列具备FIFO先进先出的特性，当然也有双端队列（Deque）优先级队列</p>
<p>主要操作：入队（EnQueue）与出队（Dequeue）</p>
<p><img src="/uploads/java/concurrent/BlockingQueue.png" alt="BlockingQueue.png"></p>
<p>1、ArrayBlockingQueue 由数组支持的有界队列<br>2、LinkedBlockingQueue 由链接节点支持的可选有界队列<br>3、PriorityBlockingQueue 由优先级堆支持的无界优先级队列<br>4、DelayQueue 由优先级堆支持的、基于时间的调度队列</p>
<h1 id="Java7HashMap死锁与Java8HashMap优化"><a href="#Java7HashMap死锁与Java8HashMap优化" class="headerlink" title="Java7HashMap死锁与Java8HashMap优化"></a>Java7HashMap死锁与Java8HashMap优化</h1><h1 id="ConcurrentHashMap线程安全与分段锁"><a href="#ConcurrentHashMap线程安全与分段锁" class="headerlink" title="ConcurrentHashMap线程安全与分段锁"></a>ConcurrentHashMap线程安全与分段锁</h1><h1 id="并发List-ArrayList与CopyOnWriteArrayList"><a href="#并发List-ArrayList与CopyOnWriteArrayList" class="headerlink" title="并发List-ArrayList与CopyOnWriteArrayList"></a>并发List-ArrayList与CopyOnWriteArrayList</h1><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p><img src="/uploads/java/concurrent/AQS%E5%90%8C%E6%AD%A5%E5%99%A8%E6%9D%A1%E4%BB%B6%E9%98%9F%E5%88%97%E5%BA%94%E7%94%A8%E9%80%BB%E8%BE%91.jpg" alt="AQS同步器条件队列应用逻辑.jpg"></p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
  </entry>
  <entry>
    <title>定时任务&amp;定时线程池</title>
    <url>/2021/11/09/java/coucurrent/7.%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1&amp;%E5%AE%9A%E6%97%B6%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
  </entry>
  <entry>
    <title>java集合框架</title>
    <url>/2017/03/16/java/javase/collection/</url>
    <content><![CDATA[<h1 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h1><p><img src="http://upload-images.jianshu.io/upload_images/4942449-cc7c288a15f6c092?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="集合框架体系图"></p>
<h2 id="Set-extends-Collection"><a href="#Set-extends-Collection" class="headerlink" title="Set (extends Collection)"></a>Set (extends Collection)</h2><p>Set是最简单的一种集合。集合中的对象不按特定的方式排序，并且没有重复对象。 Set接口主要实现了两个实现类：</p>
<ul>
<li>HashSet： HashSet类按照哈希算法来存取集合中的对象，存取速度比较快</li>
<li>TreeSet ：TreeSet类实现了SortedSet接口，能够对集合中的对象进行排序。</li>
<li>LinkedHashSet：具有HashSet的查询速度，且内部使用链表维护元素的顺序(插入的次序)。于是在使用迭代器遍历Set时，结果会按元素插入的次序显示。</li>
</ul>
<h2 id="List-extends-Collection"><a href="#List-extends-Collection" class="headerlink" title="List (extends Collection)"></a>List (extends Collection)</h2><p>实际上有两种List: 一种是基本的ArrayList,其优点在于随机访问元素，另一种是更强大的LinkedList,它并不是为快速随机访问设计的，而是具有一套更通用的方法。</p>
<p>List : 次序是List最重要的特点：它保证维护元素特定的顺序。List为Collection添加了许多方法，使得能够向List中间插入与移除元素(这只推荐LinkedList使用。)一个List可以生成ListIterator,使用它可以从两个方向遍历List,也可以从List中间插入和移除元素。</p>
<ul>
<li>ArrayList : 由数组实现的List。允许对元素进行快速随机访问，但是向List中间插入与移除元素的速度很慢。ListIterator只应该用来由后向前遍历ArrayList,而不是用来插入和移除元素。因为那比LinkedList开销要大很多。</li>
<li>LinkedList : 对顺序访问进行了优化，向List中间插入与删除的开销并不大。随机访问则相对较慢。(使用ArrayList代替。)还具有下列方法：addFirst(), addLast(), getFirst(), getLast(), removeFirst() 和 removeLast(), 这些方法 (没有在任何接口或基类中定义过)使得LinkedList可以当作堆栈、队列和双向队列使用。</li>
</ul>
<h2 id="Queen-extends-Collection"><a href="#Queen-extends-Collection" class="headerlink" title="Queen (extends Collection)"></a>Queen (extends Collection)</h2><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>方法put(Object key, Object value)添加一个“值”(想要得东西)和与“值”相关联的“键”(key)(使用它来查找)。方法get(Object key)返回与给定“键”相关联的“值”。可以用containsKey()和containsValue()测试Map中是否包含某个“键”或“值”。标准的Java类库中包含了几种不同的Map：HashMap, TreeMap, LinkedHashMap, WeakHashMap, IdentityHashMap。它们都有同样的基本接口Map，但是行为、效率、排序策略、保存对象的生命周期和判定“键”等价的策略等各不相同。</p>
<p>执行效率是Map的一个大问题。看看get()要做哪些事，就会明白为什么在ArrayList中搜索“键”是相当慢的。而这正是HashMap提高速度的地方。HashMap使用了特殊的值，称为“散列码”(hash code)，来取代对键的缓慢搜索。“散列码”是“相对唯一”用以代表对象的int值，它是通过将该对象的某些信息进行转换而生成的。所有Java对象都能产生散列码，因为hashCode()是定义在基类Object中的方法。</p>
<p>HashMap就是使用对象的hashCode()进行快速查询的。此方法能够显着提高性能</p>
<p>Map : 维护“键值对”的关联性，使你可以通过“键”查找“值”</p>
<ul>
<li>HashMap : Map基于散列表的实现。插入和查询“键值对”的开销是固定的。可以通过构造器设置容量capacity和负载因子load factor，以调整容器的性能。</li>
<li>LinkedHashMap : 类似于HashMap，但是迭代遍历它时，取得“键值对”的顺序是其插入次序，或者是最近最少使用(LRU)的次序。只比HashMap慢一点。而在迭代访问时发而更快，因为它使用链表维护内部次序。</li>
<li>TreeMap : 基于红黑树数据结构的实现。查看“键”或“键值对”时，它们会被排序(次序由Comparabel或Comparator决定)。TreeMap的特点在于，你得到的结果是经过排序的。TreeMap是唯一的带有subMap()方法的Map，它可以返回一个子树。</li>
<li>WeakHashMao : 弱键(weak key)Map，Map中使用的对象也被允许释放: 这是为解决特殊问题设计的。如果没有map之外的引用指向某个“键”，则此“键”可以被垃圾收集器回收。</li>
<li>IdentifyHashMap : 使用==代替equals()对“键”作比较的hash map。专为解决特殊问题而设计</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/4942449-9e051ab63d770a2f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<h2 id="总结如下："><a href="#总结如下：" class="headerlink" title="总结如下："></a>总结如下：</h2><p><img src="http://upload-images.jianshu.io/upload_images/4942449-51c43e347a13527d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<ul>
<li>他们之间的区别：<br><img src="http://upload-images.jianshu.io/upload_images/4942449-6c1ae30630a5a608.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></li>
</ul>
<h1 id="集合框架初始化容量和扩容比较："><a href="#集合框架初始化容量和扩容比较：" class="headerlink" title="集合框架初始化容量和扩容比较："></a>集合框架初始化容量和扩容比较：</h1><table>
<thead>
<tr>
<th align="left"></th>
<th align="left">ArrayList</th>
<th align="left">LinkList</th>
<th align="left">HashMap</th>
<th align="left">HashTable</th>
</tr>
</thead>
<tbody><tr>
<td align="left">jdk1.7</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">初始容量</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">扩容条件</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">扩容大小</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">最大容量</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">jdk1.8</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">初始容量</td>
<td align="left">10</td>
<td align="left"></td>
<td align="left">1 &lt;&lt; 4(16)</td>
<td align="left">11</td>
</tr>
<tr>
<td align="left">扩容条件</td>
<td align="left">在第一次add时扩容检测</td>
<td align="left"></td>
<td align="left">扩容加载因子为(0.75)，第一个临界点在当HashMap中元素的数量大于table数组长度<em>加载因子（16</em>0.75=12）</td>
<td align="left">扩容加载因子(0.75)，当超出默认长度（int）（11*0.75）=8时</td>
</tr>
<tr>
<td align="left">扩容大小</td>
<td align="left">oldCapacity + (oldCapacity &gt;&gt; 1)，即大约原集合长度的1.5倍</td>
<td align="left"></td>
<td align="left">oldThr &lt;&lt; 1(原长度*2)</td>
<td align="left">old*2+1(代码int newCapacity = (oldCapacity &lt;&lt; 1) + 1)</td>
</tr>
<tr>
<td align="left">最大容量</td>
<td align="left">Integer.MAX_VALUE - 8</td>
<td align="left"></td>
<td align="left">1 &lt;&lt; 30</td>
<td align="left">Integer.MAX_VALUE - 8</td>
</tr>
</tbody></table>
<p>对于java中的各种集合类，根据底层的具体实现，小结了一下大致有3种扩容的方式：</p>
<p>1、对于以散列表为底层数据结构实现的，（譬如hashset，hashmap，hashtable等），扩容方式为当链表数组的非空元素除以数组大小超过加载因子时，链表数组长度变大（乘以2+1），然后进行重新散列。</p>
<p>2、对于以数组为底层数据结构实现的，譬如ArrayList，当数组满了之后，数组长度变大 oldCapacity + (oldCapacity &gt;&gt; 1)，然后将原数组中的数据复制到新数组中。</p>
<p>3、对于以链表结构实现的，譬如TreeSet，TreeMap，则是动态增加元素~~即每次加１即可。</p>
<h2 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h2><p><strong>为啥arrayList最大值是Integer.MAX_VALUE - 8</strong>：<br>数组作为一个对象，需要一定的内存存储对象头信息，对象头信息最大占用内存不可超过8字节。</p>
<h2 id="部分源码实现过程："><a href="#部分源码实现过程：" class="headerlink" title="部分源码实现过程："></a>部分源码实现过程：</h2><h3 id="hashMap-put过程"><a href="#hashMap-put过程" class="headerlink" title="hashMap put过程"></a>hashMap put过程</h3><p>1.判断hash表是否为空，为空resize()方法创建表<br>2.根据hash值获得hash表中桶的头结点，若头结点为空直接调用newNode()添加结点<br>3.如果发生了hash冲突，先得到头结点进行比较，如果相同，替换节点值<br>4.如果头结点头结点不相同，且此时已处于红黑树状态，调用putTreeVal()添加入树中<br>5.如果还是处于链表状态，从头开始遍历链表，一旦找到相同的结点，就跳出循环，若到链表末尾，则添加一个结点<br>6.若添加后达到红黑树的阈值，则转换为红黑树(从treeifyBin方法可以看到，当容量小于64时，不会进行红黑树转换，只会扩容)<br>7.如果是添加一个数据，size将加一，如果达到阈值，则resize()扩容</p>
<h3 id="hashMap-resize"><a href="#hashMap-resize" class="headerlink" title="hashMap resize"></a>hashMap resize</h3><p>首先获取新容量以及新阈值，然后根据新容量创建新表。如果是扩容操作，则需要进行rehash操作，通过e.hash&amp;oldCap将链表分为两列，更好地均匀分布在新表中。 </p>
<h3 id="linkList-中间插入过程"><a href="#linkList-中间插入过程" class="headerlink" title="linkList 中间插入过程"></a>linkList 中间插入过程</h3><p>例：在A，B两个连续结点中插入C结点,形成ACB</p>
<p>1.创建一个新结点，将新节点的后继指针指向B，前继指针指向A<br>2.将B的前指针指向C<br>3.根据A是否为空判断，A为空该节点为头结点，重置first结点；不为空A的后指针指向C</p>
]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
  </entry>
  <entry>
    <title>java数据类型</title>
    <url>/2018/05/17/java/javase/dataType/</url>
    <content><![CDATA[<h1 id="1-Java-八大基本数据类型及其封装器类（位数为二进制位）"><a href="#1-Java-八大基本数据类型及其封装器类（位数为二进制位）" class="headerlink" title="1.Java 八大基本数据类型及其封装器类（位数为二进制位）"></a>1.Java 八大基本数据类型及其封装器类（位数为二进制位）</h1><h2 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h2><p>char：默认值：\u0000，16位，数据范围：\u0000 - u\ffff，存储Unicode码，用单引号赋值。封装类：Character</p>
<h2 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h2><p>boolean：默认值：false，1位，只有true和false两个取值。封装类：Boolean</p>
<h2 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h2><p>整数类型：(最大存储容量为2的n次方减一，范围为负数2的n减一次方至2的n减一次方减一，n为位数，原理见计算机组成原理无符号数与有符号数)</p>
<p>byte：默认值：0，8位，字节，最大存储数据量是255，存放的数据范围是-128~127之间。封装类：Byte</p>
<p>short：默认值：0，16位，最大数据存储量是65536，数据范围是-32768~32767之间。封装类：Short</p>
<p>int：默认值：0，32位，最大数据存储容量是2的32次方减1，数据范围是负的2的31次方到正的2的31次方减1。封装类：Integer</p>
<p>long：默认值：0，64位，最大数据存储容量是2的64次方减1，数据范围为负的2的63次方到正的2的63次方减1。封装类：Long</p>
<p>浮点数类型：</p>
<p>float：默认值：0.0f，32位，数据范围在3.4e-45~1.4e38，直接赋值时必须在数字后加上f或F。封装类：Float</p>
<p>double：默认值：0.0d，64位，数据范围在4.9e-324~1.8e308，赋值时可以加d或D也可以不加。封装类：Double</p>
<p>对于数值类型的基本类型的取值范围，我们无需强制去记忆，因为它们的值都已经以常量的形式定义在对应的包装类中了。如：</p>
<p>基本类型byte 二进制位数：Byte.SIZE最小值：Byte.MIN_VALUE最大值：Byte.MAX_VALUE</p>
<p>基本类型short二进制位数：Short.SIZE最小值：Short.MIN_VALUE最大值：Short.MAX_VALUE</p>
<p>基本类型char二进制位数：Character.SIZE最小值：Character.MIN_VALUE最大值：Character.MAX_VALUE</p>
<p>基本类型double 二进制位数：Double.SIZE最小值：Double.MIN_VALUE最大值：Double.MAX_VALUE</p>
<blockquote>
<p>注意：float、double两种类型的最小值与Float.MIN_VALUE、 Double.MIN_VALUE的值并不相同，实际上Float.MIN_VALUE和Double.MIN_VALUE分别指的是 float和double类型所能表示的最小正数。也就是说存在这样一种情况，0到±Float.MIN_VALUE之间的值float类型无法表示，0 到±Double.MIN_VALUE之间的值double类型无法表示。这并没有什么好奇怪的，因为这些范围内的数值超出了它们的精度范围。</p>
</blockquote>
<h1 id="2-数据类型之间的转换："><a href="#2-数据类型之间的转换：" class="headerlink" title="2.数据类型之间的转换："></a>2.数据类型之间的转换：</h1><h2 id="简单类型数据间的转换"><a href="#简单类型数据间的转换" class="headerlink" title="简单类型数据间的转换"></a>简单类型数据间的转换</h2><p>自动转换：运算或者方法调用时，低精度自动转化为高精度，从低到高顺序：(byte，short，char)–int–long–float—double；<br>        特例：int到float，long到float，long到double 是不会自动转换的，不然将会丢失精度。</p>
<p>强制转换：高精度转为低精度，可以使用强制转换；即你必须采用下面这种语句格式： int n=(int)3.14159/2;可以想象，这种转换肯定可能会导致溢出或精度的下降。</p>
<h2 id="表达式的数据类型自动提升"><a href="#表达式的数据类型自动提升" class="headerlink" title="表达式的数据类型自动提升"></a>表达式的数据类型自动提升</h2><p>注意一下规则：</p>
<pre><code>①所有的byte,short,char型的值将被提升为int型；
②如果有一个操作数是long型，计算结果是long型；
③如果有一个操作数是float型，计算结果是float型；
④如果有一个操作数是double型，计算结果是double型；
例， byte b; b=3; b=(byte)(b*3);//必须声明byte。 </code></pre><h2 id="包装类过渡类型转换"><a href="#包装类过渡类型转换" class="headerlink" title="包装类过渡类型转换"></a>包装类过渡类型转换</h2><ul>
<li>简单类型的变量转换为相应的包装类，可以利用包装类的构造函数。即：Boolean(boolean value)、Character(char value)、Integer(int value)、Long(long value)、Float(float value)、Double(double value)</li>
<li>在各个包装类中，总有形为××Value()的方法，来得到其对应的简单类型数据。利用这种方法，也可以实现不同数值型变量间的转换，例如，对于一个双精度实型类，intValue()可以得到其对应的整型变量，而doubleValue()可以得到其对应的双精度实型变量</li>
</ul>
<h2 id="字符串与其它类型间的转换"><a href="#字符串与其它类型间的转换" class="headerlink" title="字符串与其它类型间的转换"></a>字符串与其它类型间的转换</h2><p>其它类型向字符串的转换：</p>
<pre><code>①调用类的串转换方法:X.toString();
②自动转换:X+&quot;&quot;;
③使用String的方法:String.valueOf(X);</code></pre><p>字符串作为值,向其它类型的转换：</p>
<pre><code>①先转换成相应的封装器实例,再调用对应的方法转换成其它类型。例：new Float(&quot;11&quot;).doubleValue()
②静态parseXXX方法。
    String s = &quot;1&quot;;
    byte b = Byte.parseByte( s );
    short t = Short.parseShort( s );
    int i = Integer.parseInt( s );
    long l = Long.parseLong( s );
    Float f = Float.parseFloat( s );
    Double d = Double.parseDouble( s );
③Character的getNumericValue(char ch)方法</code></pre><h2 id="自动拆箱与自动装箱"><a href="#自动拆箱与自动装箱" class="headerlink" title="自动拆箱与自动装箱"></a><strong>自动拆箱与自动装箱</strong></h2><p>自动装箱：把基本类型用它们对应的包装类包装起来，使它们具有对象的特质，可以调用所对应的包装类所定义的方法，比如toString()等。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Integer i0 &#x3D; new Integer(0);&#x2F;&#x2F;基本的创建封装类对象</span><br><span class="line">Integer i1 &#x3D; 2;&#x2F;&#x2F;自动装箱</span><br><span class="line">Integer i1_ &#x3D; Integer.valueOf(2);&#x2F;&#x2F;自动装箱的本质，调用XX.valueof()方法</span><br><span class="line">&#96;&#96;&#96;    </span><br><span class="line"></span><br><span class="line">自动拆箱：跟自动装箱的方向相反，将Integer及Double这样的包装类的对象重新简化为基本类型的数据(自动拆箱时，一定要确保包装类的引用不为空)</span><br></pre></td></tr></table></figure>
<p>System.out.println(i1+2);<br>//i1是我们上面通过自动装箱得到的一个integer对象，而这个对象是不能直接进行四则运算的，但是我们却给它+2，<br>这样就必须将integer对象转变为基本数据类型（int），这个过程就是自动拆箱的过程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">jdk装箱池（方法区中的常量池）：java的八种基本类型（Byte Short、Integer、Long、Character、Boolean、Float、Double），除Float及Double意外，其它六种都实现了常量池，但是他们只在大于等于-128且小于等于127时才能使用常量池，如果不在此范围内，则会new一个出来，保存在堆内存中。</span><br><span class="line"></span><br><span class="line">例子：</span><br></pre></td></tr></table></figure>
<pre><code>Integer a = 1;
Integer b = 1;
Integer c = 144;
Integer d = 144;
Integer a1 = new Integer(1);
Integer b1 = new Integer(1);
System.out.println(a == b);         //true
System.out.println(a.equals(b));    //true
System.out.println(a1 == b1);       //false
System.out.println(a1.equals(b1));  //true
System.out.println(c == d);         //false
System.out.println(c.equals(d));    //true</code></pre><pre><code>
在进行==比较的时候，在自动装箱池范围内的数据的引用是相同的，范围外的是不同的。 

# 3.Java引用类型
Java有 5种引用类型（对象类型）：类 接口 数组 枚举 标注
引申：Java中的堆内存、栈内存、静态存储区
&gt; http://www.cnblogs.com/mingziday/p/4899212.html

栈（stack）存放基础数据类型以及对象的对象的引用

堆（heap）存放由new创建的对象和数组，即堆主要是用来存储对象的

方法区中的静态存储区存储static声明的静态变量

# 4.java字符编码
&gt; http://kxjhlele.iteye.com/blog/333211
</code></pre>]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
  </entry>
  <entry>
    <title>java异常体系结构</title>
    <url>/2018/08/08/java/javase/exception/</url>
    <content><![CDATA[<h1 id="java异常体系结构图"><a href="#java异常体系结构图" class="headerlink" title="java异常体系结构图"></a>java异常体系结构图</h1><p><img src="/uploads/java/javase/%E5%BC%82%E5%B8%B8%E7%BB%93%E6%9E%84%E4%BD%93%E7%B3%BB.png" alt="java异常体系结构"></p>
<p>从图中可以发现（列出要点，简要说明）：</p>
<ul>
<li>所以异常类的父类为Throwable类（表示可抛出），直接继承为Error和Exception两个子类，Error也是异常的一种。</li>
<li>Error是程序无法处理的错误，它是由JVM产生和抛出的，比如OutOfMemoryError、ThreadDeath等。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。Exception是程序本身可以处理的异常，这种异常分两大类运行时异常和非运行时异常。程序中应当尽可能去处理这些异常。</li>
<li>RuntimeException（也称不检查异常）：即可以编译通过，一般由程序的逻辑错误引起，开发过程中应尽量避免。例如：NullPointerException，IndexOutOfBoundsException等。<strong>自定义异常一般继承此类</strong>。</li>
<li>RuntimeException以外的异常（IOException）：编译器在编译阶段进行处理，程序必须处理此类异常否则无法通过编译。</li>
</ul>
<h1 id="try-catch-finally-return"><a href="#try-catch-finally-return" class="headerlink" title="try-catch-finally-return"></a>try-catch-finally-return</h1><p>具体例子见(个人demo):</p>
<blockquote>
<p><a href="https://github.com/MarchNineteen/spring-example/blob/master/spring-example-test/src/main/java/com/wyb/test/java/exception/ReturnFinallyTest.java" target="_blank" rel="noopener">https://github.com/MarchNineteen/spring-example/blob/master/spring-example-test/src/main/java/com/wyb/test/java/exception/ReturnFinallyTest.java</a></p>
</blockquote>
<h1 id="自定义全局异常处理（配套源码）"><a href="#自定义全局异常处理（配套源码）" class="headerlink" title="自定义全局异常处理（配套源码）"></a>自定义全局异常处理（配套源码）</h1><blockquote>
<p><a href="https://github.com/MarchNineteen/spring-example/tree/master/spring-example-exception" target="_blank" rel="noopener">https://github.com/MarchNineteen/spring-example/tree/master/spring-example-exception</a></p>
</blockquote>
<h1 id="常见的异常打印信息"><a href="#常见的异常打印信息" class="headerlink" title="常见的异常打印信息"></a>常见的异常打印信息</h1><ul>
<li>getMessage(): 返回此throwable的详细消息字符串，只会获得具体的异常名称，比如说NullPoint 空指针,就告诉你说是空指针。</li>
<li>printStackTrace():提供对打印的堆栈跟踪信息的编程访问,会打出详细异常,异常名称,出错位置,便于调试用。</li>
<li>toString():返回此throwable的简短描述。</li>
</ul>
<h2 id="注意要点："><a href="#注意要点：" class="headerlink" title="注意要点："></a>注意要点：</h2><ul>
<li>多个catch模块，子类在先，为了保证所有的catch都有存在的意义</li>
<li>finally模块在try-catch的return或者异常处理之前执行</li>
<li>在以下4种特殊情况下，finally块不会被执行：<br>1）在finally语句块中抛出了异常且未处理。<br>2）在前面的代码中用了System.exit()退出程序。<br>3）程序所在的线程死亡。<br>4）CPU出现异常被关闭。</li>
</ul>
]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
  </entry>
  <entry>
    <title>java标识符与关键字</title>
    <url>/2018/05/16/java/javase/javaKeyWord/</url>
    <content><![CDATA[<h1 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h1><ul>
<li><p>概念：就是用于给程序中的变量、类、方法命名的符号;</p>
</li>
<li><p>标识符规则：标识符可以有字母、数字、下划线_、和美元符号$组成，并且数字不能打头<br>   标识符不能使java关键字和保留字，但可以包含关键字和保留字<br>   标识符不能包含空格 标识符只能包含美元符号$，不能包含@、#等其他特殊字符</p>
</li>
<li><p>分隔符：分号; 花括号{} 方括号[] 括号() 空格 圆点.;</p>
</li>
</ul>
<h1 id="Java关键字"><a href="#Java关键字" class="headerlink" title="Java关键字"></a>Java关键字</h1><p>java中包含50个关键，所有关键字都是小写的</p>
<pre><code>关键字列表：
 abstract抽象的            assert 
 boolean                   break 
 byte                      case
 catch                     char
 const(保留字)             continue
default                    do
 double                    else
 enum                      extends
 final                     finally
 float                     for
 if                        goto(保留字)
 implements                import
 int                       interface
 long                      native
 new                       package
 private                   protected
 public                    return 
 short                     static 
 strictfp                  super
 switch                    synchronized
 this                      throw
 throws                    transient
 try                       void 
 volatile                  while

 三个特殊的直接量（iteral）;true false null 都不是关键字


 final、finally、finalize的区别:
 final:
 final修饰变量，则等同于常量,变量不能修改
 final修饰方法中的参数，称为最终参数，参数不能修改。
 final修饰类，则类不能被继承
 final修饰方法，则方法不能被重写。
 finally:
 try-catch模块中使用finally，表示finally块则是无论异常是否发生，都会执行finally块的内容
 finalize:
 使用finalize在垃圾收集器确定这个对象未被引用时调用，表示在垃圾收集器将对象从内存中清除出去之前做一些清理工作。
 子类可以覆盖该方法以实现资源清理工作，GC在回收对象之前调用该方法</code></pre>]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
  </entry>
  <entry>
    <title>java正则表达式例子</title>
    <url>/2018/08/28/java/javase/regularExpression/</url>
    <content><![CDATA[<h1 id="正则表达式-文本框输入内容控制"><a href="#正则表达式-文本框输入内容控制" class="headerlink" title="[正则表达式]文本框输入内容控制"></a>[正则表达式]文本框输入内容控制</h1><ul>
<li>整数或者小数：^[0-9]+.{0,1}[0-9]{0,2}$</li>
<li>只能输入数字：”^[0-9]*$”。</li>
<li>只能输入n位的数字：”^\d{n}$”。</li>
<li>只能输入至少n位的数字：”^\d{n,}$”。</li>
<li>只能输入m~n位的数字：。”^\d{m,n}$”</li>
<li>只能输入零和非零开头的数字：”^(0|[1-9][0-9]*)$”。</li>
<li>只能输入有两位小数的正实数：”^[0-9]+(.[0-9]{2})?$”。</li>
<li>只能输入有1~3位小数的正实数：”^[0-9]+(.[0-9]{1,3})?$”。</li>
<li>只能输入非零的正整数：”^+?[1-9][0-9]*$”。</li>
<li>只能输入非零的负整数：”^-[1-9][]0-9”*$。</li>
<li>只能输入长度为3的字符：”^.{3}$”。</li>
<li>只能输入由26个英文字母组成的字符串：”^[A-Za-z]+$”。</li>
<li>只能输入由26个大写英文字母组成的字符串：”^[A-Z]+$”。</li>
<li>只能输入由26个小写英文字母组成的字符串：”^[a-z]+$”。</li>
<li>只能输入由数字和26个英文字母组成的字符串：”^[A-Za-z0-9]+$”。</li>
<li>只能输入由数字、26个英文字母或者下划线组成的字符串：”^\w+$”。</li>
<li>验证用户密码：”^[a-zA-Z]\w{5,17}$”正确格式为：以字母开头，长度在6~18之间，只能包含字符、数字和下划线。</li>
<li>验证是否含有^%&amp;’,;=?$&quot;等字符：”[^%&amp;’,;=?$\x22]+”。</li>
<li>只能输入汉字：”^[\u4e00-\u9fa5]{0,}$”</li>
<li>验证Email地址：”^\w+([-+.]\w+)<em>@\w+([-.]\w+)*.\w+([-.]\w+)</em>$”。</li>
<li>验证InternetURL：”^http://([\w-]+.)+[\w-]+(/[\w-./?%&amp;=]*)?$”。</li>
<li>验证电话号码：”^((\d{3,4}-)|\d{3.4}-)?\d{7,8}$”正确格式为：”XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX”。</li>
<li>验证身份证号（15位或18位数字）：”^\d{15}|\d{18}$”。</li>
<li>验证一年的12个月：”^(0?[1-9]|1[0-2])$”正确格式为：”01”～”09”和”1”～”12”。</li>
<li>验证一个月的31天：”^((0?[1-9])|((1|2)[0-9])|30|31)$”正确格式为；”01”～”09”和”1”～”31”。</li>
<li>匹配中文字符的正则表达式： [\u4e00-\u9fa5]</li>
<li>匹配双字节字符(包括汉字在内)：[^\x00-\xff]</li>
<li>应用：计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）</li>
<li>String.prototype.len=function(){return this.replace(/[^\x00-\xff]/g,”aa”).length;}</li>
<li>匹配空行的正则表达式：\n[\s| ]*\r</li>
<li>匹配html标签的正则表达式：&lt;(.<em>)&gt;(.</em>)&lt;/(.<em>)&gt;|&lt;(.</em>)/&gt;</li>
<li>匹配首尾空格的正则表达式：(^\s<em>)|(\s</em>$)</li>
</ul>
]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
  </entry>
  <entry>
    <title>java 1.8  steam流操作</title>
    <url>/2020/01/11/java/javase/streamApiAction/</url>
    <content><![CDATA[<p><a href="https://github.com/MarchNineteen/spring-example/blob/master/spring-example-test/src/main/java/com/wyb/test/java/java8/StreamApiAction.java" target="_blank" rel="noopener">相应源码地址</a></p>
<h2 id="流操作类型"><a href="#流操作类型" class="headerlink" title="流操作类型"></a>流操作类型</h2><h3 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h3><p>目的是打开一个流，做出一些操作或者映射后，会返回一个新的流交给下个操作。lazy的，在调用方式时并没有真正执行。</p>
<h3 id="终止操作"><a href="#终止操作" class="headerlink" title="终止操作"></a>终止操作</h3><p>在执行这个操作后，流被使用，在出现终止操作时才会调用之前的所有方法。</p>
<h3 id="short-circuiting"><a href="#short-circuiting" class="headerlink" title="short-circuiting"></a>short-circuiting</h3><p>对于一个 intermediate 操作，如果它接受的是一个无限大（infinite/unbounded）的 Stream，但返回一个有限的新 Stream。<br>对于一个 terminal 操作，如果它接受的是一个无限大的 Stream，但能在有限的时间计算出结果。</p>
<h2 id="具体流操作"><a href="#具体流操作" class="headerlink" title="具体流操作"></a>具体流操作</h2><h3 id="中间操作-1"><a href="#中间操作-1" class="headerlink" title="中间操作"></a>中间操作</h3><ul>
<li>map (mapToInt, flatMap 等)</li>
</ul>
<p>把input Stream 的每一个元素，映射成 output Stream 的另外一个元素。</p>
<p>map一对一</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;list中数的平方</span><br><span class="line">list.stream().map(v -&gt; v * v)</span><br></pre></td></tr></table></figure>

<p>flatMap一对多 多对多 映射,把流扁平化，多个流转化成流里所有元素的单个流。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list1 &#x3D; Arrays.asList(1, 2, 3, 4, 5);</span><br><span class="line">List&lt;Integer&gt; list2 &#x3D; Arrays.asList(6, 7, 8, 9, 10);</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; allList &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">allList.add(list1);</span><br><span class="line">allList.add(list2);</span><br><span class="line">        </span><br><span class="line">allList.stream().flatMap(v -&gt; v.stream()).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<ul>
<li>filter </li>
</ul>
<p>过滤,对元素进行某种条件过滤，留下符合的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 留下偶数</span><br><span class="line">list.stream().filter(v -&gt; v % 2 &#x3D;&#x3D; 0).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<ul>
<li>distinct </li>
</ul>
<p>去重，不接收方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list.stream().distinct().forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<ul>
<li>sorted</li>
</ul>
<p>排序，接受一个Comparator，或者默认顺序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list.stream().sorted()</span><br><span class="line">list.stream().sorted((o1, o2) -&gt; -1)</span><br></pre></td></tr></table></figure>

<ul>
<li>peek</li>
</ul>
<p>peek 对每个元素执行操作并返回一个新的 Stream。类似foreach，foreach是终止操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list &#x3D; list.stream().peek(System.out::println).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<ul>
<li>limit</li>
</ul>
<p>返回 Stream 的前面 n 个元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list.stream().limit(2).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<ul>
<li>skip</li>
</ul>
<p>扔掉前 n 个元素（它是由一个叫 subStream 的方法改名而来）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list.stream().skip(2).forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<ul>
<li>parallel</li>
</ul>
<p>转行成并行流，进行多线程操作，顺序会改变。可以使用forEachOrdered，固定顺序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list.stream().parallel().forEach(System.out::println);</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">1</span><br><span class="line">5</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<ul>
<li>sequential</li>
</ul>
<p>并行流转为串行流</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list.parallelStream().forEach(System.out::println);</span><br><span class="line">list.parallelStream().sequential().forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<ul>
<li>unordered</li>
</ul>
<p><strong>消除了必须保持有序的流的约束</strong>,返回一个无序的等效的Stream，可能返回的是Stream本身，因为该Stream已经是无序的，或者该Stream的底层状态被修改为了无序.<br>一般用于并行的时候。例如TreeSet，或者流操作中指定顺序，会取消排序和指定顺序无效。</p>
<h3 id="终止操作-1"><a href="#终止操作-1" class="headerlink" title="终止操作"></a>终止操作</h3><ul>
<li>forEach</li>
</ul>
<p>forEach 不能修改自己包含的本地变量值，也不能用 break/return 之类的关键字提前结束循环。</p>
<ul>
<li><p>forEachOrdered</p>
</li>
<li><p>toArray</p>
</li>
<li><p>reduce</p>
</li>
</ul>
<p>这个方法的主要作用是把 Stream 元素组合起来。它提供一个起始值（种子），然后依照运算规则（BinaryOperator），和前面 Stream 的第一个、第二个、第 n 个元素组合。<br>从这个意义上说，字符串拼接、数值的 sum、min、max、average 都是特殊的 reduce。</p>
<p>注意：没有起始值，返回对象为Optional</p>
<ul>
<li>collect</li>
</ul>
<p>两个方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;R&gt; R collect(Supplier&lt;R&gt; supplier,</span><br><span class="line">                  BiConsumer&lt;R, ? super T&gt; accumulator,</span><br><span class="line">                  BiConsumer&lt;R, R&gt; combiner);</span><br><span class="line">                  </span><br><span class="line">IntStream i &#x3D; IntStream.of(6,5,7,1, 2, 3, 3);</span><br><span class="line">  List&lt;Integer&gt; v &#x3D; i</span><br><span class="line">      .collect(ArrayList::new, ArrayList::add, ArrayList::addAll);</span><br><span class="line">  </span><br><span class="line">  System.out.println(v);</span><br><span class="line"></span><br><span class="line">&lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector);</span><br></pre></td></tr></table></figure>

<p>Collector在后面重点讲解</p>
<ul>
<li><p>min</p>
</li>
<li><p>max</p>
</li>
<li><p>count</p>
</li>
<li><p>anyMatch</p>
</li>
<li><p>allMatch</p>
</li>
<li><p>noneMatch</p>
</li>
<li><p>findFirst</p>
</li>
<li><p>findAny</p>
</li>
<li><p>iterator</p>
</li>
</ul>
<h3 id="Short-circuiting"><a href="#Short-circuiting" class="headerlink" title="Short-circuiting"></a>Short-circuiting</h3><ul>
<li><p>anyMatch</p>
</li>
<li><p>allMatch </p>
</li>
<li><p>noneMatch</p>
</li>
<li><p>findFirst </p>
</li>
<li><p>findAny </p>
</li>
<li><p>limit</p>
</li>
</ul>
<h2 id="Collectors"><a href="#Collectors" class="headerlink" title="Collectors"></a>Collectors</h2><p>要作用就是辅助进行各类有用的 reduction 操作，例如转变输出为 Collection，把 Stream 元素进行归组。</p>
<ul>
<li>类型归纳 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Collectors.toList();</span><br><span class="line">Collectors.toMap();</span><br><span class="line">Collectors.toSet();</span><br><span class="line">Collectors.toCollection();</span><br><span class="line">Collectors.toConcurrentMap();</span><br></pre></td></tr></table></figure>

<ul>
<li>joining</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; strList = Arrays.asList(<span class="string">"aa"</span>, <span class="string">"bb"</span>, <span class="string">"cc"</span>, <span class="string">"dd"</span>, <span class="string">"ee"</span>);</span><br><span class="line">String s = strList.stream().collect(Collectors.joining());</span><br><span class="line">System.out.println(s);</span><br><span class="line"><span class="comment">// 逗号连接</span></span><br><span class="line">s = strList.stream().collect(Collectors.joining(<span class="string">","</span>));</span><br><span class="line">System.out.println(s);</span><br><span class="line"><span class="comment">// 逗号连接</span></span><br><span class="line">s = strList.stream().collect(Collectors.joining(<span class="string">","</span>, <span class="string">"["</span>, <span class="string">"]"</span>));</span><br><span class="line">System.out.println(s);</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">- collectingAndThen</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">s = strList.stream().collect(Collectors.collectingAndThen(Collectors.joining(<span class="string">","</span>), String::toUpperCase));</span><br></pre></td></tr></table></figure>

<ul>
<li>groupingBy groupingByConcurrent</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, List&lt;String&gt;&gt; map = strList.stream().collect(Collectors.groupingBy(String::length));</span><br><span class="line">map.keySet().forEach(v -&gt; map.get(v).forEach(System.out::println));</span><br><span class="line">    </span><br><span class="line">Map&lt;Integer, Set&lt;String&gt;&gt; map1 = strList.stream().collect(Collectors.groupingBy(String::length, Collectors.toSet();</span><br></pre></td></tr></table></figure>

<ul>
<li>partitioningBy</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Boolean, List&lt;Integer&gt;&gt; mapBoolean = list.stream().collect(Collectors.partitioningBy(v -&gt; v % <span class="number">2</span> == <span class="number">0</span>));</span><br><span class="line">mapBoolean.keySet().forEach(v -&gt; mapBoolean.get(v).forEach(System.out::println));</span><br></pre></td></tr></table></figure>

<ul>
<li>summingInt/Double/Long summarizingInt/Double/Long</li>
</ul>
]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
  </entry>
  <entry>
    <title>java线程解析</title>
    <url>/2019/03/02/java/javase/thread/</url>
    <content><![CDATA[<h1 id="一些概念："><a href="#一些概念：" class="headerlink" title="一些概念："></a>一些概念：</h1><p>并行与并发：</p>
<ul>
<li>并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是<strong>真正的同时</strong>。 </li>
<li>并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反应这个系统的处理能力。</li>
<li>线程安全：经常用来描绘一段代码。指在并发的情况之下，该代码经过多线程使用，线程的调度顺序不影响任何结果。这个时候使用多线程，我们只需要关注系统的内存，cpu是不是够用即可。反过来，线程不安全就意味着线程的调度顺序会影响最终结果。</li>
<li>同步：Java中的同步指的是通过人为的控制和调度，保证共享资源的多线程访问成为线程安全，来保证结果的准确。如上面的代码简单加入@synchronized关键字。在保证结果准确的同时，提高性能，才是优秀的程序。线程安全的优先级高于性能。</li>
<li>volatile：多线程的内存模型：main memory（主存）、working memory（线程栈），在处理数据时，线程会把值从主存load到本地栈，完成操作后再save回去(volatile关键词的作用：每次针对该变量的操作都激发一次load and save)。<br>针对多线程使用的变量如果不是volatile或者final修饰的，很有可能产生不可预知的结果（另一个线程修改了这个值，但是之后在某线程看到的是修改之前的值）。其实道理上讲同一实例的同一属性本身只有一个副本。但是多线程是会缓存值的，本质上，volatile就是不去缓存，直接取值。在线程安全的情况下加volatile会牺牲性能。</li>
</ul>
<p><img src="https://github.com/MarchNineteen/spring-example/blob/master/spring-example-thread/src/main/resources/static/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%86%85%E5%AD%98%E5%8E%9F%E5%9E%8B.jpg" alt="多线程内存原型"> </p>
<h1 id="线程状态-amp-状态切换"><a href="#线程状态-amp-状态切换" class="headerlink" title="线程状态&amp;状态切换"></a>线程状态&amp;状态切换</h1><p><img src="http://upload-images.jianshu.io/upload_images/4942449-8f4ad7b6ac7009c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="线程状态转换"> </p>
<h2 id="对象方法："><a href="#对象方法：" class="headerlink" title="对象方法："></a>对象方法：</h2><ul>
<li>wait()：当前线程放弃对象锁，使该线程处于<strong>等待池</strong>(wait blocked pool),直到notify()/notifyAll()，线程被唤醒被放到<strong>锁定池</strong>(lock blocked pool )，释放同步锁使线程回到可运行状态（Runnable）。</li>
<li>notify():从对象的等待池中移走一个任意的线程并放到锁标志等待池中，只有锁标志等待池中线程能够获取锁标志；如果锁标志等待池中没有线程，则notify()不起作用。</li>
<li>notifyAll(): notifyAll()则从对象等待池中移走所有等待那个对象的线程并放到锁标志等待池中。</li>
</ul>
<p>注意点：<a href="https://github.com/MarchNineteen/spring-example/blob/master/spring-example-thread/src/main/java/com/wyb/thread/base/synchronize" target="_blank" rel="noopener">源码</a></p>
<ul>
<li><strong>wait()当前线程立即释放对象锁，notify() notifyAll() 之后 才会执行剩下代码</strong></li>
<li><strong>notify() notifyAll() 本身不会释放锁，仅仅是通知，当同步块执行完毕之后才会释放锁</strong>。</li>
</ul>
<h2 id="Thread线程方法："><a href="#Thread线程方法：" class="headerlink" title="Thread线程方法："></a>Thread线程方法：</h2><ul>
<li>yield():正在执行的线程把运行机会交给线程池中拥有相同优先级的线程，无法保证迅速转换，运行状态转到可运行状态.</li>
<li>join():使得一个线程在另一个线程结束后再执行。在一个线程中调用other.join(),将等待other执行完后才继续本线程。</li>
<li>sleep():不会释放对象锁，暂停一段时间。</li>
<li>interrupt()：后两个函数皆可以被打断。</li>
</ul>
<p>使用condition控制线程通信：</p>
<ul>
<li>await(),类似wait()</li>
<li>signal() 类似notify</li>
<li>signalAll()类似notifyAll</li>
</ul>
<h1 id="高级多线程控制类："><a href="#高级多线程控制类：" class="headerlink" title="高级多线程控制类："></a>高级多线程控制类：</h1><h2 id="1-ThreadLocal类"><a href="#1-ThreadLocal类" class="headerlink" title="1.ThreadLocal类:"></a>1.ThreadLocal类:</h2><h2 id="2-原子类（AtomicInteger、AtomicBoolean……）"><a href="#2-原子类（AtomicInteger、AtomicBoolean……）" class="headerlink" title="2.原子类（AtomicInteger、AtomicBoolean……）"></a>2.原子类（AtomicInteger、AtomicBoolean……）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; cas方法</span><br><span class="line">public final boolean compareAndSet(int expect, int update) &#123;</span><br><span class="line">&#x2F;&#x2F;使用unsafe的native方法，实现高效的硬件级别CAS</span><br><span class="line">return unsafe.compareAndSwapInt(this, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-Lock类"><a href="#3-Lock类" class="headerlink" title="3.Lock类　"></a>3.Lock类　</h2><ul>
<li>Condition</li>
<li>ReentrantLock</li>
</ul>
<p><img src="https://github.com/MarchNineteen/spring-example/blob/master/spring-example-thread/src/main/resources/static/%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E8%8E%B7%E5%8F%96%E9%94%81%E8%BF%87%E7%A8%8B.jpg" alt="非公平锁获取锁过程"></p>
<p>公平锁和非公平锁不同之处在于，公平锁在获取锁的时候，不会先去检查state状态，而是直接执行aqcuire(1),即直接进入队列</p>
<p>so:由于公平锁需要关心队列的情况，得按照队列里的先后顺序来获取锁(会造成大量的线程上下文切换)，而非公平锁则没有这个限制。所以也就能解释非公平锁的效率会被公平锁更高。</p>
<ul>
<li>ReentrantReadWriteLock.ReadLock</li>
<li>ReentrantReadWriteLock.WriteLock</li>
</ul>
<h2 id="4-容器类"><a href="#4-容器类" class="headerlink" title="4.容器类"></a>4.容器类</h2><ul>
<li>BlockingQueue</li>
<li>ConcurrentHashMap</li>
</ul>
<h2 id="5-管理类"><a href="#5-管理类" class="headerlink" title="5.管理类"></a>5.管理类</h2><ul>
<li>ThreadPoolExecutor</li>
</ul>
<p>线程池构成方法参数：</p>
<p>1.指定核心线程数量</p>
<p>2.</p>
<p>队列排队策略：</p>
<p>同步移交：不会放到队列中，而是等待线程执行它。如果当前线程没有执行，很可能会新开一个线程执行。</p>
<p>核心线程满了，接下来进队列，队列也满了，创建新线程，直到达到最大线程数，之后再超出，会进入拒绝rejectedExecution</p>
<ul>
<li>JMX框架下的系统级管理类 ThreadMXBean</li>
</ul>
]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
  </entry>
  <entry>
    <title>JVM调优</title>
    <url>/2021/10/31/java/jvm/jvm%E8%B0%83%E4%BC%98/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://www.cnblogs.com/likehua/p/3369823.html" target="_blank" rel="noopener">https://www.cnblogs.com/likehua/p/3369823.html</a></p>
</blockquote>
<blockquote>
<p>实战<a href="https://juejin.cn/post/7025410482341150751?utm_source=gold_browser_extension#heading-8" target="_blank" rel="noopener">https://juejin.cn/post/7025410482341150751?utm_source=gold_browser_extension#heading-8</a> </p>
</blockquote>
<h1 id="1-堆大小设置"><a href="#1-堆大小设置" class="headerlink" title="1.堆大小设置"></a>1.堆大小设置</h1><p>典型设置</p>
<p>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k</p>
<ul>
<li><p>-Xmx3550m:设置JVM最大可用内存为3550M</p>
</li>
<li><p>-Xms3550m:设置JVM初始内存为3550m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存</p>
</li>
<li><p>-Xmn2g:设置年轻代大小为2G。整个JVM内存大小=年轻代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。<br>此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8</p>
</li>
<li><p>-Xss128k：设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。更具应用的线程所需内存大小进行调整。<br>在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。</p>
</li>
</ul>
<p>java -Xmx3550m -Xms3550m -Xss128k -XX:NewRatio=4 -XX:SurvivorRatio=4 -XX:MaxPermSize=16m -XX:MaxTenuringThreshold=0</p>
<ul>
<li><p>-XX:NewRatio=4:设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1/5</p>
</li>
<li><p>-XX:SurvivorRatio=4：设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6</p>
</li>
<li><p>-XX:MaxPermSize=16m:设置持久代大小为16m。</p>
</li>
<li><p>-XX:MaxTenuringThreshold=0：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。<br>对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，<br>增加在年轻代即被回收的概论。</p>
</li>
</ul>
<h1 id="2-回收器选择"><a href="#2-回收器选择" class="headerlink" title="2.回收器选择"></a>2.回收器选择</h1><p>JVM给了三种选择：<strong>串行收集器、并行收集器、并发收集器</strong>，但是串行收集器只适用于小数据量的情况，所以这里的选择主要针对并行收集器和并发收集器。<br>默认情况下，JDK5.0以前都是使用串行收集器，如果想使用其他收集器需要在启动时加入相应参数。JDK5.0以后，JVM会根据当前系统配置进行判断。</p>
<h2 id="2-1-吞吐量优先的并行收集器"><a href="#2-1-吞吐量优先的并行收集器" class="headerlink" title="2.1 吞吐量优先的并行收集器"></a>2.1 吞吐量优先的并行收集器</h2><p>如上文所述，并行收集器主要以到达一定的吞吐量为目标，适用于科学技术和后台处理等。</p>
<p>典型配置：<br>java -Xmx3800m -Xms3800m -Xmn2g -Xss128k <strong>-XX:+UseParallelGC -XX:ParallelGCThreads=20</strong></p>
<p>-XX:+UseParallelGC：选择垃圾收集器为并行收集器。此配置仅对年轻代有效。即上述配置下，年轻代使用并发收集，而年老代仍旧使用串行收集。<br>-XX:ParallelGCThreads=20：配置并行收集器的线程数，即：同时多少个线程一起进行垃圾回收。此值最好配置与处理器数目相等。</p>
<p>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=20 <strong>-XX:+UseParallelOldGC</strong><br>-XX:+UseParallelOldGC：配置年老代垃圾收集方式为并行收集。JDK6.0支持对年老代并行收集。</p>
<p>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k <strong>-XX:+UseParallelGC  -XX:MaxGCPauseMillis=100</strong><br>-XX:MaxGCPauseMillis=100:设置每次年轻代垃圾回收的最长时间，如果无法满足此时间，JVM会自动调整年轻代大小，以满足此值。</p>
<p>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC  -XX:MaxGCPauseMillis=100 <strong>-XX:+UseAdaptiveSizePolicy</strong><br>-XX:+UseAdaptiveSizePolicy：设置此选项后，并行收集器会自动选择年轻代区大小和相应的Survivor区比例，以达到目标系统规定的最低相应时间或者收集频率等，此值建议使用并行收集器时，一直打开。</p>
<h2 id="2-2-响应时间优先的并发收集器"><a href="#2-2-响应时间优先的并发收集器" class="headerlink" title="2.2 响应时间优先的并发收集器"></a>2.2 响应时间优先的并发收集器</h2><p>如上文所述，并发收集器主要是保证系统的响应时间，减少垃圾收集时的停顿时间。适用于应用服务器、电信领域等。</p>
<p>典型配置：<br>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:ParallelGCThreads=20 <strong>-XX:+UseConcMarkSweepGC -XX:+UseParNewGC</strong><br>-XX:+UseConcMarkSweepGC：设置年老代为并发收集。测试中配置这个以后，-XX:NewRatio=4的配置失效了，原因不明。所以，此时年轻代大小最好用-Xmn设置。<br>-XX:+UseParNewGC:设置年轻代为并行收集。可与CMS收集同时使用。JDK5.0以上，JVM会根据系统配置自行设置，所以无需再设置此值。</p>
<p>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseConcMarkSweepGC <strong>-XX:CMSFullGCsBeforeCompaction=5 -XX:+UseCMSCompactAtFullCollection</strong><br>-XX:CMSFullGCsBeforeCompaction：由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行多少次GC以后对内存空间进行压缩、整理。<br>-XX:+UseCMSCompactAtFullCollection：打开对年老代的压缩。可能会影响性能，但是可以消除碎片</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>dubbo注册中心</title>
    <url>/2021/09/12/%E5%88%86%E5%B8%83%E5%BC%8F%E6%A1%86%E6%9E%B6%E4%B8%93%E9%A2%98/dubbo/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/</url>
    <content><![CDATA[<h1 id="注册中心的作用"><a href="#注册中心的作用" class="headerlink" title="注册中心的作用"></a>注册中心的作用</h1><p>为了达到服务器动态扩容的目的，注册中心存储的服务器的地址信息和可用状态，并实时推送给订阅了相关服务的客户端。</p>
<p>一个完整的注册中心需要实现以下功能：</p>
<p>1.接收服务端的注册和客户端的引用，即 将服务与消费相关联，并支持多对多。<br>2.支持服务端宕机后能即时清楚其状态。<br>3.注册中心重启后，可以自动恢复注册的数据和订阅的请求。<br>4.注册中心自身的集群。</p>
<h1 id="Dubbo所支持的注册中心"><a href="#Dubbo所支持的注册中心" class="headerlink" title="Dubbo所支持的注册中心"></a>Dubbo所支持的注册中心</h1><p>1.Multicast注册中心:</p>
<ul>
<li>基于组网广播技术，只能用在局域网内，一般用于简单的测试服务</li>
</ul>
<p>2.zookeeper 注册中心(推荐)</p>
<p>3.Redis注册中心</p>
<p>4.Simple注册中心</p>
<h1 id="Redis-注册中心"><a href="#Redis-注册中心" class="headerlink" title="Redis 注册中心"></a>Redis 注册中心</h1><p>关于Redis注册中心我们需要了解两点，</p>
<ol>
<li>如何存储服务的注册与订阅关系</li>
<li>是当服务状态改变时如何即时更新</li>
</ol>
<h2 id="如何存储服务的注册与订阅关系"><a href="#如何存储服务的注册与订阅关系" class="headerlink" title="如何存储服务的注册与订阅关系"></a>如何存储服务的注册与订阅关系</h2><p>使用redis的发布订阅(pub/sub)模型。</p>
<p>redis中存储的数据结构。</p>
<p>服务端：<br>Reids中增加了一个Hash 类型的记录，其key为/dubbo/tuling.dubbo.server.UserService/providers。Value中分别存储了两个服务提供者的URL和有效期。</p>
<p><img src="/uploads/dubbo/Redis%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%A8%A1%E5%9E%8B.png" alt="Redis服务端模型.png"></p>
<p>客户端:<br>主 Key 为服务名和类型 </p>
<p>Map 中的 Key 为 URL 地址</p>
<p>Map 中的 Value 为过期时间，用于判断脏数据，脏数据由监控中心删除</p>
<h2 id="是当服务状态改变时如何即时更新"><a href="#是当服务状态改变时如何即时更新" class="headerlink" title="是当服务状态改变时如何即时更新"></a>是当服务状态改变时如何即时更新</h2><p>这里Dubbo采用的是定时心跳的机制 来维护服务URL的有效期，默认每30秒更新一次有效期。即URL对应的毫秒值。<br>具体代码参见：com.alibaba.dubbo.registry.redis.RedisRegistry#expireExecutor</p>
<p><img src="/uploads/dubbo/Redis%E5%BF%83%E8%B7%B3.png" alt="Redis心跳.png"></p>
<p>com.alibaba.dubbo.registry.redis.RedisRegistry#deferExpired<br>com.alibaba.dubbo.registry.integration.RegistryDirectory<br>com.alibaba.dubbo.registry.support.ProviderConsumerRegTable</p>
<h1 id="Zookeeper-注册中心"><a href="#Zookeeper-注册中心" class="headerlink" title="Zookeeper 注册中心"></a>Zookeeper 注册中心</h1><p>Zookeper是一个树型的目录服务，本身支持变更推送相比redis的实现Publish/Subscribe功能更稳定。</p>
<p>结构：<br><img src="/uploads/dubbo/Zookeeper%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83.png" alt="Zookeeper注册中心.png"></p>
]]></content>
      <categories>
        <category>dubbo</category>
      </categories>
  </entry>
  <entry>
    <title>dubbo调用模块</title>
    <url>/2021/09/12/%E5%88%86%E5%B8%83%E5%BC%8F%E6%A1%86%E6%9E%B6%E4%B8%93%E9%A2%98/dubbo/%E8%B0%83%E7%94%A8%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h2 id="一、Dubbo-调用模块基本组成"><a href="#一、Dubbo-调用模块基本组成" class="headerlink" title="一、Dubbo 调用模块基本组成"></a>一、Dubbo 调用模块基本组成</h2><ol>
<li>透明代理：通过动态代理技术，屏蔽远程调用细节以提高编程友好性。</li>
<li>负载均衡：当有多个提供者是，如何选择哪个进行调用的负载算法。</li>
<li>容错机制：当服务调用失败时采取的策略</li>
<li>调用方式：支持同步调用、异步调用</li>
</ol>
<p><img src="/uploads/dubbo/%E8%B0%83%E7%94%A8%E6%A8%A1%E5%9D%97.png" alt="调用模块.png"></p>
<h3 id="透明代理"><a href="#透明代理" class="headerlink" title="透明代理"></a>透明代理</h3><p>参见源码：<br>com.alibaba.dubbo.config.ReferenceConfig#createProxy<br>com.alibaba.dubbo.common.bytecode.ClassGenerator<br>com.alibaba.dubbo.rpc.proxy.javassist.JavassistProxyFactory</p>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>Dubbo 目前官方支持以下负载均衡策略：</p>
<ol>
<li>随机(random)：按权重设置随机概率。此为默认算法.</li>
<li>轮循(roundrobin):按公约后的权重设置轮循比率。</li>
<li>最少活跃调用数(leastactive):相同活跃数的随机，活跃数指调用前后计数差。</li>
<li>一致性Hash(consistenthash ):相同的参数总是发到同一台机器</li>
</ol>
<p>设置方式支持如下四种方式设置，优先级由低至高:</p>
<!-- 服务端级别-->
<p>&lt;dubbo:service interface=”…” loadbalance=”roundrobin” /&gt;</p>
<!-- 客户端级别-->
<p>&lt;dubbo:reference interface=”…” loadbalance=”roundrobin” /&gt;</p>
<!-- 服务端方法级别-->
<p>&lt;dubbo:service interface=”…”&gt;<br>    &lt;dubbo:method name=”…” loadbalance=”roundrobin”/&gt;<br></p>
<!-- 客户端方法级别-->
<p>&lt;dubbo:reference interface=”…”&gt;<br>    &lt;dubbo:method name=”…” loadbalance=”roundrobin”/&gt;<br></p>
<p>一至性hash 算法详解：<br><img src="/uploads/dubbo/%E4%B8%80%E8%87%B3%E6%80%A7hash.png" alt="一至性hash.png"></p>
<h3 id="容错"><a href="#容错" class="headerlink" title="容错"></a>容错</h3><p>Dubbo 官方目前支持以下容错策略：</p>
<ol>
<li>失败自动切换：调用失败后基于retries=“2”属性重试其它服务器</li>
<li>快速失败：快速失败，只发起一次调用，失败立即报错。</li>
<li>勿略失败：失败后勿略，不抛出异常给客户端。</li>
<li>失败重试：失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作</li>
<li>并行调用:只要一个成功即返回，并行调用指定数量机器，可通过 forks=”2”来设置最大并行数。</li>
<li>广播调用：广播调用所有提供者，逐个调用，任意一台报错则报错 设置方式支持如下两种方式设置，优先级由低至高<br>&lt;!–<br>Failover 失败自动切换 retries=”1” 切换次数<br>Failfast 快速失败<br>Failsafe 勿略失败<br>Failback 失败重试，5秒后仅重试一次<br>Forking 并行调用 forks=”2” 最大并行数<br>Broadcast 广播调用</li>
</ol>
<p>–&gt;<br>&lt;dubbo:service interface=”…” cluster=”broadcast” /&gt;<br>&lt;dubbo:reference interface=”…” cluster=”broadcast”/ &gt;<br>注：容错机制 在基于 API设置时无效 如 referenceConfig.setCluster(“failback”); 经测试不启作用 </p>
<h3 id="异步调用"><a href="#异步调用" class="headerlink" title="异步调用"></a>异步调用</h3><p>异步调用是指发起远程调用之后获取结果的方式。</p>
<ol>
<li>同步等待结果返回（默认）</li>
<li>异步等待结果返回</li>
<li>不需要返回结果</li>
</ol>
<p>Dubbo 中关于异步等待结果返回的实现流程如下图：</p>
<p><img src="/uploads/dubbo/%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8.png" alt="异步调用.png"></p>
<p>异步调用配置:<br>&lt;dubbo:reference id=”asyncDemoService”<br>interface=”com.tuling.teach.service.async.AsyncDemoService”&gt;</p>
<!-- 异步调async：true 异步调用 false 同步调用-->
<p>&lt;dubbo:method name=”sayHello1” async=”false”/&gt;<br>&lt;dubbo:method name=”sayHello2” async=”false”/&gt;<br>&lt;dubbo:method name=”notReturn” return=”false”/&gt;<br></p>
<p>注：在进行异步调用时 容错机制不能为  cluster=”forking” 或  cluster=”broadcast”</p>
<h2 id="二、Dubbo-调用非典型使用场景"><a href="#二、Dubbo-调用非典型使用场景" class="headerlink" title="二、Dubbo 调用非典型使用场景"></a>二、Dubbo 调用非典型使用场景</h2><h3 id="泛化提供-amp-引用"><a href="#泛化提供-amp-引用" class="headerlink" title="泛化提供&amp;引用"></a>泛化提供&amp;引用</h3><p>泛化提供<br>是指不通过接口的方式直接将服务暴露出去。通常用于Mock框架或服务降级框架实现。</p>
<p>泛化引用<br>是指不通过常规接口的方式去引用服务，通常用于测试框架</p>
<h3 id="隐示传参"><a href="#隐示传参" class="headerlink" title="隐示传参"></a>隐示传参</h3><p>是指通过非常方法参数传递参数，类似于http 调用当中添加cookie值。通常用于分布式追踪框架的实现。使用方式如下 ：<br>//客户端隐示设置值<br>RpcContext.getContext().setAttachment(“index”, “1”); // 隐式传参，后面的远程调用都会隐<br>//服务端隐示获取值<br>String index = RpcContext.getContext().getAttachment(“index”);</p>
<h3 id="令牌验证"><a href="#令牌验证" class="headerlink" title="令牌验证"></a>令牌验证</h3><p>通过令牌验证在注册中心控制权限，以决定要不要下发令牌给消费者，可以防止消费者绕过注册中心访问提供者，<br>另外通过注册中心可灵活改变授权方式，而不需修改或升级提供者</p>
<h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p>类似于 WEB 中的Filter ，Dubbo本身提供了Filter 功能用于拦截远程方法的调用。其支持自定义过滤器与官方的过滤器使用：</p>
<p>演示添加日志访问过滤:</p>
<p>&lt;dubbo:provider filter=”accesslog” accesslog=”logs/dubbo.log”/&gt;<br>以上配置 就是 为 服务提供者 添加 日志记录过滤器， 所有访问日志将会集中打印至 accesslog 当中</p>
<h2 id="三、Dubbo调用流程"><a href="#三、Dubbo调用流程" class="headerlink" title="三、Dubbo调用流程"></a>三、Dubbo调用流程</h2><p><img src="/uploads/dubbo/Dubbo%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B.png" alt="Dubbo调用流程.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//------ 6协议 调用</span></span><br><span class="line">doInvoke:<span class="number">77</span>, DubboInvoker &#123;org.apache.dubbo.rpc.protocol.dubbo&#125;</span><br><span class="line">invoke:<span class="number">155</span>, AbstractInvoker &#123;org.apache.dubbo.rpc.protocol&#125;</span><br><span class="line"><span class="comment">//------ 5异步转同步</span></span><br><span class="line">invoke:<span class="number">52</span>, AsyncToSyncInvoker &#123;org.apache.dubbo.rpc.protocol&#125; <span class="comment">// 异步转同步 ,返回结果之前进行阻塞调用线程</span></span><br><span class="line"><span class="comment">//----- 4过滤器链</span></span><br><span class="line">invoke:<span class="number">92</span>, MonitorFilter &#123;org.apache.dubbo.monitor.support&#125;  <span class="comment">// 过滤链-&gt; 监控器</span></span><br><span class="line">invoke:<span class="number">54</span>, FutureFilter &#123;org.apache.dubbo.rpc.protocol.dubbo.filter&#125;    <span class="comment">//过滤链-&gt; 回调参数</span></span><br><span class="line">invoke:<span class="number">14</span>, ProviderHelloFilter &#123;com.wyb.dubbo&#125;  <span class="comment">// 过滤链-&gt; 自定义过滤器</span></span><br><span class="line">invoke:<span class="number">60</span>, ConsumerContextFilter &#123;org.apache.dubbo.rpc.filter&#125; <span class="comment">// 过滤链-&gt; 消费者环境初始化</span></span><br><span class="line"><span class="comment">//------3集群处理</span></span><br><span class="line">doInvoke:<span class="number">82</span>, FailoverClusterInvoker &#123;org.apache.dubbo.rpc.cluster.support&#125; <span class="comment">// 集服-失败重试</span></span><br><span class="line">invoke:<span class="number">248</span>, AbstractClusterInvoker &#123;org.apache.dubbo.rpc.cluster.support&#125; <span class="comment">//</span></span><br><span class="line"><span class="comment">//----- Mock服务</span></span><br><span class="line">invoke:<span class="number">78</span>, MockClusterInvoker &#123;org.apache.dubbo.rpc.cluster.support.wrapper&#125; <span class="comment">// mock 服务</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//----- 2动态代理 --透明化</span></span><br><span class="line">invoke:<span class="number">55</span>, InvokerInvocationHandler &#123;org.apache.dubbo.rpc.proxy&#125;<span class="comment">// 代理的中间接口</span></span><br><span class="line">getUser:-<span class="number">1</span>, proxy0 &#123;org.apache.dubbo.common.bytecode&#125; <span class="comment">// 代理对象</span></span><br><span class="line"><span class="comment">//----- 1调用客户端</span></span><br><span class="line">main:<span class="number">53</span>, DubboClient &#123;com.wyb.dubbo&#125;  <span class="comment">// 客户端</span></span><br><span class="line"></span><br><span class="line">RegistryProtocol --&gt; Cluster --&gt; MockClusterInvoker:ClusterInvoker-&gt;DubboProtocol-&gt;FilterChain:AsyncToSyncInvoker:DubboInvoker</span><br><span class="line">协议--》(注册协议)---&gt;MockClusterInvoker ---》ClusterInvoker---&gt; RegistryDirectory ---&gt;(DubboProtcol)-&gt;FilterChain--&gt;DubboInvoker</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>dubbo</category>
      </categories>
  </entry>
  <entry>
    <title>Executor线程池原理</title>
    <url>/2021/11/08/java/coucurrent/6.Executor%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="线程使用过程中存在的问题"><a href="#线程使用过程中存在的问题" class="headerlink" title="线程使用过程中存在的问题"></a>线程使用过程中存在的问题</h1><p>如果并发的请求数量非常多，但每个线程执行的时间很短，这样就会频繁的创建和销毁<br>线程，如此一来会大大降低系统的效率。可能出现服务器在为每个请求创建新线程和销毁线<br>程上花费的时间和消耗的系统资源要比处理实际的用户请求的时间和资源更多。</p>
<h1 id="线程池的使用场景-amp-优势"><a href="#线程池的使用场景-amp-优势" class="headerlink" title="线程池的使用场景&amp;优势"></a>线程池的使用场景&amp;优势</h1><p>什么时候使用线程池?</p>
<ul>
<li>单个任务处理时间比较短</li>
<li>需要处理的任务数量很大</li>
</ul>
<p>线程池优势</p>
<ul>
<li>重用存在的线程，减少线程创建，消亡的开销，提高性能 提高响应速度。 </li>
<li>当任务到达时，任务可以不需要的等到线程创建就能立即执行。 </li>
<li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，<br>使用线程池可以进行统一的分配，调优和监控。</li>
</ul>
<h1 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a>线程的实现方式</h1><p>Runnable,Thread,Callable</p>
<h3 id="Runnable"><a href="#Runnable" class="headerlink" title="Runnable"></a>Runnable</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现Runnable接口的类将被Thread执行，表示一个基本的任务 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// run方法就是它所有的内容，就是实际执行的任务 </span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span>; </span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestThread thread = <span class="keyword">new</span> TestThread();</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h3><p>有返回结果，用Future接收</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Callable同样是任务，与Runnable接口的区别在于它接收泛型，同时它执行任务后带 有返回内容</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123; </span><br><span class="line">    <span class="comment">// 相对于run方法的带有返回值的call方法</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception; </span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h1><p>Executor接口是线程池框架中最基础的部分，定义了一个用于执行Runnable的execute方法。</p>
<p>下图为它的继承与实现.</p>
<p><img src="/uploads/java/concurrent/%E7%BA%BF%E7%A8%8B%E6%B1%A0.png" alt="线程池.png"></p>
<p>从图中可以看出Executor下有一个重要子接口ExecutorService，其中定义了线程池的具体行为<br>1，execute（Runnable command）：履行Ruannable类型的任务,</p>
<p>2，submit（task）：可用来提交Callable或Runnable任务，并返回代表此任务的Future 对象</p>
<p>3，shutdown（）：在完成已提交的任务后封闭办事，不再接管新任务,</p>
<p>4，shutdownNow（）：停止所有正在履行的任务并封闭办事。</p>
<p>5，isTerminated（）：测试是否所有任务都履行完毕了。</p>
<p>6，isShutdown（）：测试是否该ExecutorService已被关闭</p>
<h1 id="线程池重点属性"><a href="#线程池重点属性" class="headerlink" title="线程池重点属性"></a>线程池重点属性</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING,<span class="number">0</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span> = <span class="number">29</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY = (<span class="number">1</span> &lt;&lt; COUNT_BITS)  - <span class="number">1</span> = workerCount;</span><br></pre></td></tr></table></figure>
<p>ctl 是对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段， 它包含两<br>部分的信息: 线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)，这<br>里可以看到，使用了Integer类型来保存，高3位保存runState，低29位保存<br>workerCount。COUNT_BITS 就是29，CAPACITY就是1左移29位减1（29个1），这个常<br>量表示workerCount的上限值，大约是5亿。</p>
<h3 id="ctl相关方法"><a href="#ctl相关方法" class="headerlink" title="ctl相关方法"></a>ctl相关方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>runStateOf：获取运行状态；</li>
<li>workerCountOf：获取活动线程数；</li>
<li>ctlOf：获取运行状态和活动线程数的值。</li>
</ul>
<p>线程池存在5种状态</p>
<ul>
<li>RUNNING = 1 &lt;&lt; COUNT_BITS; //高3位为111</li>
<li>SHUTDOWN = 0 &lt;&lt; COUNT_BITS; //高3位为000</li>
<li>STOP = 1 &lt;&lt; COUNT_BITS; //高3位为001</li>
<li>TIDYING = 2 &lt;&lt; COUNT_BITS; //高3位为010</li>
<li>TERMINATED = 3 &lt;&lt; COUNT_BITS; //高3位为011</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      System.out.println(toBin(-<span class="number">1</span> &lt;&lt; Integer.SIZE - <span class="number">3</span>));</span><br><span class="line">      System.out.println(toBin(<span class="number">0</span> &lt;&lt; Integer.SIZE - <span class="number">3</span>));</span><br><span class="line">      System.out.println(toBin(<span class="number">1</span> &lt;&lt; Integer.SIZE - <span class="number">3</span>));</span><br><span class="line">      System.out.println(toBin(<span class="number">2</span> &lt;&lt; Integer.SIZE - <span class="number">3</span>));</span><br><span class="line">      System.out.println(toBin(<span class="number">3</span> &lt;&lt; Integer.SIZE - <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">      <span class="number">11100000000000000000000000000000</span></span><br><span class="line">      <span class="number">00000000000000000000000000000000</span></span><br><span class="line">      <span class="number">00100000000000000000000000000000</span></span><br><span class="line">      <span class="number">01000000000000000000000000000000</span></span><br><span class="line">      <span class="number">01100000000000000000000000000000</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toBin</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] chs = <span class="keyword">new</span> <span class="keyword">char</span>[Integer.SIZE];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Integer.SIZE; i++) &#123;</span><br><span class="line">        chs[Integer.SIZE - <span class="number">1</span> - i] = (<span class="keyword">char</span>) ((num &gt;&gt; i &amp; <span class="number">1</span>) + <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(chs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1、RUNNING</p>
<p>(1) 状态说明：线程池处在RUNNING状态时，能够接收新任务，以及对已添加的任务进行<br>处理。</p>
<p>(2) 状态切换：线程池的初始化状态是RUNNING。换句话说，线程池被一旦被创建，就处<br>于RUNNING状态，并且线程池中的任务数为0！</p>
<p>2、 SHUTDOWN</p>
<p>(1) 状态说明：线程池处在SHUTDOWN状态时，不接收新任务，但能处理已添加的任务。</p>
<p>(2) 状态切换：调用线程池的shutdown()接口时，线程池由RUNNING -&gt; SHUTDOWN。</p>
<p>3、STOP</p>
<p>(1) 状态说明：线程池处在STOP状态时，不接收新任务，不处理已添加的任务，并且会中断正在处理的任务。</p>
<p>(2) 状态切换：调用线程池的shutdownNow()接口时，线程池由(RUNNING or SHUTDOWN ) -&gt; STOP。</p>
<p>4、TIDYING</p>
<p>(1) 状态说明：当所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为TIDYING<br>状态。当线程池变为TIDYING状态时，会执行钩子函数terminated()。terminated()在<br>ThreadPoolExecutor类中是空的，若用户想在线程池变为TIDYING时，进行相应的处理；<br>可以通过重载terminated()函数来实现。</p>
<p>(2) 状态切换：当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也<br>为空时，就会由 SHUTDOWN -&gt; TIDYING。 当线程池在STOP状态下，线程池中执行的<br>任务为空时，就会由STOP -&gt; TIDYING。</p>
<p>5、 TERMINATED</p>
<p>(1) 状态说明：线程池彻底终止，就变成TERMINATED状态。</p>
<p>(2) 状态切换：线程池处在TIDYING状态时，执行完terminated()之后，就会由 TIDYING -&gt; TERMINATED。</p>
<p>进入TERMINATED的条件如下：</p>
<ul>
<li>线程池不是RUNNING状态；</li>
<li>线程池状态不是TIDYING状态或TERMINATED状态；</li>
<li>如果线程池状态是SHUTDOWN并且workerQueue为空；</li>
<li>workerCount为0；</li>
<li>设置TIDYING状态成功</li>
</ul>
<p><img src="/uploads/java/concurrent/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81%E5%88%87%E6%8D%A2.jpg" alt="线程池状态切换.jpg"></p>
<h1 id="线程池的具体实现"><a href="#线程池的具体实现" class="headerlink" title="线程池的具体实现"></a>线程池的具体实现</h1><p>ThreadPoolExecutor 默认线程池</p>
<p>ScheduledThreadPoolExecutor 定时线程池</p>
<h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><h3 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">        TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">        BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">        ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">        RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure>
<h3 id="任务提交"><a href="#任务提交" class="headerlink" title="任务提交"></a>任务提交</h3><p>1、public void execute() //提交任务无返回值</p>
<p>2、public Future&lt;?&gt; submit() //任务执行完成后有返回值参数</p>
<h3 id="参数解释"><a href="#参数解释" class="headerlink" title="参数解释"></a>参数解释</h3><h4 id="corePoolSize"><a href="#corePoolSize" class="headerlink" title="corePoolSize"></a>corePoolSize</h4><p>线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当<br>前线程数等于corePoolSize；如果当前线程数为corePoolSize，继续提交的任务被保存到<br>阻塞队列中，等待被执行；如果执行了线程池的prestartAllCoreThreads()方法，线程池会<br>提前创建并启动所有核心线程。</p>
<h4 id="maximumPoolSize"><a href="#maximumPoolSize" class="headerlink" title="maximumPoolSize"></a>maximumPoolSize</h4><p>线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线<br>程执行任务，前提是当前线程数小于maximumPoolSize；</p>
<h4 id="keepAliveTime"><a href="#keepAliveTime" class="headerlink" title="keepAliveTime"></a>keepAliveTime</h4><p>线程池维护线程所允许的空闲时间。当线程池中的线程数量大于corePoolSize的时<br>候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待<br>的时间超过了keepAliveTime；</p>
<h4 id="unit"><a href="#unit" class="headerlink" title="unit"></a>unit</h4><p>keepAliveTime的单位；</p>
<h4 id="workQueue"><a href="#workQueue" class="headerlink" title="workQueue"></a>workQueue</h4><p>用来保存等待被执行的任务的阻塞队列，且任务必须实现Runable接口，在JDK中提供了如下阻塞队列：</p>
<ul>
<li>1、ArrayBlockingQueue：基于数组结构的有界阻塞队列，按FIFO排序任务；</li>
<li>2、LinkedBlockingQuene：基于链表结构的阻塞队列，按FIFO排序任务，吞<br>吐量通常要高于ArrayBlockingQuene；</li>
<li>3、SynchronousQuene：一个不存储元素的阻塞队列，每个插入操作必须等到<br>另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于<br>LinkedBlockingQuene；</li>
<li>4、priorityBlockingQuene：具有优先级的无界阻塞队列；</li>
</ul>
<h4 id="threadFactory"><a href="#threadFactory" class="headerlink" title="threadFactory"></a>threadFactory</h4><p>它是ThreadFactory类型的变量，用来创建新线程。默认使用<br>Executors.defaultThreadFactory() 来创建线程。使用默认的ThreadFactory来创建线程<br>时，会使新创建的线程具有相同的NORM_PRIORITY优先级并且是非守护线程，同时也设<br>置了线程的名称。</p>
<h4 id="handler"><a href="#handler" class="headerlink" title="handler"></a>handler</h4><p>线程池的饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了4种策略：</p>
<ul>
<li>1、AbortPolicy：直接抛出异常，默认策略；</li>
<li>2、CallerRunsPolicy：用调用者所在的线程来执行任务；</li>
<li>3、DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；</li>
<li>4、DiscardPolicy：直接丢弃任务；</li>
</ul>
<h3 id="线程池监控"><a href="#线程池监控" class="headerlink" title="线程池监控"></a>线程池监控</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getTaskCount</span><span class="params">()</span> <span class="comment">//线程池已执行与未执行的任务总数</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getCompletedTaskCount</span><span class="params">()</span> <span class="comment">//已完成的任务数</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPoolSize</span><span class="params">()</span> <span class="comment">//线程池当前的线程数</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getActiveCount</span><span class="params">()</span> <span class="comment">//线程池中正在执行任务的线程数量</span></span></span><br></pre></td></tr></table></figure>

<h3 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h3><p><img src="/uploads/java/concurrent/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86.jpg" alt="线程池运行原理.jpg"></p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1>]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
  </entry>
  <entry>
    <title>dubbo协议模块</title>
    <url>/2021/09/12/%E5%88%86%E5%B8%83%E5%BC%8F%E6%A1%86%E6%9E%B6%E4%B8%93%E9%A2%98/dubbo/%E5%8D%8F%E8%AE%AE%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<p><strong>课程概要：</strong></p>
<ol>
<li>RPC协议基本组成</li>
<li>RPC协议报文编码与实现详解</li>
<li>Dubbo中所支持RPC协议与使用<h3 id="RPC协议基本组成"><a href="#RPC协议基本组成" class="headerlink" title="## RPC协议基本组成"></a>## <strong>RPC协议基本组成</strong></h3></li>
</ol>
<hr>
<h3 id="RPC-协议名词解释"><a href="#RPC-协议名词解释" class="headerlink" title="RPC 协议名词解释"></a><strong>RPC 协议名词解释</strong></h3><p>在一个典型RPC的使用场景中，包含了服务发现、负载、容错、网络传输、序列化等组件，其中RPC协议就指明了程序如何进行网络传输和序列化 。也就是说一个RPC协议的实现就等于一个非透明的远程调用实现，如何做到的的呢？</p>
<p><img src="/uploads/dubbo/Rpc%E5%8D%8F%E8%AE%AE.png" alt="Rpc协议.png"></p>
<h3 id="协议基本组成："><a href="#协议基本组成：" class="headerlink" title="协议基本组成："></a><strong>协议基本组成：</strong></h3><p><img src="/uploads/dubbo/Rpc%E5%8D%8F%E8%AE%AE%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90.png" alt="Rpc协议基本组成.png"></p>
<ol>
<li>地址：服务提供者地址</li>
<li>端口：协议指定开放的端口</li>
<li>报文编码：协议报文编码 ，分为请求头和请求体两部分。</li>
<li>序列化方式：将请求体序列化成对象<ol>
<li>Hessian2Serialization、</li>
<li>DubboSerialization、</li>
<li>JavaSerialization</li>
<li>JsonSerialization</li>
</ol>
</li>
<li>运行服务: 网络传输实现<ol>
<li>netty</li>
<li>mina</li>
<li>RMI 服务</li>
<li>servlet 容器（jetty、Tomcat、Jboss）<h2 id="Dubbo中所支持RPC协议使用"><a href="#Dubbo中所支持RPC协议使用" class="headerlink" title="Dubbo中所支持RPC协议使用"></a><strong>Dubbo中所支持RPC协议使用</strong></h2></li>
</ol>
</li>
</ol>
<hr>
<p><strong>dubbo 支持的RPC协议列表</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>名称</strong></th>
<th align="left"><strong>实现描述</strong></th>
<th align="left"><strong>连接描述</strong></th>
<th align="left"><strong>适用场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>dubbo</strong></td>
<td align="left">传输服务: mina, netty(默认), grizzy序列化: hessian2(默认), java, fastjson自定义报文</td>
<td align="left">单个长连接NIO异步传输</td>
<td align="left">1、常规RPC调用2、传输数据量小3、提供者少于消费者</td>
</tr>
<tr>
<td align="left"><strong>rmi</strong></td>
<td align="left">传输：java rmi 服务序列化：java原生二进制序列化</td>
<td align="left">多个短连接BIO同步传输</td>
<td align="left">1、常规RPC调用  2、与原RMI客户端集成  3、可传少量文件  4、不防火墙穿透</td>
</tr>
<tr>
<td align="left"><strong>hessian</strong></td>
<td align="left">传输服务：servlet容器序列化：hessian二进制序列化</td>
<td align="left">基于Http 协议传输，依懒servlet容器配置</td>
<td align="left">1、提供者多于消费者  2、可传大字段和文件  <del>3、跨语言调用</del></td>
</tr>
<tr>
<td align="left"><strong>http</strong></td>
<td align="left">传输服务：servlet容器序列化：java原生二进制序列化</td>
<td align="left">依懒servlet容器配置</td>
<td align="left">1、数据包大小混合</td>
</tr>
<tr>
<td align="left"><strong>thrift</strong></td>
<td align="left">与thrift RPC 实现集成，并在其基础上修改了报文头</td>
<td align="left">长连接、NIO异步传输</td>
<td align="left"></td>
</tr>
</tbody></table>
<p><strong><em>关于RMI不支持防火墙穿透的补充说明：</em></strong></p>
<p>原因在于RMI 底层实现中会有两个端口，一个是固定的用于服务发现的注册端口，另外会生成一个<strong><em>随机</em></strong>端口用于网络传输。因为这个随机端口就不能在防火墙中提前设置开放开。所以存在<em>防火墙穿透问题</em></p>
<h3 id="协议的使用与配置"><a href="#协议的使用与配置" class="headerlink" title="协议的使用与配置:"></a><strong>协议的使用与配置:</strong></h3><p>Dubbo框架配置协议非常方便，用户只需要在 provider 应用中 配置*&lt;*<em>dubbo:protocol&gt;</em>元素即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line"> name: 协议名称 dubbo|rmi|hessian|http|</span><br><span class="line"> host:本机IP可不填，则系统自动获取</span><br><span class="line"> port：端口、填-1表示系统自动选择</span><br><span class="line"> server：运行服务 mina|netty|grizzy|servlet|jetty</span><br><span class="line"> serialization：序列化方式 hessian2|java|compactedjava|fastjson</span><br><span class="line"> 详细配置参见dubbo 官网 dubbo.io</span><br><span class="line">--&gt;</span><br><span class="line">&lt;dubbo:protocol name&#x3D;&quot;dubbo&quot; host&#x3D;&quot;192.168.0.11&quot; port&#x3D;&quot;20880&quot; server&#x3D;&quot;netty&quot;</span><br><span class="line"> serialization&#x3D;“hessian2” charset&#x3D;“UTF-8” &#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p>#TODO 演示采用其它协议来配置Dubbo</p>
<ul>
<li><input disabled type="checkbox"> dubbo 协议采用 json 进行序列化(源码参见：com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol<em>)</em></li>
<li><input disabled type="checkbox"> 采用RMI协议(源码参见：<em>com.alibaba.dubbo.rpc.protocol.rmi.RmiProtocol)</em></li>
<li><input disabled type="checkbox"> 采用Http协议(源码参见：<em>com.alibaba.dubbo.rpc.protocol.http.HttpProtocol.InternalHandler)</em></li>
<li><input disabled type="checkbox"> 采用Heason协议(源码参见:com.alibaba.dubbo.rpc.protocol.hessian.HessianProtocol.HessianHandler)</li>
</ul>
<p>new PrintWriter(System.out)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netstat -aon|findstr &quot;17732&quot;</span><br></pre></td></tr></table></figure>
<p>序列化：</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">特点</th>
</tr>
</thead>
<tbody><tr>
<td align="left">fastjson</td>
<td align="left">文本型：体积较大，性能慢、跨语言、可读性高</td>
</tr>
<tr>
<td align="left">fst</td>
<td align="left">二进制型：体积小、兼容 JDK 原生的序列化。要求 JDK 1.7 支持。</td>
</tr>
<tr>
<td align="left">hessian2</td>
<td align="left">二进制型：跨语言、容错性高、体积小</td>
</tr>
<tr>
<td align="left">java</td>
<td align="left">二进制型：在JAVA原生的基础上 可以写入Null</td>
</tr>
<tr>
<td align="left">compactedjava</td>
<td align="left">二进制型：与java 类似，内容做了压缩</td>
</tr>
<tr>
<td align="left">nativejava</td>
<td align="left">二进制型：原生的JAVA 序列化</td>
</tr>
<tr>
<td align="left">kryo</td>
<td align="left">二进制型：体积比hessian2 还要小，但容错性 没有hessian2 好</td>
</tr>
</tbody></table>
<h3 id="Hessian-序列化："><a href="#Hessian-序列化：" class="headerlink" title="Hessian 序列化："></a>Hessian 序列化：</h3><ul>
<li>参数及返回值需实现Serializable接口</li>
<li>参数及返回值不能自定义实现List,Map,Number,Date,Calendar等接口，只能用 JDK 自带的实现，因为 hessian 会做特殊处理，自定义实现类中的属性值都会丢失。</li>
<li>Hessian 序列化，只传成员属性值和值的类型，不传方法或静态变量，兼容情况<a href="http://dubbo.apache.org/zh-cn/docs/user/references/protocol/dubbo.html#fn1" target="_blank" rel="noopener">[1]</a><br><a href="http://dubbo.apache.org/zh-cn/docs/user/references/protocol/dubbo.html#fn2" target="_blank" rel="noopener">[2]</a></li>
</ul>
<table>
<thead>
<tr>
<th align="left"><strong>数据通讯</strong></th>
<th align="left"><strong>情况</strong></th>
<th align="left"><strong>结果</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">A-&gt;B</td>
<td align="left">类A多一种 属性（或者说类B少一种 属性）</td>
<td align="left">不抛异常，A多的那 个属性的值，B没有， 其他正常</td>
</tr>
<tr>
<td align="left">A-&gt;B</td>
<td align="left">枚举A多一种 枚举（或者说B少一种 枚举），A使用多 出来的枚举进行传输</td>
<td align="left">抛异常</td>
</tr>
<tr>
<td align="left">A-&gt;B</td>
<td align="left">枚举A多一种 枚举（或者说B少一种 枚举），A不使用 多出来的枚举进行传输</td>
<td align="left">不抛异常，B正常接 收数据</td>
</tr>
<tr>
<td align="left">A-&gt;B</td>
<td align="left">A和B的属性 名相同，但类型不相同</td>
<td align="left">抛异常</td>
</tr>
<tr>
<td align="left">A-&gt;B</td>
<td align="left">serialId 不相同</td>
<td align="left">正常传输</td>
</tr>
</tbody></table>
<p>接口增加方法，对客户端无影响，如果该方法不是客户端需要的，客户端不需要重新部署。输入参数和结果集中增加属性，对客户端无影响，如果客户端并不需要新属性，不用重新部署。</p>
<p>输入参数和结果集属性名变化，对客户端序列化无影响，但是如果客户端不重新部署，不管输入还是输出，属性名变化的属性值是获取不到的。</p>
<p>总结：服务器端和客户端对领域对象并不需要完全一致，而是按照最大匹配原则。</p>
<ul>
<li><input disabled type="checkbox"> 演示Hession2 序列化的容错性</li>
</ul>
<h2 id="三-、RPC协议报文编码与实现详解"><a href="#三-、RPC协议报文编码与实现详解" class="headerlink" title="三 、RPC协议报文编码与实现详解"></a><strong>三 、RPC协议报文编码与实现详解</strong></h2><hr>
<h3 id="RPC-传输实现："><a href="#RPC-传输实现：" class="headerlink" title="RPC 传输实现："></a><strong>RPC 传输实现：</strong></h3><p>RPC的协议的传输是基于 TCP/IP 做为基础使用Socket 或Netty、mina等网络编程组件实现。但有个问题是TCP是面向字节流的无边边界协议，其只管负责数据传输并不会区分每次请求所对应的消息，这样就会出现TCP协义传输当中的拆包与粘包问题</p>
<h3 id="拆包与粘包产生的原因："><a href="#拆包与粘包产生的原因：" class="headerlink" title="拆包与粘包产生的原因："></a><strong>拆包与粘包产生的原因：</strong></h3><p>我们知道tcp是以流动的方式传输数据，传输的最小单位为一个报文段（segment）。tcp Header中有个Options标识位，常见的标识为mss(Maximum Segment Size)指的是，连接层每次传输的数据有个最大限制MTU(Maximum Transmission Unit)，一般是1500比特，超过这个量要分成多个报文段，mss则是这个最大限制减去TCP的header，光是要传输的数据的大小，一般为1460比特。换算成字节，也就是180多字节。</p>
<p>tcp为提高性能，发送端会将需要发送的数据发送到缓冲区，等待缓冲区满了之后，再将缓冲中的数据发送到接收方。同理，接收方也有缓冲区这样的机制，来接收数据。这时就会出现以下情况：</p>
<ol>
<li>应用程序写入的数据大于MSS大小，这将会发生拆包。</li>
<li>应用程序写入数据小于MSS大小，这将会发生粘包。</li>
<li>接收方法不及时读取套接字缓冲区数据，这将发生粘包。<h3 id="拆包与粘包解决办法："><a href="#拆包与粘包解决办法：" class="headerlink" title="拆包与粘包解决办法："></a><strong>拆包与粘包解决办法：</strong></h3></li>
<li>设置定长消息，服务端每次读取既定长度的内容作为一条完整消息。</li>
<li>{“type”:”message”,”content”:”hello”}\n</li>
<li>使用带消息头的协议、消息头存储消息开始标识及消息长度信息，服务端获取消息头的时候解析出消息长度，然后向后读取该长度的内容。</li>
</ol>
<p><strong>比如：</strong>Http协议 heade 中的 Content-Length 就表示消息体的大小。</p>
<p><img src="/uploads/dubbo/Http%E5%8D%8F%E8%AE%AEhead.png" alt="http协议head.png"></p>
<h3 id="Dubbo-协议报文编码："><a href="#Dubbo-协议报文编码：" class="headerlink" title="Dubbo 协议报文编码："></a>Dubbo 协议报文编码：</h3><p><img src="/uploads/dubbo/Dubbo%E5%8D%8F%E8%AE%AE%E6%8A%A5%E6%96%87%E7%BC%96%E7%A0%81.png" alt="Dubbo协议报文编码.png"></p>
<ul>
<li><strong>magic</strong>：类似java字节码文件里的魔数，用来判断是不是dubbo协议的数据包。魔数是常量0xdabb,用于判断报文的开始。</li>
<li><strong>flag</strong>：标志位, 一共8个地址位。低四位用来表示消息体数据用的序列化工具的类型（默认hessian），高四位中，第一位为1表示是request请求，第二位为1表示双向传输（即有返回response），第三位为1表示是心跳ping事件。</li>
<li><strong>status</strong>：状态位, 设置请求响应状态，dubbo定义了一些响应的类型。具体类型见 com.alibaba.dubbo.remoting.exchange.Response</li>
<li><strong>invoke id：</strong>消息id, long 类型。每一个请求的唯一识别id（由于采用异步通讯的方式，用来把请求request和返回的response对应上）</li>
<li><strong>body length：</strong>消息体 body 长度, int 类型，即记录Body Content有多少个字节。</li>
</ul>
<p><img src="/uploads/dubbo/Dubbo%E5%8D%8F%E8%AE%AE%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.png" alt="img.png"></p>
<pre><code>*（注：相关源码参见**c**om.alibaba.dubbo.rpc.protocol.dubbo.DubboCodec**）*</code></pre><h3 id="Dubbo协议的编解码过程："><a href="#Dubbo协议的编解码过程：" class="headerlink" title="Dubbo协议的编解码过程："></a><strong><em>Dubbo协议的编解码过程：</em></strong></h3><p><img src="/uploads/dubbo/Dubbo%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%BC%96%E8%A7%A3%E7%A0%81%E8%BF%87%E7%A8%8B.png" alt="Dubbo协议的编解码过程.png"></p>
<p><strong>Dubbo 协议编解码实现过程*</strong>(源码来源于<em>*dubbo2.5.8 )</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、DubboCodec.encodeRequestData() 116L &#x2F;&#x2F; 编码request</span><br><span class="line">2、DecodeableRpcInvocation.decode()  89L   &#x2F;&#x2F; 解码request</span><br><span class="line">3、DubboCodec.encodeResponseData()   184L  &#x2F;&#x2F; 编码response    </span><br><span class="line">4、DecodeableRpcResult.decode()      73L   &#x2F;&#x2F; 解码response</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>dubbo</category>
      </categories>
  </entry>
  <entry>
    <title>JDK1.8 HashMap源码分析</title>
    <url>/2019/01/08/java/javase/hashMap/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/qq_36520235/article/details/82417949" target="_blank" rel="noopener">Hashmap的结构，1.7和1.8有哪些区别，史上最深入的分析</a><br><a href="https://www.cnblogs.com/Hangtutu/p/9251999.html" target="_blank" rel="noopener">jdk1.7死环</a><br><a href="https://juejin.im/post/5a66a08d5188253dc3321da0" target="_blank" rel="noopener">jdk1.7线程不安全</a><br><a href="https://blog.csdn.net/u013494765/article/details/77837338" target="_blank" rel="noopener">jdk1.8扩容核心-链表复制处理</a><br><a href="https://mp.weixin.qq.com/s/NvmqdPOyWQdeHG2s-xSbHg" target="_blank" rel="noopener">HashMap1.8面试连问</a><br><a href="https://blog.csdn.net/weixin_42340670/article/details/80503517?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3" target="_blank" rel="noopener">HashMap1.8源码解析：resize方法（有问题）</a></p>
<h1 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h1><p><img src="/uploads/java/javase/hashMap.png" alt="hashMap继承关系"></p>
<h1 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h1><pre><code>// Hash表结构
transient Node&lt;K,V&gt;[] table;

// 保证 fail-fast机制
transient int modCount;

// 下一次扩容时的阈值 (capacity * load factor).
int threshold;

// 负载因子，决定hash表的数据填充程度，此值越大说明hash表填充的越满，空间利用率高，但是增加了查询开销，此值若太小，hash表空间利用率不高且rehash更加频繁
final float loadFactor;    

// 默认初始容量,必须是2的次方
static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16

// 最大容量，2的30次方，因为int类型32位，去掉一位符号位，只能左移30位
static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;

// 默认负载因子
static final float DEFAULT_LOAD_FACTOR = 0.75f;

// jdk1.8增加 链表转红黑树的阈值
static final int TREEIFY_THRESHOLD = 8;

// jdk1.8增加 红黑树转链表的阈值
static final int UNTREEIFY_THRESHOLD = 6;</code></pre><h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p>HashMap一共有4个构造方法，主要的工作就是完成容量和加载因子的赋值。Hash表都是采用的<strong>懒加载</strong>方式，当第一次插入数据时才会创建。</p>
<pre><code>// 指定默认容量和负载因子   
public HashMap(int initialCapacity, float loadFactor) {
        if (initialCapacity &lt; 0)
            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +
                                               initialCapacity);
        if (initialCapacity &gt; MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +
                                               loadFactor);
        this.loadFactor = loadFactor;
        // 找到大于等于initialCapacity的最小的2的幂  若传入6 threshold=8
        this.threshold = tableSizeFor(initialCapacity);
}

// 使用默认负载因子
public HashMap(int initialCapacity) {
        this(initialCapacity, DEFAULT_LOAD_FACTOR);
}

// 参数全部都是默认值
public HashMap() {
       this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted
}

// 构造一个新的 HashMap与指定的相同的映射 Map 。 
public HashMap(Map&lt;? extends K, ? extends V&gt; m) {
        this.loadFactor = DEFAULT_LOAD_FACTOR;
        putMapEntries(m, false);
}</code></pre><h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><h2 id="添加一个元素put-K-k-V-v"><a href="#添加一个元素put-K-k-V-v" class="headerlink" title="添加一个元素put(K k,V v)"></a>添加一个元素put(K k,V v)</h2><p>HashMap允许K和V都为null，添加一个键值对时使用put方法，如果之前已经存在K的键值，那么旧值将会被新值替换。</p>
<pre><code>// return 前一个值与key相关联 ，或null如果没有key的映射。 （A null返回也可以指示以前关联的地图null与key。 
public V put(K key, V value) {
        return putVal(hash(key), key, value, false, true);
}

//先来看看hash方法，采用了Object的hash算法返回的是对象的内存地址,每个对象在内存中地址不一样，所以他们的hash值也不一样，不同的算法hashCode不同。
// 这里使用右移操作是为了让高位也参与运算提高散射率。低16位与高16位异或作为key的最终hash值。
// （h &gt;&gt;&gt; 16，表示无符号右移16位，高位补0，任何数跟0异或都是其本身，因此key的hash值高16位不变。） 
// 为什么要这么干呢？ 这个与HashMap中table下标的计算有关。n = table.length; index = （n-1） &amp; hash;因为，table的长度都是2的幂，因此index仅与hash值的低n位有关，hash值的高位都被与操作置为0了。 
// key为null 默认为0即数组第一个
static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
}

/**
 * @param hash key的Hash值 经过高位与地位的异或运算
 * @param key 
 * @param value 
 * @param onlyIfAbsent 如果是，则不要更改现有值
 * @param evict 如果为false，则表处于创建模式。
 * @return 返回旧值或者null值。
 */        
final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;
        // 如果哈希表的长度为空 调用resize()扩容方法 n为表长度
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
        // 如果当前数组下标为null值， (i = (n - 1) &amp; hash]即计算数组下标)，数组当前下标新建一个节点，即为头结点
        if ((p = tab[i = (n - 1) &amp; hash]) == null)
            tab[i] = newNode(hash, key, value, null);
        // 数组上该位置有值,桶处有节点，发生hash冲突
        else {
            Node&lt;K,V&gt; e; K k;
            // 如果头结点的值与添加的值一致，hash冲突后，key的值也一致，进行替换。将e指向p
            if (p.hash == hash &amp;&amp;
                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
                e = p;
            // 如果与头节点不同，并且该桶目前已经是红黑树状态，调用putTreeVal()方法 
            else if (p instanceof TreeNode)
                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
            // 如果与头节点不同,桶中仍是链表阶段
            else {
                // 循环遍历链表
                for (int binCount = 0; ; ++binCount) {
                // 讲e指向下一个节点，如果是null，说明该桶中只有头节点，直接添加到链表尾部即可
                    if ((e = p.next) == null) {
                        p.next = newNode(hash, key, value, null);
                        // 如果此时链表个数达到了8，那么需要将该桶处链表转换成红黑树，treeifyBin()方法将hash处的桶转成红黑树
                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash);
                        break;
                    }
                    //如果与已有节点相同，跳出循环
                    if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                        break;
                    p = e;
                }
            }
            // 存在重复key进行覆盖
            if (e != null) { // existing mapping for key
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                // 子类实现 linkHashMap 
                afterNodeAccess(e);
                return oldValue;
            }
        }
        //是一个全新节点，那么size需要+1
        ++modCount;
        // 如果大小朝阳了阈值，需要扩容
        if (++size &gt; threshold)
            resize();
        //子类实现    
        afterNodeInsertion(evict);
        return null;
}</code></pre><p>putVal()方法的流程：</p>
<ul>
<li>1.若hash表为空，调用resize方法创建。</li>
<li>2.若桶的头结点为空，创建新结点放在数组中作为链表的头结点。</li>
<li>3.若头节点不为空，即发生hash冲突，取出头结点与当前值判断，若重复直接覆盖；</li>
<li>4.若不重复且当前处于红黑树状态，调用putTreeVal()方法；若不重复且当前处于链表阶段，遍历链表直到找到重复节点或者链表尾部，把该节点插入尾部；存在重复key就跳出循环。</li>
<li>5.存在重复key，进行value替换。</li>
<li>6.扩容验证。</li>
</ul>
<h2 id="resize-方法"><a href="#resize-方法" class="headerlink" title="resize()方法"></a>resize()方法</h2><p>resize()在哈希表为null时将会初始化，但是在已经初始化后就会进行容量扩展</p>
<pre><code>final Node&lt;K,V&gt;[] resize() {
        Node&lt;K,V&gt;[] oldTab = table;
        int oldCap = (oldTab == null) ? 0 : oldTab.length;// 旧表容量
        int oldThr = threshold;// 旧表的扩容阈值
        int newCap, newThr = 0;
        // 旧表存在
        if (oldCap &gt; 0) {
            // 容量已达上限 
            if (oldCap &gt;= MAXIMUM_CAPACITY) {
                threshold = Integer.MAX_VALUE;
                return oldTab;
            }
            // 否则新容量与新阈值都扩大2倍
            else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;
                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)
                newThr = oldThr &lt;&lt; 1; // double threshold
        }
        / /如果就阈值&gt;0，说明构造方法中指定了容量
        else if (oldThr &gt; 0) // initial capacity was placed in threshold
            newCap = oldThr;
        // 初始化时没有指定阈值和容量，使用默认的容量16和阈值16*0.75=12    
        else {               // zero initial threshold signifies using defaults
            newCap = DEFAULT_INITIAL_CAPACITY;
            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
        }
        //如果新的阈值为 0 ，就得用 新容量*加载因子 重计算一次
        if (newThr == 0) {
            float ft = (float)newCap * loadFactor;
            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?
                      (int)ft : Integer.MAX_VALUE);
        }
        threshold = newThr;
        //常见扩容后的hash表
        @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;})
            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];
        table = newTab;
        // 属于扩容
        if (oldTab != null) {
            //遍历旧表 
            for (int j = 0; j &lt; oldCap; ++j) {
                Node&lt;K,V&gt; e;
                // 当前位置有值
                if ((e = oldTab[j]) != null) {
                    oldTab[j] = null;
                    //如果只有一个节点，直接在新表中赋值
                    if (e.next == null)
                        newTab[e.hash &amp; (newCap - 1)] = e;
                    else if (e instanceof TreeNode)
                        //如果旧哈希表中这个位置的桶是树形结构，就要把新哈希表里当前桶也变成树形结构
                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);
                    else { // preserve order 保留旧哈希表桶中链表的顺序
                        // 通过e.hash &amp; oldCap将链表分为两队，参考知乎上的一段解释 
                        /** 
                        * 把链表上的键值对按hash值分成lo和hi两串，lo串的新索引位置与原先相同[原先位j]，hi串的新索引位置为[原先位置j+oldCap]； 
                        * 链表的键值对加入lo还是hi串取决于 判断条件if ((e.hash &amp; oldCap) == 0)，因为* capacity是2的幂，所以oldCap为10...0的二进制形式，若判断条件为真，意味着 
                        * oldCap为1的那位对应的hash位为0，对新索引的计算没有影响（新索引 
                        * =hash&amp;(newCap-*1)，newCap=oldCap&lt;&lt;2）；若判断条件为假，则 oldCap为1的那位* 对应的hash位为1， 
                        * 即新索引=hash&amp;( newCap-1 )= hash&amp;( (oldCap&lt;&lt;2) - 1)，相当于多了10...0， 
                        * 即 oldCap 
                        * 例子： 
                        * 旧容量=16，二进制10000；新容量=32，二进制100000 
                        * 旧索引的计算： 
                        * hash = xxxx xxxx xxxy xxxx 
                        * 旧容量-1 1111 
                        * &amp;运算 xxxx 
                        * 新索引的计算： 
                        * hash = xxxx xxxx xxxy xxxx 
                        * 新容量-1 1 1111 
                        * &amp;运算 y xxxx 
                        * 新索引 = 旧索引 + y0000，若判断条件为真，则y=0(lo串索引不变)，否则y=1(hi串 
                        * 索引=旧索引+旧容量10000) 
                           */  
                        Node&lt;K,V&gt; loHead = null, loTail = null;
                        Node&lt;K,V&gt; hiHead = null, hiTail = null;
                        Node&lt;K,V&gt; next;
                        do {
                            next = e.next;
                            // 双链表 尾插法 
                            if ((e.hash &amp; oldCap) == 0) {
                                if (loTail == null)
                                    loHead = e;
                                else
                                    loTail.next = e;
                                loTail = e;
                            }
                            else {
                                if (hiTail == null)
                                    hiHead = e;
                                else
                                    hiTail.next = e;
                                hiTail = e;
                            }
                        } while ((e = next) != null);
                        if (loTail != null) {
                            loTail.next = null;
                            newTab[j] = loHead;
                        }
                        if (hiTail != null) {
                            hiTail.next = null;
                            newTab[j + oldCap] = hiHead;
                        }
                    }
                }
            }
        }
        return newTab;
}</code></pre><p>resize()首先获取新容量以及新阈值，然后根据新容量创建新表。如果是扩容操作，则需要进行rehash操作，通过e.hash&amp;oldCap将链表分为两列，更好地均匀分布在新表中。     </p>
<h2 id="get-K-k-操作"><a href="#get-K-k-操作" class="headerlink" title="get(K k)操作"></a>get(K k)操作</h2><p>get(K k)根据键得到值，如果值不存在，那么返回null</p>
<pre><code>public V get(Object key) {
        Node&lt;K,V&gt; e;
        return (e = getNode(hash(key), key)) == null ? null : e.value;
    }

final Node&lt;K,V&gt; getNode(int hash, Object key) {
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;
    // hash表不为空且第一个节点存在
    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;
        (first = tab[(n - 1) &amp; hash]) != null) {
        // 第一个节点即为要查询的节点
        if (first.hash == hash &amp;&amp; // always check first node
            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))
            return first;
        // 链表不止一个头节点    
        if ((e = first.next) != null) {
            // 首节点是红黑树节点，调用getTreeNode方法
            if (first instanceof TreeNode)
                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);
            // 首节点是链表,循环遍历链表
            do {
                // 匹配就返回
                if (e.hash == hash &amp;&amp;
                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                    return e;
            } while ((e = e.next) != null);
        }
    }
    return null;
}  </code></pre><p>getNode()过程：</p>
<ul>
<li>1.如果hash表为空或者长度为0或找不到hash值对应的数组位置，返回null</li>
<li>2.如果头节点匹配，返回头结点。</li>
<li>3.如果头结点不匹配且没有后续节点，返回null</li>
<li>4.如果头结点不匹配且头结点是红黑树类型，调用getTreeNode方法寻找节点</li>
<li>5.如果头结点不匹配且头结点是链表结构，从前往后遍历，找到相应的节点就返回</li>
</ul>
<h2 id="remove-操作"><a href="#remove-操作" class="headerlink" title="remove()操作"></a>remove()操作</h2><p>remove(K k)用于根据键值删除键值对，如果哈希表中存在该键，那么返回键对应的值，否则返回null。  </p>
<pre><code>public V remove(Object key) {
    Node&lt;K,V&gt; e;
    return (e = removeNode(hash(key), key, null, false, true)) == null ?
        null : e.value;
}

final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value,
                           boolean matchValue, boolean movable) {
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index;
    // 当前hash表存在且长度大于0且数组中存在头结点
    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;
        (p = tab[index = (n - 1) &amp; hash]) != null) {
        Node&lt;K,V&gt; node = null, e; K k; V v;
        // 头节点即为key所对应的节点，node即为头节点
        if (p.hash == hash &amp;&amp;
            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
            node = p;
        // 头结点有下一个节点    
        else if ((e = p.next) != null) {
            // 首节点是红黑树节点，调用getTreeNode方法
            if (p instanceof TreeNode)
                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);
            else {
                // 首节点是链表,遍历链表
                do {
                    if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key ||
                         (key != null &amp;&amp; key.equals(k)))) {
                        node = e;
                        break;
                    }
                    p = e;
                } while ((e = e.next) != null);
            }
        }
        //如果存在待删除节点节点
        if (node != null &amp;&amp; (!matchValue || (v = node.value) == value ||
                             (value != null &amp;&amp; value.equals(v)))) {
            //如果节点是TreeNode，使用红黑树的方法                 
            if (node instanceof TreeNode)
                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable);
            //如果待删除节点是头节点，更改桶中的头节点即可    
            else if (node == p)
                tab[index] = node.next;
            //在链表遍历过程中，p代表node节点的前驱节点    
            else
                p.next = node.next;
            ++modCount;
            --size;
            afterNodeRemoval(node);
            return node;
        }
    }
    return null;
}   </code></pre><p>总体来说，removeNode（）先查出待删除的节点，查找过程与查询过程类型，只不过多了在遍历链表时还需要保存前驱节点，因为后面删除时要用到（单链表结构）。存在待删除节点，接下来再执行删除操作.</p>
<ul>
<li>1.如果待删除节点是TreeNode，那么调用removeTreeNode()方法 </li>
<li>2.如果待删除节点是Node，并且待删除节点就是头节点，那么将头节点更改为原有节点的下一个节点就可以了 </li>
<li>3.如果待删除节点是Node且待删除节点不是头节点，那么将遍历过程中保存的前驱节点p的后继节点设为node的后继节点就可以了</li>
</ul>
]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
  </entry>
  <entry>
    <title>Java设计模式：责任链模式</title>
    <url>/2019/01/24/java/java-design/behavioral/chainOfResponsibility/</url>
    <content><![CDATA[<h1 id="定义-目的"><a href="#定义-目的" class="headerlink" title="定义(目的)"></a>定义(目的)</h1><p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链发送该请求，直到有一个对象处理它为止。</p>
<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>定义个抽象类，依赖一个本身对象，每个继承类，即可传入其它的继承类实现对象链。</p>
<h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><p>   定义处理器抽象类 依赖一个本身对象，通过构造器传入，拥有一个处理请求的抽象方法 </p>
<pre><code>protected Handler successor;

    public Handler(Handler successor) {
        this.successor = successor;
    }


    protected abstract void handleRequest(Request request);</code></pre><p>   请求参数类</p>
<pre><code>public class Request {

    private RequestType type;
    private String name;


    public Request(RequestType type, String name) {
        this.type = type;
        this.name = name;
    }


    public RequestType getType() {
        return type;
    }


    public String getName() {
        return name;
    }

}</code></pre><p>   请求类型枚举类 不同的请求类型 调用不同的处理器</p>
<pre><code>public enum RequestType {
    TYPE1, TYPE2, TYPE3
} </code></pre><p>   定义处理器类1继承抽象类处理类型为TYPE1的请求</p>
<pre><code>public class ConcreteHandler1 extends Handler {

   public ConcreteHandler1(Handler successor) {
       super(successor);
   }

   @Override
   protected void handleRequest(Request request) {
       if (RequestType.TYPE1 == request.getType()) {
           System.out.println(request.getName() + &quot; is handle by ConcreteHandler1&quot;);
           return;
       }
       if (successor != null) {
           successor.handleRequest(request);
       }
   }
}</code></pre><p>   定义处理器类2继承抽象类处理类型为TYPE2的请求</p>
<pre><code>public class ConcreteHandler2 extends Handler {
   public ConcreteHandler2(Handler successor) {
       super(successor);
   }

   @Override
   protected void handleRequest(Request request) {
       if (request.getType() == RequestType.TYPE2) {
           System.out.println(request.getName() + &quot; is handle by ConcreteHandler2&quot;);
           return;
       }
       if (successor != null) {
           successor.handleRequest(request);
       }
   }
}</code></pre><p>   测试：</p>
<pre><code>public class Client {

   public static void main(String[] args) {

       Handler handler1 = new ConcreteHandler1(null);
       Handler handler2 = new ConcreteHandler2(handler1);

       Request request1 = new Request(RequestType.TYPE1, &quot;request1&quot;);
       handler2.handleRequest(request1);
       Request request2 = new Request(RequestType.TYPE2, &quot;request2&quot;);
       handler2.handleRequest(request2);

       Handler handler3 = new ConcreteHandler3(handler2);
       Request request3 = new Request(RequestType.TYPE3, &quot;request3&quot;);
       handler3.handleRequest(request1);
   }
}</code></pre><p>   输出：</p>
<pre><code>request1 is handle by ConcreteHandler1
request2 is handle by ConcreteHandler2</code></pre><p>   再定义一个定义处理器类3继承抽象类处理类型为TYPE3的请求</p>
<pre><code>public class ConcreteHandler3 extends Handler {

   public ConcreteHandler3(Handler successor) {
       super(successor);
   }

   @Override
   protected void handleRequest(Request request) {
       if (RequestType.TYPE3 == request.getType()) {
           System.out.println(request.getName() + &quot; is handle by ConcreteHandler3&quot;);
           return;
       }
       if (successor != null) {
           successor.handleRequest(request);
       }
   }
}</code></pre><p>   测试：使用handler3处理request1请求</p>
<pre><code>public class Client {

    public static void main(String[] args) {

        Handler handler1 = new ConcreteHandler1(null);
        Handler handler2 = new ConcreteHandler2(handler1);

        Request request1 = new Request(RequestType.TYPE1, &quot;request1&quot;);
        Handler handler3 = new ConcreteHandler3(handler2);
        Request request3 = new Request(RequestType.TYPE3, &quot;request3&quot;);
        handler3.handleRequest(request1);
    }
}</code></pre><p>   输出：最外层的Handler即调用所有类型的处理请求</p>
<pre><code>request1 is handle by ConcreteHandler1</code></pre>]]></content>
      <categories>
        <category>java-design-patterns</category>
      </categories>
  </entry>
  <entry>
    <title>Java设计模式：观察者模式</title>
    <url>/2019/01/24/java/java-design/behavioral/observer/</url>
    <content><![CDATA[<h1 id="定义-目的"><a href="#定义-目的" class="headerlink" title="定义(目的)"></a>定义(目的)</h1><p>定义对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖都会收到通知并且自动更新状态。</p>
<p>主题（Subject）是被观察的对象，而其所有依赖者（Observer）称为观察者。</p>
<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>主题依赖了观察者的一个集合，观察者依赖了一个主题，生成一个观察者需要在主题进行注册，主题更新后对每个观察者进行推送</p>
<h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><p>   定义主题接口，拥有对观察者的操作方法</p>
<pre><code>public interface Subject {

    // 注册观察者
    public void registerObserver(Observer observer);

    // 移除观察者
    public void removeObserver(Observer observer);

    // 提醒观察者
    public void notifyObserver();
}</code></pre><p>   定义一个观察者接口，提供一个操作接口，方便主题更新时对观察者进行操作</p>
<pre><code>public interface Observer {

    void update(float temp, float humidity, float pressure);
}</code></pre><p>   定义主题接口实现类，依赖了一个观察者集合，当对主题进行更新时，循环通知各个观察者</p>
<pre><code>public class WeatherSubject implements Subject {

    private List&lt;Observer&gt; observers;
    private float temperature;
    private float humidity;
    private float pressure;

    public WeatherSubject() {
        observers = new ArrayList&lt;&gt;();
    }

    public void setMeasurements(float temperature, float humidity, float pressure) {
        this.temperature = temperature;
        this.humidity = humidity;
        this.pressure = pressure;
        notifyObserver();
    }

    @Override
    public void registerObserver(Observer observer) {
        observers.add(observer);
    }

    @Override
    public void removeObserver(Observer observer) {
        int i = observers.indexOf(observer);
        if (i &gt;= 0) {
            observers.remove(i);
        }
    }

    @Override
    public void notifyObserver() {
        for (Observer o : observers) {
            o.update(temperature, humidity, pressure);
        }
    }
}</code></pre><p>   定义观察者实现类，每个观察者通过构造方法传入它所订阅的主题，并在主题中注册该观察者</p>
<pre><code>public class StatisticsDisplay implements Observer {

    public StatisticsDisplay(Subject weatherData) {
        weatherData.registerObserver(this);
    }

    @Override
    public void update(float temp, float humidity, float pressure) {
        System.out.println(&quot;StatisticsDisplay.update: &quot; + temp + &quot; &quot; + humidity + &quot; &quot; + pressure);
    }
}</code></pre><p>   定义另一个观察者实现类</p>
<pre><code>public class CurrentConditionsDisplay implements Observer {

    public CurrentConditionsDisplay(Subject weatherData) {
        weatherData.registerObserver(this);
    }

    @Override
    public void update(float temp, float humidity, float pressure) {
        System.out.println(&quot;CurrentConditionsDisplay.update: &quot; + temp + &quot; &quot; + humidity + &quot; &quot; + pressure);
    }

}</code></pre><p>   测试：</p>
<pre><code>public class Client {

    public static void main(String[] args) {
        WeatherSubject subject = new WeatherSubject();
        Observer statis = new StatisticsDisplay(subject);
        Observer current = new CurrentConditionsDisplay(subject);
        subject.setMeasurements(22f, 29f, 100f);
    }
}</code></pre><p>   输出：</p>
<pre><code>StatisticsDisplay.update: 22.0 29.0 100.0
CurrentConditionsDisplay.update: 22.0 29.0 100.0</code></pre><h2 id="JDK实现"><a href="#JDK实现" class="headerlink" title="JDK实现"></a>JDK实现</h2><p>第一眼看到这个模式就感觉这不就是java的监听器嘛，其实监听器就是通过这种模式实现的。</p>
<ul>
<li>java.util.Observer</li>
<li>java.util.EventListener</li>
<li>javax.servlet.http.HttpSessionBindingListener</li>
</ul>
]]></content>
      <categories>
        <category>java-design-patterns</category>
      </categories>
  </entry>
  <entry>
    <title>Java设计模式：策略模式</title>
    <url>/2019/01/24/java/java-design/behavioral/strategy/</url>
    <content><![CDATA[<h1 id="定义-目的"><a href="#定义-目的" class="headerlink" title="定义(目的)"></a>定义(目的)</h1><p>定义一系列算法，封装每个算法，并使它们可以互换。策略模式可以让算法独立于使用它的客户端。</p>
<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>把对象的功能实现定义成一个接口，对象中依赖一个功能接口，通过改变接口的实现，来达到不同的功能。</p>
<h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><p>   定义功能接口</p>
<pre><code>public interface CallBehavior {

   // 叫，不同动物叫声不同
   void call();
}</code></pre><p>   功能接口实现</p>
<pre><code>public class Quack implements CallBehavior {

    @Override
    public void call() {
        System.out.println(&quot;鸭子叫!&quot;);
    }
}

public class Squeak implements CallBehavior {

   @Override
   public void call() {
       System.out.println(&quot;鸡叫k!&quot;);
   }
}</code></pre><p>   定义对象类，并依赖功能接口，通过改变接口的具体实现达到不同的功能</p>
<pre><code>public class Duck {

    private CallBehavior behavior;

    public void performQuack() {
        if (behavior != null) {
            behavior.call();
        }
    }
    public void setQuackBehavior(CallBehavior behavior) {
        this.behavior = behavior;
    }
}</code></pre><p>   测试：</p>
<pre><code>public class Client {

    public static void main(String[] args) {
        Duck duck = new Duck();
        CallBehavior quack = new Quack();
        duck.setQuackBehavior(quack);
        duck.performQuack();
        CallBehavior squeak = new Squeak();
        duck.setQuackBehavior(squeak);
        duck.performQuack();
    }
}</code></pre><p>   输出：</p>
<pre><code>鸭子叫!
鸡叫k!</code></pre><h2 id="JDK实现"><a href="#JDK实现" class="headerlink" title="JDK实现"></a>JDK实现</h2><ul>
<li>java.util.Comparator#compare()</li>
<li>javax.servlet.http.HttpServlet</li>
<li>javax.servlet.Filter#doFilter()</li>
</ul>
]]></content>
      <categories>
        <category>java-design-patterns</category>
      </categories>
  </entry>
  <entry>
    <title>Java设计模式：适配器</title>
    <url>/2019/01/08/java/java-design/structure/adapter/</url>
    <content><![CDATA[<h1 id="定义-目的"><a href="#定义-目的" class="headerlink" title="定义(目的)"></a>定义(目的)</h1><p>适配器就是一种适配中间件，它存在于不匹配的二者之间，用于连接二者，将不匹配变得匹配，简单点理解就是平常所见的转接头，转换器之类的存在。</p>
<p>把一个类接口转换成另一个用户需要的接口。</p>
<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><ul>
<li>通过组合的方式。</li>
<li>通过继承来实现适配器功能。</li>
</ul>
<h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><p>   定义一个鸭接口 方法为鸭子叫</p>
<pre><code>public interface Duck {

    void quack();</code></pre><p>   定义一个火鸡接口 方法为鸡叫</p>
<pre><code>public interface Turkey {

   void gobble();    </code></pre><p>   鸭子实现类</p>
<pre><code>public class WildDuck implements Duck {

    @Override
    public void quack() {
        System.out.println(&quot;鸭子叫&quot;);
    }
}    </code></pre><p>   火鸡实现类</p>
<pre><code>public class WildTurkey implements Turkey {

    @Override
    public void gobble() {
        System.out.println(&quot;火鸡叫&quot;);
    }
} </code></pre><p>   现在鸭子只能发出鸭子叫，鸡只能发出鸡叫，我们想要鸭子发出鸡的叫声。添加鸭子适配器。</p>
<pre><code>public class DuckAdapter implements Turkey {

   Duck duck;

   public DuckAdapter(Duck duck) {
       this.duck = duck;
   }

   @Override
   public void gobble() {
       duck.quack();
   }
}</code></pre><p>   组合方式，适配器构造器需要一个鸭子对象，适配器实现了火鸡的接口，通过调用鸭子对象的方法，实现了鸭子发生了鸡叫。</p>
<pre><code>public class DuckAdapter extends Turkey WildTurkey implements Turkey {

      @Override
      public void gobble() {
          gobble.quack();
      }
   }</code></pre><p>   继承方式，适配器构造器需要一个鸭子对象，适配器实现了火鸡的接口，通过调用鸭子对象的方法，实现了鸭子发生了鸡叫。</p>
]]></content>
      <categories>
        <category>java-design-patterns</category>
      </categories>
  </entry>
  <entry>
    <title>Java设计模式：桥接器</title>
    <url>/2019/01/08/java/java-design/structure/bridge/</url>
    <content><![CDATA[<h1 id="定义-目的"><a href="#定义-目的" class="headerlink" title="定义(目的)"></a>定义(目的)</h1><p>将抽象与实现分离开来，使它们可以独立变化。</p>
<p>抽象与实现解耦，例如一个生产线的机器，将参数设定与具体生产的过程实现分离开，使整个生产线更加灵活，用一套参数也可以使用不同的工作模式。</p>
<p>其中参数设定与生产过程属于两种不同的维度，桥接模式所做的事情就是将不同的维度联结在一起！</p>
<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><ul>
<li>在一个类中通过组合另一个对象，调用时只需在当前类调用对象方法即可，实现解耦。</li>
</ul>
<h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><p>   定义电视机抽象类,拥有3个方法。</p>
<pre><code>public abstract class Tv {

    public abstract void on();

    public abstract void off();

    public abstract void tuneTunnel();</code></pre><p>   定义一个电视机的实现类，Sony电视机。</p>
<pre><code>public class SonyTv extends Tv {

    @Override
    public void on() {
        System.out.println(&quot;SonyTv,on&quot;);
    }

    @Override
    public void off() {
        System.out.println(&quot;SonyTv,off&quot;);
    }

    @Override
    public void tuneTunnel() {
        System.out.println(&quot;SonyTv,tuneTunnel&quot;);
    }</code></pre><p>   定义一个遥控器抽象类。组合了一个电视机对象。</p>
<pre><code>protected Tv tv;

    public RemoteControl(Tv tv) {
        this.tv = tv;
    }

    public abstract void on();

    public abstract void off();

    public abstract void tuneTunnel();   </code></pre><p>   定义一个遥控器的实现类，Sony电视机遥控器。</p>
<pre><code>public class SonyRemoteControl extends RemoteControl {

    public SonyRemoteControl(Tv tv) {
        super(tv);
    }

    @Override
    public void on() {
        System.out.println(&quot;sonyRemoteControl,on&quot;);
        tv.on();
    }

    @Override
    public void off() {
        System.out.println(&quot;sonyRemoteControl,off&quot;);
        tv.off();
    }

    @Override
    public void tuneTunnel() {
        System.out.println(&quot;sonyRemoteControl,tuneTunnel&quot;);
        tv.off();
    }
} </code></pre><p>   在生成sony电视机遥控器时，传入一个sony电视机对象，即可使用该遥控器实现该电视机的状态变换。</p>
<pre><code>public class Client {

   public static void main(String[] args) {
       Tv sonyTv = new SonyTv();
       SonyRemoteControl sonyRemoteControl = new SonyRemoteControl(sonyTv);
       sonyRemoteControl.on();
       sonyRemoteControl.off();
       sonyRemoteControl.tuneTunnel();
   }
}</code></pre>]]></content>
      <categories>
        <category>java-design-patterns</category>
      </categories>
  </entry>
  <entry>
    <title>Java设计模式：组合模式</title>
    <url>/2019/01/08/java/java-design/structure/composite/</url>
    <content><![CDATA[<h1 id="定义-目的"><a href="#定义-目的" class="headerlink" title="定义(目的)"></a>定义(目的)</h1><p>将对象组合成树形结构来表示“整体/部分”层次关系，允许用户以相同的方式处理单独对象和组合对象。</p>
<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>组件（Component）类是组合类（Composite）和叶子类（Leaf）的父类，可以把组合类看成是树的中间节点。<br>组合对象拥有一个或多个组件对象，因此组合对象的操作可以委托给组件对象去处理，而组件对象可以是另一个组合对象或者叶子对象。</p>
<h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><p>   定义组件抽象类</p>
<pre><code>public abstract class Component {

    protected String name;

    public Component(String name) {
        this.name = name;
    }

    public void print() {
        print(0);
    }
    public abstract void print(int level);

    public abstract void add(Component component);

    public abstract void remove(Component component);
}</code></pre><p>   定义一个组合类，继承组件类，并依赖了组件类，依赖的组件类可以是另一个组合对象或者叶子对象</p>
<pre><code>public class Composite extends Component {

    private List&lt;Component&gt; child;

    public Composite(String name) {
        super(name);
        child = new ArrayList&lt;&gt;();
    }

    @Override
    public void print(int level) {
        for (int i = 0; i &lt; level; i++) {
            System.out.print(&quot;--&quot;);
        }
        System.out.println(&quot;Composite:&quot; + name);
        for (Component component : child) {
            component.print(level + 1);
        }
    }

    @Override
    public void add(Component component) {
        child.add(component);
    }

    @Override
    public void remove(Component component) {
        child.remove(component);
    }
}</code></pre><p>   定义一个叶子类，继承组件类。</p>
<pre><code>public class Leaf extends Component{

    public Leaf(String name) {
        super(name);
    }

    @Override
    public void print(int level) {
        for (int i = 0; i &lt; level; i++) {
            System.out.print(&quot;--&quot;);
        }
        System.out.println(&quot;left:&quot; + name);
    }

    @Override
    public void add(Component component) {
        throw new UnsupportedOperationException(); // 牺牲透明性换取单一职责原则，这样就不用考虑是叶子节点还是组合节点
    }

    @Override
    public void remove(Component component) {
        throw new UnsupportedOperationException();
    }  </code></pre><p>   测试</p>
<pre><code>public class Client {

    public static void main(String[] args) {
        Composite root = new Composite(&quot;root&quot;);
        Component node1 = new Leaf(&quot;1&quot;);
        Component node2 = new Composite(&quot;2&quot;);
        Component node3 = new Leaf(&quot;3&quot;);
        root.add(node1);
        root.add(node2);
        root.add(node3);
        Component node21 = new Leaf(&quot;21&quot;);
        Component node22 = new Composite(&quot;22&quot;);
        node2.add(node21);
        node2.add(node22);
        Component node221 = new Leaf(&quot;221&quot;);
        node22.add(node221);
        root.print();
    }
}</code></pre><p>   结果</p>
<pre><code>Composite:root
--left:1
--Composite:2
----left:21
----Composite:22
------left:221
--left:3</code></pre>]]></content>
      <categories>
        <category>java-design-patterns</category>
      </categories>
  </entry>
  <entry>
    <title>Java设计模式：装饰者</title>
    <url>/2019/01/08/java/java-design/structure/decorator/</url>
    <content><![CDATA[<h1 id="定义-目的"><a href="#定义-目的" class="headerlink" title="定义(目的)"></a>定义(目的)</h1><p>为对象动态添加功能。组合模式是部分和整理的关系，而装饰器模式只是额外增加某些功能。</p>
<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>装饰者（Decorator）和具体组件（ConcreteComponent）都继承自组件（Component）,<strong>装饰者组合了一个组件</strong>，这样它可以装饰其它装饰者或者具体组件。</p>
<p>就是把这个装饰者套在被装饰者之上，从而动态扩展被装饰者的功能。</p>
<p>装饰者的方法有一部分是自己的，这属于它的功能，然后调用被装饰者的方法实现，从而也保留了被装饰者的功能。可以看到，具体组件应当是装饰层次的最低层，因为只有具体组件的方法实现不需要依赖于其它对象。</p>
<h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><p>设计不同种类的饮料，饮料可以添加配料，比如可以添加牛奶，并且支持动态添加新配料。每增加一种配料，该饮料的价格就会增加，要求计算一种饮料的价格。</p>
<p>下面实现在 DarkRoast 饮料上新增新添加 Mocha 配料，之后又添加了 Milk 配料。DarkRoast 被 Mocha 包裹，Mocha 又被 Milk 包裹。它们都继承自相同父类，都有 cost() 方法，外层类的 cost() 方法调用了内层类的 cost() 方法。</p>
<p>   定义一个组件（Component）接口,这里为饮料。装饰者和具体组件都要实现它。</p>
<pre><code>public interface Beverage {

    public double cost();
}</code></pre><p>   具体组件实现DarkRoast饮料</p>
<pre><code>public class DarkRoast implements Beverage {

   @Override
   public double cost() {
       return 1;
   }
}</code></pre><p>   定义一个装饰者抽象类，实现了饮料接口，拥有饮料的方法，并关联了饮料接口对象。</p>
<pre><code>public abstract class CondimentDecorator implements Beverage {

    protected Beverage beverage;

    public CondimentDecorator(Beverage beverage) {
        this.beverage = beverage;
    }
}</code></pre><p>   装饰者实现类Milk，继承了装饰者类</p>
<pre><code>public class Milk extends CondimentDecorator {

    public Milk(Beverage beverage) {
        super(beverage);
    }

    @Override
    public double cost() {
        return 1 + beverage.cost();
    }
}</code></pre><p>   装饰者实现类Mocha，继承了装饰者类</p>
<pre><code>public class Mocha extends CondimentDecorator {

    public Mocha(Beverage beverage) {
        super(beverage);
    }

    @Override
    public double cost() {
        return 1 + beverage.cost();
    }
}</code></pre><p>   测试：当执行cost()方法时会一层一层从内往外调用。</p>
<pre><code>public class Client {

   public static void main(String[] args) {
       Beverage beverage = new DarkRoast();// 一杯饮料
       beverage = new Mocha(beverage);// 饮料里加mocha
       beverage = new Milk(beverage);// 饮料里加牛奶
       System.out.println(beverage.cost());//总价
   }</code></pre><p>   }</p>
]]></content>
      <categories>
        <category>java-design-patterns</category>
      </categories>
  </entry>
  <entry>
    <title>Java设计模式：外观模式</title>
    <url>/2019/01/24/java/java-design/structure/facade/</url>
    <content><![CDATA[<h1 id="定义-目的"><a href="#定义-目的" class="headerlink" title="定义(目的)"></a>定义(目的)</h1><p>提供了一个统一的接口，用来访问子系统中的一群接口，从而让子系统更容易使用。</p>
<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>定义一个外观对象，在内部进行功能的封装，功能具体是在都在外观类的内部，其它方法要使用该功能<br>调用外观对象的方法即可。</p>
<h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><p>   定义一个电影播放系统，方法代表需要功能所需步骤</p>
<pre><code>public class SubSystem {

    public void turnOnTV() {
        System.out.println(&quot;turnOnTV()&quot;);
    }

    public void setCD(String cd) {
        System.out.println(&quot;setCD( &quot; + cd + &quot; )&quot;);
    }

    public void starWatching() {
        System.out.println(&quot;starWatching()&quot;);
    }

}</code></pre><p>   定义一个外观类，封装了看电影的三步骤，客户端只需调用外观类的方法即可实现功能</p>
<pre><code>public class Facade {

    private SubSystem subSystem = new SubSystem();

    public void watchMovie(String name) {
        subSystem.turnOnTV();
        subSystem.setCD(name);
        subSystem.starWatching();
    }
}</code></pre><p>   测试：</p>
<pre><code>public class Client {

    public static void main(String[] args) {
        Facade facade = new Facade();
        facade.watchMovie(&quot;家有喜事&quot;);
    }
}</code></pre><p>   测试：</p>
<pre><code>turnOnTV()
setCD( 家有喜事 )
starWatching()</code></pre>]]></content>
      <categories>
        <category>java-design-patterns</category>
      </categories>
  </entry>
  <entry>
    <title>Java设计模式：享元模式</title>
    <url>/2019/01/24/java/java-design/structure/flyweight/</url>
    <content><![CDATA[<h1 id="定义-目的"><a href="#定义-目的" class="headerlink" title="定义(目的)"></a>定义(目的)</h1><p>利用共享的方式来支持大量细粒度的对象，这些对象一部分内部状态是相同的。</p>
<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>在享元接口中 定义一个方法，即为对象的外部状态，每个对象的外部状态都不同<br>在接口的实现类中添加一个成员变量作为识别标志，在创建工厂类中添加一个Map以识别标志为key，即以对象内部相同状态为key，<br>调用方法即可改变其它状态</p>
<h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><p>   定义组享元接口 拥有改变外部对象的方法</p>
<pre><code>public interface Flyweight {

    /**
     * 外部状态，每个享元对象的外部状态不同
     *
     * @param extrinsicState
     */
    public void extrinsicState(String extrinsicState);
}</code></pre><p>   定义一个享元接口实现类，内部状态为成员变量，提供外部状态实现</p>
<pre><code>public class ConcreteFlyweight implements Flyweight {

    private String intrinsicState;

    public ConcreteFlyweight(String intrinsicState) {
        this.intrinsicState = intrinsicState;
    }

    @Override
    public void extrinsicState(String extrinsicState) {
        System.out.println(&quot;Object address: &quot; + System.identityHashCode(this));
        System.out.println(&quot;IntrinsicState: &quot; + intrinsicState);
        System.out.println(&quot;ExtrinsicState: &quot; + extrinsicState);
    }
}</code></pre><p>   定义享元对象工厂类，定义一个全局变量map存储享元对象。</p>
<pre><code>public class FlyweightFactory {

    private HashMap&lt;String, Flyweight&gt; flyweights = new HashMap&lt;&gt;();

    public Flyweight getFlyweight(String intrinsicState) {
        if (!flyweights.containsKey(intrinsicState)) {
            Flyweight flyweight = new ConcreteFlyweight(intrinsicState);
            flyweights.put(intrinsicState, flyweight);
        }
        return flyweights.get(intrinsicState);
    }
}  </code></pre><p>   测试</p>
<pre><code>public class Client {

    public static void main(String[] args) {
        FlyweightFactory factory = new FlyweightFactory();
        Flyweight flyweight1 = factory.getFlyweight(&quot;aa&quot;);
        Flyweight flyweight2 = factory.getFlyweight(&quot;aa&quot;);
        flyweight1.extrinsicState(&quot;x&quot;);
        flyweight2.extrinsicState(&quot;y&quot;);
    }
}</code></pre><p>   结果</p>
<pre><code>Object address: 985934102
IntrinsicState: aa
ExtrinsicState: x
Object address: 985934102
IntrinsicState: aa
ExtrinsicState: y</code></pre><h3 id="JDK使用："><a href="#JDK使用：" class="headerlink" title="JDK使用："></a>JDK使用：</h3><p>Java 利用缓存来加速大量小对象的访问时间。</p>
<ul>
<li>java.lang.Integer#valueOf(int)</li>
<li>java.lang.Boolean#valueOf(boolean)</li>
<li>java.lang.Byte#valueOf(byte)</li>
<li>java.lang.Character#valueOf(char)</li>
</ul>
]]></content>
      <categories>
        <category>java-design-patterns</category>
      </categories>
  </entry>
  <entry>
    <title>jvm学习（一）</title>
    <url>/2018/10/31/java/jvm/jvm(1)/</url>
    <content><![CDATA[<h1 id="一：内存区域"><a href="#一：内存区域" class="headerlink" title="一：内存区域"></a>一：内存区域</h1><p><img src="/uploads/java/jvm/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F.jpg" alt="内存区域"></p>
<h2 id="线程私有-针对于方法-："><a href="#线程私有-针对于方法-：" class="headerlink" title="线程私有(针对于方法)："></a>线程私有(针对于方法)：</h2><p>   程序计数器（Program Count Register）：如果线程正在执行java方法，计数器记录正在执行的虚拟机字节码地址；Native方法，值为空。</p>
<p>   虚拟机栈（Vm Stack）: 描述Java方法执行的内存模型：每个方法在执行的同时会创建一个栈帧用于存储<strong>局部变量表</strong>、操作数栈、动态链接、方法出口等。</p>
<ul>
<li><p>人们常说的Java内存分为堆内存（Heap）和栈内存（Stack），这个栈就是虚拟机栈，或者说是机栈中局部变量表部分。</p>
</li>
<li><p>局部变量表（虚拟机栈）存放编译器可知的<strong>基本数据类型</strong>和<strong>对象引用</strong>。</p>
</li>
<li><p>当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。</p>
<p>本地方法栈（Native Method Stack）：作用与虚拟机栈相似，本地方法栈执行Native方法。</p>
</li>
</ul>
<h2 id="线程共享（针对于Class）："><a href="#线程共享（针对于Class）：" class="headerlink" title="线程共享（针对于Class）："></a>线程共享（针对于Class）：</h2><p>   堆（Heap）：存放<strong>所有对象实例</strong>以及<strong>数组</strong>，是垃圾回收的主要区域。</p>
<ul>
<li><p>现在垃圾收集器基本采用<strong>分代收集算法</strong>，主要思想为针对不用类型的对象采取不同的垃圾回收算法，可将堆分为<strong>新生代</strong>和<strong>老年代</strong>，还可细分。</p>
</li>
<li><p>从内存分配的角度，堆可能分出多个线程私有的分配缓冲区(TLAB)，只是为了更好回收内存，更快分配内存，存储对象不变。</p>
</li>
<li><p>堆无需连续内存，可以动态增加，增加失败会抛出OutOfMemoryError 异常。可以通过 -Xms 和 -Xmx 两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。java -Xms1M -Xmx2M。</p>
<p>方法区（Method Area）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
</li>
<li><p>和堆一样不需要连续的内存，还可以选择不实现垃圾回收，对这一区域内存回收目标主要是针对常量池和类型的卸载，一般难以实现，效果较差。</p>
</li>
<li><p>HotSpot 虚拟机把它当成永久代来进行垃圾回收。但是很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。为了更容易管理方法区，从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。</p>
<p>运行时常量池（Runtime Constant Pool）：是方法区的一部分。Class 文件中的常量池（编译器生成的各种字面量和符号引用）会在类加载后被放入这个区域。</p>
</li>
<li><p>具备动态性，除了再编译器生成的常量放入这一区域外，还允许动态生成。常量不仅仅再编译期间才能产生，在运行时也可能产生新的常量，例如String类的intern()。</p>
</li>
<li><p>受到方法区内存大小限制，无法申请到内存时会抛出OutOfMemoryError异常。</p>
<p>直接内存：不是虚拟机运行时数据区的一部分。jdk1.4中引入NIO，可以直接使用native函数库分配堆外的内存，然后通过一个存储在Java堆里的DirectByteBuffer对象作为这块内存的引用进行操作，避免了Java堆和Native对中来回复制数据显著提高性能。</p>
</li>
</ul>
<h1 id="二：HotSpot虚拟机对象"><a href="#二：HotSpot虚拟机对象" class="headerlink" title="二：HotSpot虚拟机对象"></a>二：HotSpot虚拟机对象</h1><h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p>   空间划分（内存分配）：堆采用的垃圾收集器是否带有压缩整理功能–&gt;堆是否规整–&gt;内存的分配方式，规整采用<strong>指针碰撞</strong>方法，否则采用<strong>空闲列表</strong>方式</p>
<p>   对象在创建中是否频繁（并发问题）：</p>
<ul>
<li><p>同步处理，CAS加失败重试保证原子性</p>
</li>
<li><p>本地线程分配缓冲区（TLAB）：每个线程在Java堆中预先分配一小块内存。线程私有内存。</p>
</li>
<li><p>内存分配完成后，进行对象实例字段的初始化（不包括对象头，内存空间都为零值）；若使用TLAB，则可提前在TLAB中分配。</p>
<p>对象头设置：存放类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。虚拟机当前运行状态（如是否启用偏向锁）不同，对象头有不同的设置方式。</p>
<p>上述工作完成后，虚拟机角度新的对象已经产生，程序角度对象创建刚刚开始–<init>方法还未执行。</init></p>
</li>
</ul>
<h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p>   <img src="/uploads/java/jvm/%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.jpg" alt="对象在内存布局"></p>
<h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p>   Java程序通过栈上的reference（指向对象的引用）数据操作堆上的具体数据。访问方式由虚拟机实现。主流方式有2种。</p>
<ul>
<li>句柄：堆中划分句柄池，reference存储对象的句柄地址，句柄包含<strong>对象实例数据</strong>与<strong>类型数据（类数据）</strong>各自的具体地址。<br>优点：在对象被移动时（垃圾收集时移动对象是非常普遍的行为）只会改变句柄中的实例数据指针，reference本事不需要修改。</li>
<li>直接指针：reference存储的直接是对象的地址，对象的实例数据中要放置访问类型数据的指针。<br>优点：速度快，节省了一次指针定位的时间开销。</li>
</ul>
<h1 id="三：垃圾收集"><a href="#三：垃圾收集" class="headerlink" title="三：垃圾收集"></a>三：垃圾收集</h1><p>   垃圾收集需要考虑三个问题：<strong>回收哪些内存</strong>，<strong>什么时候回收</strong>，<strong>怎么回收</strong></p>
<p>   垃圾收集器主要针对堆和方法区进行。</p>
<p>   程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后也会消失，因此不需要对这三个区域进行垃圾回收。</p>
<h2 id="判断一个对象是否可被回收（回收哪些内存）"><a href="#判断一个对象是否可被回收（回收哪些内存）" class="headerlink" title="判断一个对象是否可被回收（回收哪些内存）"></a>判断一个对象是否可被回收（回收哪些内存）</h2><h3 id="1-引用计数算法"><a href="#1-引用计数算法" class="headerlink" title="1.引用计数算法"></a>1.引用计数算法</h3><p>   给对象添加一个引用计数器，当对象增加引用时就加一，失效一个引用时就减一。引用计数器为0的对象表示可以回收。 </p>
<ul>
<li><p>由于存在循环引用，引用计数器永远不为0，导致永远不会被回收。</p>
<h3 id="2-可达性分析算法"><a href="#2-可达性分析算法" class="headerlink" title="2.可达性分析算法"></a>2.可达性分析算法</h3><p>通过 Roots作为起点，能够到达的对象被视为存活，不可达的对象可以回收。<br><img src="/uploads/java/jvm/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95.png" alt="可达性分析算法"></p>
<p>可作为GC Roots的对象：（全局性引用如常量和类静态变量，应用上下文如帧栈中的本地变量表）</p>
</li>
<li><p>虚拟机栈（帧栈中的本地变量两）中引用的对象</p>
</li>
<li><p>方法区中的类静态属性引用的对象</p>
</li>
<li><p>方法区中常量引用的对象</p>
</li>
<li><p>本地方法栈中的JNI（即一般说的Native方法）引用的对象。</p>
<h3 id="3-对象生存还是死亡（finalize-方法）"><a href="#3-对象生存还是死亡（finalize-方法）" class="headerlink" title="3.对象生存还是死亡（finalize()方法）"></a>3.对象生存还是死亡（finalize()方法）</h3><p>在可达性分析算法过程中不可达的对象并非一定会被回收。在可达性分析算法被认为无引用链后，需要2步才能真正宣告对象已死。</p>
</li>
<li><p>进行一次筛选，筛选条件为对象是否有必要执行finalize()方法，若对象未执行过finalize方法，将其放入F-Queue队列，由一低优先级线程执行该队列中对象的finalize方法。<br>执行finalize方法完毕后，GC会再次判断该对象是否可达，若不可达，则进行回收，否则，对象“复活”。</p>
</li>
<li><p>若未覆盖finalize方法，则直接将其回收。</p>
<p>自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会调用 finalize() 方法。</p>
<h3 id="4-方法区回收"><a href="#4-方法区回收" class="headerlink" title="4.方法区回收"></a>4.方法区回收</h3><p>因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，因此在方法区上进行回收性价比不高。主要是对常量池的回收和对类的卸载。</p>
<p>在大量使用反射、动态代理、CGLib 等 ByteCode 框架、动态生成 JSP 以及 OSGi 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载功能，以保证不会出现内存溢出。</p>
<p>类的卸载条件很多，需要满足以下三个条件，并且满足了也不一定会被卸载：</p>
</li>
<li><p>该类所有的实例都已经被回收，也就是堆中不存在该类的任何实例。</p>
</li>
<li><p>加载该类的 ClassLoader 已经被回收。</p>
</li>
<li><p>该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。</p>
<p>可以通过 -Xnoclassgc 参数来控制是否对类进行卸载。</p>
</li>
</ul>
<h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>   无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。</p>
<p>   Java 提供了四种强度不同的引用类型。</p>
<h3 id="1-强引用"><a href="#1-强引用" class="headerlink" title="1.强引用"></a>1.强引用</h3><p>   被强引用关联的对象不会被回收。使用 new 一个新对象的方式来创建强引用。 </p>
<pre><code>Object obj = new Object();</code></pre><h3 id="2-软引用"><a href="#2-软引用" class="headerlink" title="2.软引用"></a>2.软引用</h3><p>   被软引用关联的对象只有在内存不够的情况下才会被回收。使用 SoftReference 类来创建软引用。 </p>
<pre><code>Object obj = new Object();
SoftReference&lt;Object&gt; sf = new SoftReference&lt;Object&gt;(obj);
obj = null;  // 使对象只被软引用关联</code></pre><h3 id="3-弱引用"><a href="#3-弱引用" class="headerlink" title="3.弱引用"></a>3.弱引用</h3><p>   被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。使用 WeakReference 类来实现弱引用。</p>
<pre><code>Object obj = new Object();
SoftReference&lt;Object&gt; sf = new SoftReference&lt;Object&gt;(obj);
obj = null;  // 使对象只被软引用关联</code></pre><h3 id="4-虚引用"><a href="#4-虚引用" class="headerlink" title="4.虚引用"></a>4.虚引用</h3><p>   又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。</p>
<p>   为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。</p>
<p>   使用 PhantomReference 来创建虚引用。</p>
<pre><code>Object obj = new Object();
PhantomReference&lt;Object&gt; pf = new PhantomReference&lt;Object&gt;(obj, null);
obj = null;</code></pre><h2 id="垃圾收集算法（怎么回收）"><a href="#垃圾收集算法（怎么回收）" class="headerlink" title="垃圾收集算法（怎么回收）"></a>垃圾收集算法（怎么回收）</h2><h3 id="1-标记-清除"><a href="#1-标记-清除" class="headerlink" title="1.标记 - 清除"></a>1.标记 - 清除</h3><p>   <img src="/uploads/java/jvm/%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4.jpg" alt="标记-清除"><br>   标记要回收的对象，然后清除。</p>
<p>   不足：</p>
<p>   标记和清除过程效率都不高；<br>   会产生大量不连续的内存碎片，导致无法给大对象分配内存。</p>
<h3 id="2-标记-整理"><a href="#2-标记-整理" class="headerlink" title="2.标记 - 整理"></a>2.标记 - 整理</h3><p>   <img src="/uploads/java/jvm/%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86.jpg" alt="标记-整理"><br>   让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>
<h3 id="3-复制"><a href="#3-复制" class="headerlink" title="3.复制"></a>3.复制</h3><p>   <img src="/uploads/java/jvm/%E5%A4%8D%E5%88%B6.jpg" alt="复制"><br>   将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。</p>
<p>   主要不足是只使用了内存的一半。</p>
<p>   现在的商业虚拟机都采用这种收集算法来回收新生代，但是并不是将新生代划分为大小相等的两块，而是分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象一次性复制到另一块 Survivor 空间上，最后清理 Eden 和使用过的那一块 Survivor。</p>
<p>   HotSpot 虚拟机的 Eden 和 Survivor 的大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间存储放不下的对象。</p>
<h3 id="4-分代收集"><a href="#4-分代收集" class="headerlink" title="4.分代收集"></a>4.分代收集</h3><p>   现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。</p>
<p>   一般将堆分为新生代和老年代。</p>
<ul>
<li>新生代使用：复制算法</li>
<li>老年代使用：标记 - 清除 或者 标记 - 整理 算法</li>
</ul>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><h3 id="HotSpot垃圾收集器"><a href="#HotSpot垃圾收集器" class="headerlink" title="HotSpot垃圾收集器"></a>HotSpot垃圾收集器</h3><p>   <img src="/uploads/java/jvm/HotSpot%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="HotSpot垃圾收集器"></p>
<p>   连线表示可以配合使用。</p>
<ul>
<li><p>单线程与多线程：单线程指的是垃圾收集器只使用一个线程进行收集，而多线程使用多个线程；</p>
</li>
<li><p>串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。 </p>
<h3 id="1-Serial-收集器"><a href="#1-Serial-收集器" class="headerlink" title="1.Serial 收集器"></a>1.Serial 收集器</h3><p>串行，单线程。优点：高效，单cpu环境没有线程交互的切换，拥有最高的单线程收集效率。</p>
</li>
</ul>
<p>   <strong>client模式的下的默认新生代</strong>垃圾收集器。因为在该应用场景下，分配给虚拟机管理的内存一般来说不会很大。</p>
<p>   Serial 收集器收集几十兆甚至一两百兆的新生代停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿是可以接受的。</p>
<h3 id="2-ParNew-收集器"><a href="#2-ParNew-收集器" class="headerlink" title="2.ParNew 收集器"></a>2.ParNew 收集器</h3><p>   Serial 收集器的多线程版本。</p>
<p>   是 <strong>Server 模式下的虚拟机首选新生代</strong>收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合工作。</p>
<p>   默认开启的线程数量与 CPU 数量相同，可以使用 -XX:ParallelGCThreads 参数来设置线程数。</p>
<h3 id="3-Parallel-Scavenge-收集器"><a href="#3-Parallel-Scavenge-收集器" class="headerlink" title="3.Parallel Scavenge 收集器"></a>3.Parallel Scavenge 收集器</h3><p>   多线程收集器。</p>
<p>   其它收集器关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户代码的时间占总时间的比值。</p>
<p>   停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务。</p>
<p>   缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。</p>
<p>   可以通过一个开关参数打开 GC 自适应的调节策略（GC Ergonomics），就不需要手工指定新生代的大小（-Xmn）、Eden 和 Survivor 区的比例、晋升老年代对象年龄等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。</p>
<h3 id="4-Serial-Old-收集器"><a href="#4-Serial-Old-收集器" class="headerlink" title="4.Serial Old 收集器"></a>4.Serial Old 收集器</h3><p>   是 Serial 收集器的老年代版本，也是给 Client 模式下的虚拟机使用。如果用在 Server 模式下，它有两大用途：</p>
<ul>
<li><p>在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。</p>
</li>
<li><p>作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。</p>
<h3 id="5-Parallel-Old-收集器"><a href="#5-Parallel-Old-收集器" class="headerlink" title="5.Parallel Old 收集器"></a>5.Parallel Old 收集器</h3><p>是 Parallel Scavenge 收集器的老年代版本。</p>
<p>在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。</p>
<h3 id="6-CMS-收集器"><a href="#6-CMS-收集器" class="headerlink" title="6. CMS 收集器"></a>6. CMS 收集器</h3><p><img src="/uploads/java/jvm/CMS%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="CMS收集器"><br>CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法。</p>
<p>分为以下四个流程：</p>
</li>
<li><p>初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。</p>
</li>
<li><p>并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。</p>
</li>
<li><p>重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。</p>
</li>
<li><p>并发清除：不需要停顿。</p>
<p>在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。</p>
<p>具有以下缺点：</p>
</li>
<li><p>吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。</p>
</li>
<li><p>无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。</p>
</li>
<li><p>标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。</p>
<h3 id="7-G1-收集器"><a href="#7-G1-收集器" class="headerlink" title="7. G1 收集器"></a>7. G1 收集器</h3><p><img src="/uploads/java/jvm/CMS%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="CMS收集器"><br>G1（Garbage-First），它是一款面向<strong>服务端应用</strong>的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。</p>
<p>堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。</p>
<p><img src="/uploads/java/jvm/HotspotHeapStructure.png" alt="HotspotHeapStructure"><br>G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。         </p>
<p><img src="/uploads/java/jvm/G1HeapAllocation.png" alt="G1HeapAllocation"></p>
<p>通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。</p>
<p>每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。</p>
<p><img src="/uploads/java/jvm/G1%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="G1收集器">   </p>
<p>如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：</p>
</li>
<li><p>初始标记</p>
</li>
<li><p>并发标记</p>
</li>
<li><p>重新标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。</p>
</li>
<li><p>并发清除：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</p>
<p>具备如下特点：</p>
</li>
<li><p>空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。</p>
</li>
<li><p>可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。Full GC。</p>
</li>
</ul>
<h1 id="四：内存分配与回收策略"><a href="#四：内存分配与回收策略" class="headerlink" title="四：内存分配与回收策略"></a>四：内存分配与回收策略</h1><h2 id="Minor-GC-和-Full-GC"><a href="#Minor-GC-和-Full-GC" class="headerlink" title="Minor GC 和 Full GC"></a>Minor GC 和 Full GC</h2><ul>
<li>Minor GC：发生在新生代上，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。</li>
<li>Full GC：发生在老年代上，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。</li>
</ul>
<h2 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h2><h3 id="1-对象优先在Eden分配"><a href="#1-对象优先在Eden分配" class="headerlink" title="1.对象优先在Eden分配"></a>1.对象优先在Eden分配</h3><p>   大多数情况下，对象在新生代 Eden 区分配，当 Eden 区空间不够时，发起 Minor GC。</p>
<h3 id="2-大对象直接进入老年代"><a href="#2-大对象直接进入老年代" class="headerlink" title="2.大对象直接进入老年代"></a>2.大对象直接进入老年代</h3><p>   大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。</p>
<p>   经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。</p>
<p>   -XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 区和 Survivor 区之间的大量内存复制。</p>
<h3 id="3-长期存活的对象进入老年代"><a href="#3-长期存活的对象进入老年代" class="headerlink" title="3.长期存活的对象进入老年代"></a>3.长期存活的对象进入老年代</h3><p>   为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。</p>
<p>   -XX:MaxTenuringThreshold 用来定义年龄的阈值。</p>
<h3 id="4-动态对象年龄判定"><a href="#4-动态对象年龄判定" class="headerlink" title="4.动态对象年龄判定"></a>4.动态对象年龄判定</h3><p>   虚拟机并不是永远地要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。</p>
<h3 id="5-空间分配担保"><a href="#5-空间分配担保" class="headerlink" title="5.空间分配担保"></a>5.空间分配担保</h3><p>   在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。</p>
<p>   如果不成立的话虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 设置不允许冒险，那么就要进行一次 Full GC。</p>
<h2 id="Full-GC-的触发条件"><a href="#Full-GC-的触发条件" class="headerlink" title="Full GC 的触发条件"></a>Full GC 的触发条件</h2><p>   对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件： </p>
<h5 id="1-调用-System-gc"><a href="#1-调用-System-gc" class="headerlink" title="1.调用 System.gc()"></a>1.调用 System.gc()</h5><p>   只是建议虚拟机执行 Full GC，<strong>但是虚拟机不一定真正去执行</strong>。不建议使用这种方式，而是让虚拟机管理内存。</p>
<h3 id="2-老年代空间不足"><a href="#2-老年代空间不足" class="headerlink" title="2.老年代空间不足"></a>2.老年代空间不足</h3><p>   老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。</p>
<p>   为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数<strong>调大新生代的大小</strong>，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold <strong>调大对象进入老年代的年龄</strong>，让对象在新生代多存活一段时间。</p>
<h3 id="3-空间分配担保失败"><a href="#3-空间分配担保失败" class="headerlink" title="3.空间分配担保失败"></a>3.空间分配担保失败</h3><p>   使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。   </p>
<p>   ####4.JDK 1.7 及以前的永久代空间不足<br>   在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。</p>
<p>   当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。</p>
<p>   为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。</p>
<h3 id="5-Concurrent-Mode-Failure"><a href="#5-Concurrent-Mode-Failure" class="headerlink" title="5.Concurrent Mode Failure"></a>5.Concurrent Mode Failure</h3><p>   执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。</p>
<h1 id="五：类加载机制"><a href="#五：类加载机制" class="headerlink" title="五：类加载机制"></a>五：类加载机制</h1><p>类是在运行期间第一次使用时动态加载的，而不是编译时期一次性加载。因为如果在编译时期一次性加载，那么会占用很多的内存。</p>
<h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h2><p><img src="/uploads/java/jvm/%E7%B1%BB%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg" alt="类生命周期">   </p>
<h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><p>   ####加载<br>   查找并加载类的二进制数据加载时类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情： </p>
<ul>
<li><p>通过一个类的全限定名来获取其定义的二进制字节流。</p>
</li>
<li><p>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</p>
</li>
<li><p>在Java堆中生成一个代表这个类的 java.lang.Class对象，作为对方法区中这些数据的访问入口。</p>
<p>相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</p>
<p>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个 java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据。</p>
<h3 id="验证：确保被加载的类的正确性"><a href="#验证：确保被加载的类的正确性" class="headerlink" title="验证：确保被加载的类的正确性"></a>验证：确保被加载的类的正确性</h3><p>验证是连接阶段的第一步，目的是保证加载的类符合当前虚拟机的要求。验证阶段大致分四步：</p>
</li>
<li><p>文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以 0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</p>
</li>
<li><p>元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了 java.lang.Object之外。</p>
</li>
<li><p>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</p>
</li>
<li><p>符号引用验证：确保解析动作能正确执行。</p>
<p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用 -Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p>
<h3 id="准备：为类的静态变量分配内存，初始化默认值-类型默认值-不是程序赋值"><a href="#准备：为类的静态变量分配内存，初始化默认值-类型默认值-不是程序赋值" class="headerlink" title="准备：为类的静态变量分配内存，初始化默认值 类型默认值 不是程序赋值"></a>准备：为<strong>类的静态变量</strong>分配内存，初始化默认值 类型默认值 不是程序赋值</h3><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：</p>
</li>
<li><p>这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。</p>
</li>
<li><p>这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。</p>
</li>
<li><p>如果类字段的字段属性表中存在 ConstantValue属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。</p>
<h3 id="解析：把类中的符号引用转换为直接引用"><a href="#解析：把类中的符号引用转换为直接引用" class="headerlink" title="解析：把类中的符号引用转换为直接引用"></a>解析：把类中的符号引用转换为直接引用</h3><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。</p>
<p>直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化 "></a>初始化 <clinit></clinit></h3><p>初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：</p>
</li>
<li><p>声明类变量是指定初始值</p>
</li>
<li><p>使用静态代码块为类变量指定初始值</p>
<p>初始化步骤：</p>
</li>
<li><p>假如这个类还没有被加载和连接，则程序先加载并连接该类</p>
</li>
<li><p>假如该类的直接父类还没有被初始化，则先初始化其直接父类</p>
</li>
<li><p>假如类中有初始化语句，则系统依次执行这些初始化语句</p>
<p>类初始化时机（主动，被动）</p>
<p>只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种：</p>
</li>
<li><p>创建类的实例，也就是new的方式 </p>
</li>
<li><p>反射（如 Class.forName(“com.Test”)</p>
</li>
<li><p>访问某个类或接口的静态变量，或者对该静态变量赋值</p>
</li>
<li><p>调用类的静态方法</p>
</li>
<li><p>初始化某个类的子类，则其父类也会被初始化</p>
</li>
<li><p>Java虚拟机启动时被标明为启动类的类（ JavaTest），直接使用 java.exe命令来运行某个主类</p>
<p>被动引用的常见例子包括：</p>
</li>
<li><p>通过子类引用父类的静态字段，不会导致子类初始化。 </p>
<blockquote>
<p>System.out.println(SubClass.value);  // value 字段在 SuperClass 中定义</p>
</blockquote>
</li>
<li><p>通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。</p>
<blockquote>
<p>SuperClass[] sca = new SuperClass[10];</p>
</blockquote>
</li>
<li><p>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</p>
<blockquote>
<p>System.out.println(ConstClass.HELLOWORLD);</p>
</blockquote>
<h3 id="结束生命周期"><a href="#结束生命周期" class="headerlink" title="结束生命周期"></a>结束生命周期</h3></li>
<li><p>执行了System.exit()方法</p>
</li>
<li><p>程序正常执行结束</p>
</li>
<li><p>程序在执行过程中遇到了异常或错误而异常终止</p>
</li>
<li><p>由于操作系统出现错误而导致Java虚拟机进程终止</p>
</li>
</ul>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2>]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
</search>
